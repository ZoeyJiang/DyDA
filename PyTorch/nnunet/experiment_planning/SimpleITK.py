# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_SimpleITK')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_SimpleITK')
    _SimpleITK = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_SimpleITK', [dirname(__file__)])
        except ImportError:
            import _SimpleITK
            return _SimpleITK
        if fp is not None:
            try:
                _mod = imp.load_module('_SimpleITK', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _SimpleITK = swig_import_helper()
    del swig_import_helper
else:
    import _SimpleITK
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator_value(self)


    def incr(self, n=1):
        """incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _SimpleITK.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _SimpleITK.SwigPyIterator_equal(self, x)


    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_copy(self)


    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator_next(self)


    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator___next__(self)


    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _SimpleITK.SwigPyIterator_previous(self)


    def advance(self, n):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _SimpleITK.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _SimpleITK.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _SimpleITK.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _SimpleITK.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _SimpleITK.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class VectorBool(_object):
    """Proxy of C++ std::vector<(bool)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorBool, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorBool self) -> SwigPyIterator"""
        return _SimpleITK.VectorBool_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorBool self) -> bool"""
        return _SimpleITK.VectorBool___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorBool self) -> bool"""
        return _SimpleITK.VectorBool___bool__(self)


    def __len__(self):
        """__len__(VectorBool self) -> std::vector< bool >::size_type"""
        return _SimpleITK.VectorBool___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> VectorBool"""
        return _SimpleITK.VectorBool___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        __setslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, VectorBool v)
        """
        return _SimpleITK.VectorBool___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _SimpleITK.VectorBool___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorBool self, std::vector< bool >::difference_type i)
        __delitem__(VectorBool self, PySliceObject * slice)
        """
        return _SimpleITK.VectorBool___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorBool self, PySliceObject * slice) -> VectorBool
        __getitem__(VectorBool self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _SimpleITK.VectorBool___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorBool self, PySliceObject * slice, VectorBool v)
        __setitem__(VectorBool self, PySliceObject * slice)
        __setitem__(VectorBool self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _SimpleITK.VectorBool___setitem__(self, *args)


    def pop(self):
        """pop(VectorBool self) -> std::vector< bool >::value_type"""
        return _SimpleITK.VectorBool_pop(self)


    def append(self, x):
        """append(VectorBool self, std::vector< bool >::value_type x)"""
        return _SimpleITK.VectorBool_append(self, x)


    def empty(self):
        """empty(VectorBool self) -> bool"""
        return _SimpleITK.VectorBool_empty(self)


    def size(self):
        """size(VectorBool self) -> std::vector< bool >::size_type"""
        return _SimpleITK.VectorBool_size(self)


    def swap(self, v):
        """swap(VectorBool self, VectorBool v)"""
        return _SimpleITK.VectorBool_swap(self, v)


    def begin(self):
        """begin(VectorBool self) -> std::vector< bool >::iterator"""
        return _SimpleITK.VectorBool_begin(self)


    def end(self):
        """end(VectorBool self) -> std::vector< bool >::iterator"""
        return _SimpleITK.VectorBool_end(self)


    def rbegin(self):
        """rbegin(VectorBool self) -> std::vector< bool >::reverse_iterator"""
        return _SimpleITK.VectorBool_rbegin(self)


    def rend(self):
        """rend(VectorBool self) -> std::vector< bool >::reverse_iterator"""
        return _SimpleITK.VectorBool_rend(self)


    def clear(self):
        """clear(VectorBool self)"""
        return _SimpleITK.VectorBool_clear(self)


    def get_allocator(self):
        """get_allocator(VectorBool self) -> std::vector< bool >::allocator_type"""
        return _SimpleITK.VectorBool_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorBool self)"""
        return _SimpleITK.VectorBool_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorBool self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(VectorBool self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _SimpleITK.VectorBool_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(bool)> self) -> VectorBool
        __init__(std::vector<(bool)> self, VectorBool arg2) -> VectorBool
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size) -> VectorBool
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> VectorBool
        """
        this = _SimpleITK.new_VectorBool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorBool self, std::vector< bool >::value_type x)"""
        return _SimpleITK.VectorBool_push_back(self, x)


    def front(self):
        """front(VectorBool self) -> std::vector< bool >::value_type"""
        return _SimpleITK.VectorBool_front(self)


    def back(self):
        """back(VectorBool self) -> std::vector< bool >::value_type"""
        return _SimpleITK.VectorBool_back(self)


    def assign(self, n, x):
        """assign(VectorBool self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _SimpleITK.VectorBool_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorBool self, std::vector< bool >::size_type new_size)
        resize(VectorBool self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _SimpleITK.VectorBool_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorBool self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(VectorBool self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _SimpleITK.VectorBool_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorBool self, std::vector< bool >::size_type n)"""
        return _SimpleITK.VectorBool_reserve(self, n)


    def capacity(self):
        """capacity(VectorBool self) -> std::vector< bool >::size_type"""
        return _SimpleITK.VectorBool_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorBool
    __del__ = lambda self: None
VectorBool_swigregister = _SimpleITK.VectorBool_swigregister
VectorBool_swigregister(VectorBool)

class VectorUInt8(_object):
    """Proxy of C++ std::vector<(uint8_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUInt8, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUInt8, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorUInt8 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt8_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorUInt8 self) -> bool"""
        return _SimpleITK.VectorUInt8___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorUInt8 self) -> bool"""
        return _SimpleITK.VectorUInt8___bool__(self)


    def __len__(self):
        """__len__(VectorUInt8 self) -> std::vector< unsigned char >::size_type"""
        return _SimpleITK.VectorUInt8___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j) -> VectorUInt8"""
        return _SimpleITK.VectorUInt8___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)
        __setslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j, VectorUInt8 v)
        """
        return _SimpleITK.VectorUInt8___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)"""
        return _SimpleITK.VectorUInt8___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorUInt8 self, std::vector< unsigned char >::difference_type i)
        __delitem__(VectorUInt8 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorUInt8___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorUInt8 self, PySliceObject * slice) -> VectorUInt8
        __getitem__(VectorUInt8 self, std::vector< unsigned char >::difference_type i) -> std::vector< unsigned char >::value_type const &
        """
        return _SimpleITK.VectorUInt8___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorUInt8 self, PySliceObject * slice, VectorUInt8 v)
        __setitem__(VectorUInt8 self, PySliceObject * slice)
        __setitem__(VectorUInt8 self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::value_type const & x)
        """
        return _SimpleITK.VectorUInt8___setitem__(self, *args)


    def pop(self):
        """pop(VectorUInt8 self) -> std::vector< unsigned char >::value_type"""
        return _SimpleITK.VectorUInt8_pop(self)


    def append(self, x):
        """append(VectorUInt8 self, std::vector< unsigned char >::value_type const & x)"""
        return _SimpleITK.VectorUInt8_append(self, x)


    def empty(self):
        """empty(VectorUInt8 self) -> bool"""
        return _SimpleITK.VectorUInt8_empty(self)


    def size(self):
        """size(VectorUInt8 self) -> std::vector< unsigned char >::size_type"""
        return _SimpleITK.VectorUInt8_size(self)


    def swap(self, v):
        """swap(VectorUInt8 self, VectorUInt8 v)"""
        return _SimpleITK.VectorUInt8_swap(self, v)


    def begin(self):
        """begin(VectorUInt8 self) -> std::vector< unsigned char >::iterator"""
        return _SimpleITK.VectorUInt8_begin(self)


    def end(self):
        """end(VectorUInt8 self) -> std::vector< unsigned char >::iterator"""
        return _SimpleITK.VectorUInt8_end(self)


    def rbegin(self):
        """rbegin(VectorUInt8 self) -> std::vector< unsigned char >::reverse_iterator"""
        return _SimpleITK.VectorUInt8_rbegin(self)


    def rend(self):
        """rend(VectorUInt8 self) -> std::vector< unsigned char >::reverse_iterator"""
        return _SimpleITK.VectorUInt8_rend(self)


    def clear(self):
        """clear(VectorUInt8 self)"""
        return _SimpleITK.VectorUInt8_clear(self)


    def get_allocator(self):
        """get_allocator(VectorUInt8 self) -> std::vector< unsigned char >::allocator_type"""
        return _SimpleITK.VectorUInt8_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorUInt8 self)"""
        return _SimpleITK.VectorUInt8_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorUInt8 self, std::vector< unsigned char >::iterator pos) -> std::vector< unsigned char >::iterator
        erase(VectorUInt8 self, std::vector< unsigned char >::iterator first, std::vector< unsigned char >::iterator last) -> std::vector< unsigned char >::iterator
        """
        return _SimpleITK.VectorUInt8_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(uint8_t)> self) -> VectorUInt8
        __init__(std::vector<(uint8_t)> self, VectorUInt8 arg2) -> VectorUInt8
        __init__(std::vector<(uint8_t)> self, std::vector< unsigned char >::size_type size) -> VectorUInt8
        __init__(std::vector<(uint8_t)> self, std::vector< unsigned char >::size_type size, std::vector< unsigned char >::value_type const & value) -> VectorUInt8
        """
        this = _SimpleITK.new_VectorUInt8(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorUInt8 self, std::vector< unsigned char >::value_type const & x)"""
        return _SimpleITK.VectorUInt8_push_back(self, x)


    def front(self):
        """front(VectorUInt8 self) -> std::vector< unsigned char >::value_type const &"""
        return _SimpleITK.VectorUInt8_front(self)


    def back(self):
        """back(VectorUInt8 self) -> std::vector< unsigned char >::value_type const &"""
        return _SimpleITK.VectorUInt8_back(self)


    def assign(self, n, x):
        """assign(VectorUInt8 self, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)"""
        return _SimpleITK.VectorUInt8_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorUInt8 self, std::vector< unsigned char >::size_type new_size)
        resize(VectorUInt8 self, std::vector< unsigned char >::size_type new_size, std::vector< unsigned char >::value_type const & x)
        """
        return _SimpleITK.VectorUInt8_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorUInt8 self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::value_type const & x) -> std::vector< unsigned char >::iterator
        insert(VectorUInt8 self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)
        """
        return _SimpleITK.VectorUInt8_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorUInt8 self, std::vector< unsigned char >::size_type n)"""
        return _SimpleITK.VectorUInt8_reserve(self, n)


    def capacity(self):
        """capacity(VectorUInt8 self) -> std::vector< unsigned char >::size_type"""
        return _SimpleITK.VectorUInt8_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt8
    __del__ = lambda self: None
VectorUInt8_swigregister = _SimpleITK.VectorUInt8_swigregister
VectorUInt8_swigregister(VectorUInt8)

class VectorInt8(_object):
    """Proxy of C++ std::vector<(int8_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt8, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt8, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorInt8 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt8_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorInt8 self) -> bool"""
        return _SimpleITK.VectorInt8___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorInt8 self) -> bool"""
        return _SimpleITK.VectorInt8___bool__(self)


    def __len__(self):
        """__len__(VectorInt8 self) -> std::vector< signed char >::size_type"""
        return _SimpleITK.VectorInt8___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j) -> VectorInt8"""
        return _SimpleITK.VectorInt8___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j)
        __setslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j, VectorInt8 v)
        """
        return _SimpleITK.VectorInt8___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j)"""
        return _SimpleITK.VectorInt8___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorInt8 self, std::vector< signed char >::difference_type i)
        __delitem__(VectorInt8 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorInt8___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorInt8 self, PySliceObject * slice) -> VectorInt8
        __getitem__(VectorInt8 self, std::vector< signed char >::difference_type i) -> std::vector< signed char >::value_type const &
        """
        return _SimpleITK.VectorInt8___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorInt8 self, PySliceObject * slice, VectorInt8 v)
        __setitem__(VectorInt8 self, PySliceObject * slice)
        __setitem__(VectorInt8 self, std::vector< signed char >::difference_type i, std::vector< signed char >::value_type const & x)
        """
        return _SimpleITK.VectorInt8___setitem__(self, *args)


    def pop(self):
        """pop(VectorInt8 self) -> std::vector< signed char >::value_type"""
        return _SimpleITK.VectorInt8_pop(self)


    def append(self, x):
        """append(VectorInt8 self, std::vector< signed char >::value_type const & x)"""
        return _SimpleITK.VectorInt8_append(self, x)


    def empty(self):
        """empty(VectorInt8 self) -> bool"""
        return _SimpleITK.VectorInt8_empty(self)


    def size(self):
        """size(VectorInt8 self) -> std::vector< signed char >::size_type"""
        return _SimpleITK.VectorInt8_size(self)


    def swap(self, v):
        """swap(VectorInt8 self, VectorInt8 v)"""
        return _SimpleITK.VectorInt8_swap(self, v)


    def begin(self):
        """begin(VectorInt8 self) -> std::vector< signed char >::iterator"""
        return _SimpleITK.VectorInt8_begin(self)


    def end(self):
        """end(VectorInt8 self) -> std::vector< signed char >::iterator"""
        return _SimpleITK.VectorInt8_end(self)


    def rbegin(self):
        """rbegin(VectorInt8 self) -> std::vector< signed char >::reverse_iterator"""
        return _SimpleITK.VectorInt8_rbegin(self)


    def rend(self):
        """rend(VectorInt8 self) -> std::vector< signed char >::reverse_iterator"""
        return _SimpleITK.VectorInt8_rend(self)


    def clear(self):
        """clear(VectorInt8 self)"""
        return _SimpleITK.VectorInt8_clear(self)


    def get_allocator(self):
        """get_allocator(VectorInt8 self) -> std::vector< signed char >::allocator_type"""
        return _SimpleITK.VectorInt8_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorInt8 self)"""
        return _SimpleITK.VectorInt8_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorInt8 self, std::vector< signed char >::iterator pos) -> std::vector< signed char >::iterator
        erase(VectorInt8 self, std::vector< signed char >::iterator first, std::vector< signed char >::iterator last) -> std::vector< signed char >::iterator
        """
        return _SimpleITK.VectorInt8_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int8_t)> self) -> VectorInt8
        __init__(std::vector<(int8_t)> self, VectorInt8 arg2) -> VectorInt8
        __init__(std::vector<(int8_t)> self, std::vector< signed char >::size_type size) -> VectorInt8
        __init__(std::vector<(int8_t)> self, std::vector< signed char >::size_type size, std::vector< signed char >::value_type const & value) -> VectorInt8
        """
        this = _SimpleITK.new_VectorInt8(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorInt8 self, std::vector< signed char >::value_type const & x)"""
        return _SimpleITK.VectorInt8_push_back(self, x)


    def front(self):
        """front(VectorInt8 self) -> std::vector< signed char >::value_type const &"""
        return _SimpleITK.VectorInt8_front(self)


    def back(self):
        """back(VectorInt8 self) -> std::vector< signed char >::value_type const &"""
        return _SimpleITK.VectorInt8_back(self)


    def assign(self, n, x):
        """assign(VectorInt8 self, std::vector< signed char >::size_type n, std::vector< signed char >::value_type const & x)"""
        return _SimpleITK.VectorInt8_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorInt8 self, std::vector< signed char >::size_type new_size)
        resize(VectorInt8 self, std::vector< signed char >::size_type new_size, std::vector< signed char >::value_type const & x)
        """
        return _SimpleITK.VectorInt8_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorInt8 self, std::vector< signed char >::iterator pos, std::vector< signed char >::value_type const & x) -> std::vector< signed char >::iterator
        insert(VectorInt8 self, std::vector< signed char >::iterator pos, std::vector< signed char >::size_type n, std::vector< signed char >::value_type const & x)
        """
        return _SimpleITK.VectorInt8_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorInt8 self, std::vector< signed char >::size_type n)"""
        return _SimpleITK.VectorInt8_reserve(self, n)


    def capacity(self):
        """capacity(VectorInt8 self) -> std::vector< signed char >::size_type"""
        return _SimpleITK.VectorInt8_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt8
    __del__ = lambda self: None
VectorInt8_swigregister = _SimpleITK.VectorInt8_swigregister
VectorInt8_swigregister(VectorInt8)

class VectorUInt16(_object):
    """Proxy of C++ std::vector<(uint16_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUInt16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUInt16, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorUInt16 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt16_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorUInt16 self) -> bool"""
        return _SimpleITK.VectorUInt16___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorUInt16 self) -> bool"""
        return _SimpleITK.VectorUInt16___bool__(self)


    def __len__(self):
        """__len__(VectorUInt16 self) -> std::vector< unsigned short >::size_type"""
        return _SimpleITK.VectorUInt16___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j) -> VectorUInt16"""
        return _SimpleITK.VectorUInt16___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j)
        __setslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j, VectorUInt16 v)
        """
        return _SimpleITK.VectorUInt16___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::difference_type j)"""
        return _SimpleITK.VectorUInt16___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorUInt16 self, std::vector< unsigned short >::difference_type i)
        __delitem__(VectorUInt16 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorUInt16___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorUInt16 self, PySliceObject * slice) -> VectorUInt16
        __getitem__(VectorUInt16 self, std::vector< unsigned short >::difference_type i) -> std::vector< unsigned short >::value_type const &
        """
        return _SimpleITK.VectorUInt16___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorUInt16 self, PySliceObject * slice, VectorUInt16 v)
        __setitem__(VectorUInt16 self, PySliceObject * slice)
        __setitem__(VectorUInt16 self, std::vector< unsigned short >::difference_type i, std::vector< unsigned short >::value_type const & x)
        """
        return _SimpleITK.VectorUInt16___setitem__(self, *args)


    def pop(self):
        """pop(VectorUInt16 self) -> std::vector< unsigned short >::value_type"""
        return _SimpleITK.VectorUInt16_pop(self)


    def append(self, x):
        """append(VectorUInt16 self, std::vector< unsigned short >::value_type const & x)"""
        return _SimpleITK.VectorUInt16_append(self, x)


    def empty(self):
        """empty(VectorUInt16 self) -> bool"""
        return _SimpleITK.VectorUInt16_empty(self)


    def size(self):
        """size(VectorUInt16 self) -> std::vector< unsigned short >::size_type"""
        return _SimpleITK.VectorUInt16_size(self)


    def swap(self, v):
        """swap(VectorUInt16 self, VectorUInt16 v)"""
        return _SimpleITK.VectorUInt16_swap(self, v)


    def begin(self):
        """begin(VectorUInt16 self) -> std::vector< unsigned short >::iterator"""
        return _SimpleITK.VectorUInt16_begin(self)


    def end(self):
        """end(VectorUInt16 self) -> std::vector< unsigned short >::iterator"""
        return _SimpleITK.VectorUInt16_end(self)


    def rbegin(self):
        """rbegin(VectorUInt16 self) -> std::vector< unsigned short >::reverse_iterator"""
        return _SimpleITK.VectorUInt16_rbegin(self)


    def rend(self):
        """rend(VectorUInt16 self) -> std::vector< unsigned short >::reverse_iterator"""
        return _SimpleITK.VectorUInt16_rend(self)


    def clear(self):
        """clear(VectorUInt16 self)"""
        return _SimpleITK.VectorUInt16_clear(self)


    def get_allocator(self):
        """get_allocator(VectorUInt16 self) -> std::vector< unsigned short >::allocator_type"""
        return _SimpleITK.VectorUInt16_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorUInt16 self)"""
        return _SimpleITK.VectorUInt16_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorUInt16 self, std::vector< unsigned short >::iterator pos) -> std::vector< unsigned short >::iterator
        erase(VectorUInt16 self, std::vector< unsigned short >::iterator first, std::vector< unsigned short >::iterator last) -> std::vector< unsigned short >::iterator
        """
        return _SimpleITK.VectorUInt16_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(uint16_t)> self) -> VectorUInt16
        __init__(std::vector<(uint16_t)> self, VectorUInt16 arg2) -> VectorUInt16
        __init__(std::vector<(uint16_t)> self, std::vector< unsigned short >::size_type size) -> VectorUInt16
        __init__(std::vector<(uint16_t)> self, std::vector< unsigned short >::size_type size, std::vector< unsigned short >::value_type const & value) -> VectorUInt16
        """
        this = _SimpleITK.new_VectorUInt16(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorUInt16 self, std::vector< unsigned short >::value_type const & x)"""
        return _SimpleITK.VectorUInt16_push_back(self, x)


    def front(self):
        """front(VectorUInt16 self) -> std::vector< unsigned short >::value_type const &"""
        return _SimpleITK.VectorUInt16_front(self)


    def back(self):
        """back(VectorUInt16 self) -> std::vector< unsigned short >::value_type const &"""
        return _SimpleITK.VectorUInt16_back(self)


    def assign(self, n, x):
        """assign(VectorUInt16 self, std::vector< unsigned short >::size_type n, std::vector< unsigned short >::value_type const & x)"""
        return _SimpleITK.VectorUInt16_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorUInt16 self, std::vector< unsigned short >::size_type new_size)
        resize(VectorUInt16 self, std::vector< unsigned short >::size_type new_size, std::vector< unsigned short >::value_type const & x)
        """
        return _SimpleITK.VectorUInt16_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorUInt16 self, std::vector< unsigned short >::iterator pos, std::vector< unsigned short >::value_type const & x) -> std::vector< unsigned short >::iterator
        insert(VectorUInt16 self, std::vector< unsigned short >::iterator pos, std::vector< unsigned short >::size_type n, std::vector< unsigned short >::value_type const & x)
        """
        return _SimpleITK.VectorUInt16_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorUInt16 self, std::vector< unsigned short >::size_type n)"""
        return _SimpleITK.VectorUInt16_reserve(self, n)


    def capacity(self):
        """capacity(VectorUInt16 self) -> std::vector< unsigned short >::size_type"""
        return _SimpleITK.VectorUInt16_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt16
    __del__ = lambda self: None
VectorUInt16_swigregister = _SimpleITK.VectorUInt16_swigregister
VectorUInt16_swigregister(VectorUInt16)

class VectorInt16(_object):
    """Proxy of C++ std::vector<(int16_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt16, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorInt16 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt16_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorInt16 self) -> bool"""
        return _SimpleITK.VectorInt16___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorInt16 self) -> bool"""
        return _SimpleITK.VectorInt16___bool__(self)


    def __len__(self):
        """__len__(VectorInt16 self) -> std::vector< short >::size_type"""
        return _SimpleITK.VectorInt16___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j) -> VectorInt16"""
        return _SimpleITK.VectorInt16___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)
        __setslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j, VectorInt16 v)
        """
        return _SimpleITK.VectorInt16___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::difference_type j)"""
        return _SimpleITK.VectorInt16___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorInt16 self, std::vector< short >::difference_type i)
        __delitem__(VectorInt16 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorInt16___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorInt16 self, PySliceObject * slice) -> VectorInt16
        __getitem__(VectorInt16 self, std::vector< short >::difference_type i) -> std::vector< short >::value_type const &
        """
        return _SimpleITK.VectorInt16___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorInt16 self, PySliceObject * slice, VectorInt16 v)
        __setitem__(VectorInt16 self, PySliceObject * slice)
        __setitem__(VectorInt16 self, std::vector< short >::difference_type i, std::vector< short >::value_type const & x)
        """
        return _SimpleITK.VectorInt16___setitem__(self, *args)


    def pop(self):
        """pop(VectorInt16 self) -> std::vector< short >::value_type"""
        return _SimpleITK.VectorInt16_pop(self)


    def append(self, x):
        """append(VectorInt16 self, std::vector< short >::value_type const & x)"""
        return _SimpleITK.VectorInt16_append(self, x)


    def empty(self):
        """empty(VectorInt16 self) -> bool"""
        return _SimpleITK.VectorInt16_empty(self)


    def size(self):
        """size(VectorInt16 self) -> std::vector< short >::size_type"""
        return _SimpleITK.VectorInt16_size(self)


    def swap(self, v):
        """swap(VectorInt16 self, VectorInt16 v)"""
        return _SimpleITK.VectorInt16_swap(self, v)


    def begin(self):
        """begin(VectorInt16 self) -> std::vector< short >::iterator"""
        return _SimpleITK.VectorInt16_begin(self)


    def end(self):
        """end(VectorInt16 self) -> std::vector< short >::iterator"""
        return _SimpleITK.VectorInt16_end(self)


    def rbegin(self):
        """rbegin(VectorInt16 self) -> std::vector< short >::reverse_iterator"""
        return _SimpleITK.VectorInt16_rbegin(self)


    def rend(self):
        """rend(VectorInt16 self) -> std::vector< short >::reverse_iterator"""
        return _SimpleITK.VectorInt16_rend(self)


    def clear(self):
        """clear(VectorInt16 self)"""
        return _SimpleITK.VectorInt16_clear(self)


    def get_allocator(self):
        """get_allocator(VectorInt16 self) -> std::vector< short >::allocator_type"""
        return _SimpleITK.VectorInt16_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorInt16 self)"""
        return _SimpleITK.VectorInt16_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorInt16 self, std::vector< short >::iterator pos) -> std::vector< short >::iterator
        erase(VectorInt16 self, std::vector< short >::iterator first, std::vector< short >::iterator last) -> std::vector< short >::iterator
        """
        return _SimpleITK.VectorInt16_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int16_t)> self) -> VectorInt16
        __init__(std::vector<(int16_t)> self, VectorInt16 arg2) -> VectorInt16
        __init__(std::vector<(int16_t)> self, std::vector< short >::size_type size) -> VectorInt16
        __init__(std::vector<(int16_t)> self, std::vector< short >::size_type size, std::vector< short >::value_type const & value) -> VectorInt16
        """
        this = _SimpleITK.new_VectorInt16(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorInt16 self, std::vector< short >::value_type const & x)"""
        return _SimpleITK.VectorInt16_push_back(self, x)


    def front(self):
        """front(VectorInt16 self) -> std::vector< short >::value_type const &"""
        return _SimpleITK.VectorInt16_front(self)


    def back(self):
        """back(VectorInt16 self) -> std::vector< short >::value_type const &"""
        return _SimpleITK.VectorInt16_back(self)


    def assign(self, n, x):
        """assign(VectorInt16 self, std::vector< short >::size_type n, std::vector< short >::value_type const & x)"""
        return _SimpleITK.VectorInt16_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorInt16 self, std::vector< short >::size_type new_size)
        resize(VectorInt16 self, std::vector< short >::size_type new_size, std::vector< short >::value_type const & x)
        """
        return _SimpleITK.VectorInt16_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorInt16 self, std::vector< short >::iterator pos, std::vector< short >::value_type const & x) -> std::vector< short >::iterator
        insert(VectorInt16 self, std::vector< short >::iterator pos, std::vector< short >::size_type n, std::vector< short >::value_type const & x)
        """
        return _SimpleITK.VectorInt16_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorInt16 self, std::vector< short >::size_type n)"""
        return _SimpleITK.VectorInt16_reserve(self, n)


    def capacity(self):
        """capacity(VectorInt16 self) -> std::vector< short >::size_type"""
        return _SimpleITK.VectorInt16_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt16
    __del__ = lambda self: None
VectorInt16_swigregister = _SimpleITK.VectorInt16_swigregister
VectorInt16_swigregister(VectorInt16)

class VectorUInt32(_object):
    """Proxy of C++ std::vector<(uint32_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUInt32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUInt32, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorUInt32 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt32_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorUInt32 self) -> bool"""
        return _SimpleITK.VectorUInt32___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorUInt32 self) -> bool"""
        return _SimpleITK.VectorUInt32___bool__(self)


    def __len__(self):
        """__len__(VectorUInt32 self) -> std::vector< unsigned int >::size_type"""
        return _SimpleITK.VectorUInt32___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> VectorUInt32"""
        return _SimpleITK.VectorUInt32___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, VectorUInt32 v)
        """
        return _SimpleITK.VectorUInt32___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _SimpleITK.VectorUInt32___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorUInt32 self, std::vector< unsigned int >::difference_type i)
        __delitem__(VectorUInt32 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorUInt32___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorUInt32 self, PySliceObject * slice) -> VectorUInt32
        __getitem__(VectorUInt32 self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _SimpleITK.VectorUInt32___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorUInt32 self, PySliceObject * slice, VectorUInt32 v)
        __setitem__(VectorUInt32 self, PySliceObject * slice)
        __setitem__(VectorUInt32 self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _SimpleITK.VectorUInt32___setitem__(self, *args)


    def pop(self):
        """pop(VectorUInt32 self) -> std::vector< unsigned int >::value_type"""
        return _SimpleITK.VectorUInt32_pop(self)


    def append(self, x):
        """append(VectorUInt32 self, std::vector< unsigned int >::value_type const & x)"""
        return _SimpleITK.VectorUInt32_append(self, x)


    def empty(self):
        """empty(VectorUInt32 self) -> bool"""
        return _SimpleITK.VectorUInt32_empty(self)


    def size(self):
        """size(VectorUInt32 self) -> std::vector< unsigned int >::size_type"""
        return _SimpleITK.VectorUInt32_size(self)


    def swap(self, v):
        """swap(VectorUInt32 self, VectorUInt32 v)"""
        return _SimpleITK.VectorUInt32_swap(self, v)


    def begin(self):
        """begin(VectorUInt32 self) -> std::vector< unsigned int >::iterator"""
        return _SimpleITK.VectorUInt32_begin(self)


    def end(self):
        """end(VectorUInt32 self) -> std::vector< unsigned int >::iterator"""
        return _SimpleITK.VectorUInt32_end(self)


    def rbegin(self):
        """rbegin(VectorUInt32 self) -> std::vector< unsigned int >::reverse_iterator"""
        return _SimpleITK.VectorUInt32_rbegin(self)


    def rend(self):
        """rend(VectorUInt32 self) -> std::vector< unsigned int >::reverse_iterator"""
        return _SimpleITK.VectorUInt32_rend(self)


    def clear(self):
        """clear(VectorUInt32 self)"""
        return _SimpleITK.VectorUInt32_clear(self)


    def get_allocator(self):
        """get_allocator(VectorUInt32 self) -> std::vector< unsigned int >::allocator_type"""
        return _SimpleITK.VectorUInt32_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorUInt32 self)"""
        return _SimpleITK.VectorUInt32_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorUInt32 self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(VectorUInt32 self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _SimpleITK.VectorUInt32_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(uint32_t)> self) -> VectorUInt32
        __init__(std::vector<(uint32_t)> self, VectorUInt32 arg2) -> VectorUInt32
        __init__(std::vector<(uint32_t)> self, std::vector< unsigned int >::size_type size) -> VectorUInt32
        __init__(std::vector<(uint32_t)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> VectorUInt32
        """
        this = _SimpleITK.new_VectorUInt32(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorUInt32 self, std::vector< unsigned int >::value_type const & x)"""
        return _SimpleITK.VectorUInt32_push_back(self, x)


    def front(self):
        """front(VectorUInt32 self) -> std::vector< unsigned int >::value_type const &"""
        return _SimpleITK.VectorUInt32_front(self)


    def back(self):
        """back(VectorUInt32 self) -> std::vector< unsigned int >::value_type const &"""
        return _SimpleITK.VectorUInt32_back(self)


    def assign(self, n, x):
        """assign(VectorUInt32 self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _SimpleITK.VectorUInt32_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorUInt32 self, std::vector< unsigned int >::size_type new_size)
        resize(VectorUInt32 self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _SimpleITK.VectorUInt32_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorUInt32 self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(VectorUInt32 self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _SimpleITK.VectorUInt32_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorUInt32 self, std::vector< unsigned int >::size_type n)"""
        return _SimpleITK.VectorUInt32_reserve(self, n)


    def capacity(self):
        """capacity(VectorUInt32 self) -> std::vector< unsigned int >::size_type"""
        return _SimpleITK.VectorUInt32_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt32
    __del__ = lambda self: None
VectorUInt32_swigregister = _SimpleITK.VectorUInt32_swigregister
VectorUInt32_swigregister(VectorUInt32)

class VectorInt32(_object):
    """Proxy of C++ std::vector<(int32_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt32, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorInt32 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt32_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorInt32 self) -> bool"""
        return _SimpleITK.VectorInt32___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorInt32 self) -> bool"""
        return _SimpleITK.VectorInt32___bool__(self)


    def __len__(self):
        """__len__(VectorInt32 self) -> std::vector< int >::size_type"""
        return _SimpleITK.VectorInt32___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> VectorInt32"""
        return _SimpleITK.VectorInt32___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, VectorInt32 v)
        """
        return _SimpleITK.VectorInt32___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _SimpleITK.VectorInt32___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorInt32 self, std::vector< int >::difference_type i)
        __delitem__(VectorInt32 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorInt32___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorInt32 self, PySliceObject * slice) -> VectorInt32
        __getitem__(VectorInt32 self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _SimpleITK.VectorInt32___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorInt32 self, PySliceObject * slice, VectorInt32 v)
        __setitem__(VectorInt32 self, PySliceObject * slice)
        __setitem__(VectorInt32 self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _SimpleITK.VectorInt32___setitem__(self, *args)


    def pop(self):
        """pop(VectorInt32 self) -> std::vector< int >::value_type"""
        return _SimpleITK.VectorInt32_pop(self)


    def append(self, x):
        """append(VectorInt32 self, std::vector< int >::value_type const & x)"""
        return _SimpleITK.VectorInt32_append(self, x)


    def empty(self):
        """empty(VectorInt32 self) -> bool"""
        return _SimpleITK.VectorInt32_empty(self)


    def size(self):
        """size(VectorInt32 self) -> std::vector< int >::size_type"""
        return _SimpleITK.VectorInt32_size(self)


    def swap(self, v):
        """swap(VectorInt32 self, VectorInt32 v)"""
        return _SimpleITK.VectorInt32_swap(self, v)


    def begin(self):
        """begin(VectorInt32 self) -> std::vector< int >::iterator"""
        return _SimpleITK.VectorInt32_begin(self)


    def end(self):
        """end(VectorInt32 self) -> std::vector< int >::iterator"""
        return _SimpleITK.VectorInt32_end(self)


    def rbegin(self):
        """rbegin(VectorInt32 self) -> std::vector< int >::reverse_iterator"""
        return _SimpleITK.VectorInt32_rbegin(self)


    def rend(self):
        """rend(VectorInt32 self) -> std::vector< int >::reverse_iterator"""
        return _SimpleITK.VectorInt32_rend(self)


    def clear(self):
        """clear(VectorInt32 self)"""
        return _SimpleITK.VectorInt32_clear(self)


    def get_allocator(self):
        """get_allocator(VectorInt32 self) -> std::vector< int >::allocator_type"""
        return _SimpleITK.VectorInt32_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorInt32 self)"""
        return _SimpleITK.VectorInt32_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorInt32 self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(VectorInt32 self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _SimpleITK.VectorInt32_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int32_t)> self) -> VectorInt32
        __init__(std::vector<(int32_t)> self, VectorInt32 arg2) -> VectorInt32
        __init__(std::vector<(int32_t)> self, std::vector< int >::size_type size) -> VectorInt32
        __init__(std::vector<(int32_t)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> VectorInt32
        """
        this = _SimpleITK.new_VectorInt32(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorInt32 self, std::vector< int >::value_type const & x)"""
        return _SimpleITK.VectorInt32_push_back(self, x)


    def front(self):
        """front(VectorInt32 self) -> std::vector< int >::value_type const &"""
        return _SimpleITK.VectorInt32_front(self)


    def back(self):
        """back(VectorInt32 self) -> std::vector< int >::value_type const &"""
        return _SimpleITK.VectorInt32_back(self)


    def assign(self, n, x):
        """assign(VectorInt32 self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _SimpleITK.VectorInt32_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorInt32 self, std::vector< int >::size_type new_size)
        resize(VectorInt32 self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _SimpleITK.VectorInt32_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorInt32 self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(VectorInt32 self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _SimpleITK.VectorInt32_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorInt32 self, std::vector< int >::size_type n)"""
        return _SimpleITK.VectorInt32_reserve(self, n)


    def capacity(self):
        """capacity(VectorInt32 self) -> std::vector< int >::size_type"""
        return _SimpleITK.VectorInt32_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt32
    __del__ = lambda self: None
VectorInt32_swigregister = _SimpleITK.VectorInt32_swigregister
VectorInt32_swigregister(VectorInt32)

class VectorUInt64(_object):
    """Proxy of C++ std::vector<(uint64_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUInt64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUInt64, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorUInt64 self) -> SwigPyIterator"""
        return _SimpleITK.VectorUInt64_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorUInt64 self) -> bool"""
        return _SimpleITK.VectorUInt64___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorUInt64 self) -> bool"""
        return _SimpleITK.VectorUInt64___bool__(self)


    def __len__(self):
        """__len__(VectorUInt64 self) -> std::vector< unsigned long >::size_type"""
        return _SimpleITK.VectorUInt64___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j) -> VectorUInt64"""
        return _SimpleITK.VectorUInt64___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)
        __setslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j, VectorUInt64 v)
        """
        return _SimpleITK.VectorUInt64___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::difference_type j)"""
        return _SimpleITK.VectorUInt64___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorUInt64 self, std::vector< unsigned long >::difference_type i)
        __delitem__(VectorUInt64 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorUInt64___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorUInt64 self, PySliceObject * slice) -> VectorUInt64
        __getitem__(VectorUInt64 self, std::vector< unsigned long >::difference_type i) -> std::vector< unsigned long >::value_type const &
        """
        return _SimpleITK.VectorUInt64___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorUInt64 self, PySliceObject * slice, VectorUInt64 v)
        __setitem__(VectorUInt64 self, PySliceObject * slice)
        __setitem__(VectorUInt64 self, std::vector< unsigned long >::difference_type i, std::vector< unsigned long >::value_type const & x)
        """
        return _SimpleITK.VectorUInt64___setitem__(self, *args)


    def pop(self):
        """pop(VectorUInt64 self) -> std::vector< unsigned long >::value_type"""
        return _SimpleITK.VectorUInt64_pop(self)


    def append(self, x):
        """append(VectorUInt64 self, std::vector< unsigned long >::value_type const & x)"""
        return _SimpleITK.VectorUInt64_append(self, x)


    def empty(self):
        """empty(VectorUInt64 self) -> bool"""
        return _SimpleITK.VectorUInt64_empty(self)


    def size(self):
        """size(VectorUInt64 self) -> std::vector< unsigned long >::size_type"""
        return _SimpleITK.VectorUInt64_size(self)


    def swap(self, v):
        """swap(VectorUInt64 self, VectorUInt64 v)"""
        return _SimpleITK.VectorUInt64_swap(self, v)


    def begin(self):
        """begin(VectorUInt64 self) -> std::vector< unsigned long >::iterator"""
        return _SimpleITK.VectorUInt64_begin(self)


    def end(self):
        """end(VectorUInt64 self) -> std::vector< unsigned long >::iterator"""
        return _SimpleITK.VectorUInt64_end(self)


    def rbegin(self):
        """rbegin(VectorUInt64 self) -> std::vector< unsigned long >::reverse_iterator"""
        return _SimpleITK.VectorUInt64_rbegin(self)


    def rend(self):
        """rend(VectorUInt64 self) -> std::vector< unsigned long >::reverse_iterator"""
        return _SimpleITK.VectorUInt64_rend(self)


    def clear(self):
        """clear(VectorUInt64 self)"""
        return _SimpleITK.VectorUInt64_clear(self)


    def get_allocator(self):
        """get_allocator(VectorUInt64 self) -> std::vector< unsigned long >::allocator_type"""
        return _SimpleITK.VectorUInt64_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorUInt64 self)"""
        return _SimpleITK.VectorUInt64_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorUInt64 self, std::vector< unsigned long >::iterator pos) -> std::vector< unsigned long >::iterator
        erase(VectorUInt64 self, std::vector< unsigned long >::iterator first, std::vector< unsigned long >::iterator last) -> std::vector< unsigned long >::iterator
        """
        return _SimpleITK.VectorUInt64_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(uint64_t)> self) -> VectorUInt64
        __init__(std::vector<(uint64_t)> self, VectorUInt64 arg2) -> VectorUInt64
        __init__(std::vector<(uint64_t)> self, std::vector< unsigned long >::size_type size) -> VectorUInt64
        __init__(std::vector<(uint64_t)> self, std::vector< unsigned long >::size_type size, std::vector< unsigned long >::value_type const & value) -> VectorUInt64
        """
        this = _SimpleITK.new_VectorUInt64(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorUInt64 self, std::vector< unsigned long >::value_type const & x)"""
        return _SimpleITK.VectorUInt64_push_back(self, x)


    def front(self):
        """front(VectorUInt64 self) -> std::vector< unsigned long >::value_type const &"""
        return _SimpleITK.VectorUInt64_front(self)


    def back(self):
        """back(VectorUInt64 self) -> std::vector< unsigned long >::value_type const &"""
        return _SimpleITK.VectorUInt64_back(self)


    def assign(self, n, x):
        """assign(VectorUInt64 self, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)"""
        return _SimpleITK.VectorUInt64_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorUInt64 self, std::vector< unsigned long >::size_type new_size)
        resize(VectorUInt64 self, std::vector< unsigned long >::size_type new_size, std::vector< unsigned long >::value_type const & x)
        """
        return _SimpleITK.VectorUInt64_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorUInt64 self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::value_type const & x) -> std::vector< unsigned long >::iterator
        insert(VectorUInt64 self, std::vector< unsigned long >::iterator pos, std::vector< unsigned long >::size_type n, std::vector< unsigned long >::value_type const & x)
        """
        return _SimpleITK.VectorUInt64_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorUInt64 self, std::vector< unsigned long >::size_type n)"""
        return _SimpleITK.VectorUInt64_reserve(self, n)


    def capacity(self):
        """capacity(VectorUInt64 self) -> std::vector< unsigned long >::size_type"""
        return _SimpleITK.VectorUInt64_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUInt64
    __del__ = lambda self: None
VectorUInt64_swigregister = _SimpleITK.VectorUInt64_swigregister
VectorUInt64_swigregister(VectorUInt64)

class VectorInt64(_object):
    """Proxy of C++ std::vector<(int64_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt64, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorInt64 self) -> SwigPyIterator"""
        return _SimpleITK.VectorInt64_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorInt64 self) -> bool"""
        return _SimpleITK.VectorInt64___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorInt64 self) -> bool"""
        return _SimpleITK.VectorInt64___bool__(self)


    def __len__(self):
        """__len__(VectorInt64 self) -> std::vector< long >::size_type"""
        return _SimpleITK.VectorInt64___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j) -> VectorInt64"""
        return _SimpleITK.VectorInt64___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)
        __setslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j, VectorInt64 v)
        """
        return _SimpleITK.VectorInt64___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)"""
        return _SimpleITK.VectorInt64___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorInt64 self, std::vector< long >::difference_type i)
        __delitem__(VectorInt64 self, PySliceObject * slice)
        """
        return _SimpleITK.VectorInt64___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorInt64 self, PySliceObject * slice) -> VectorInt64
        __getitem__(VectorInt64 self, std::vector< long >::difference_type i) -> std::vector< long >::value_type const &
        """
        return _SimpleITK.VectorInt64___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorInt64 self, PySliceObject * slice, VectorInt64 v)
        __setitem__(VectorInt64 self, PySliceObject * slice)
        __setitem__(VectorInt64 self, std::vector< long >::difference_type i, std::vector< long >::value_type const & x)
        """
        return _SimpleITK.VectorInt64___setitem__(self, *args)


    def pop(self):
        """pop(VectorInt64 self) -> std::vector< long >::value_type"""
        return _SimpleITK.VectorInt64_pop(self)


    def append(self, x):
        """append(VectorInt64 self, std::vector< long >::value_type const & x)"""
        return _SimpleITK.VectorInt64_append(self, x)


    def empty(self):
        """empty(VectorInt64 self) -> bool"""
        return _SimpleITK.VectorInt64_empty(self)


    def size(self):
        """size(VectorInt64 self) -> std::vector< long >::size_type"""
        return _SimpleITK.VectorInt64_size(self)


    def swap(self, v):
        """swap(VectorInt64 self, VectorInt64 v)"""
        return _SimpleITK.VectorInt64_swap(self, v)


    def begin(self):
        """begin(VectorInt64 self) -> std::vector< long >::iterator"""
        return _SimpleITK.VectorInt64_begin(self)


    def end(self):
        """end(VectorInt64 self) -> std::vector< long >::iterator"""
        return _SimpleITK.VectorInt64_end(self)


    def rbegin(self):
        """rbegin(VectorInt64 self) -> std::vector< long >::reverse_iterator"""
        return _SimpleITK.VectorInt64_rbegin(self)


    def rend(self):
        """rend(VectorInt64 self) -> std::vector< long >::reverse_iterator"""
        return _SimpleITK.VectorInt64_rend(self)


    def clear(self):
        """clear(VectorInt64 self)"""
        return _SimpleITK.VectorInt64_clear(self)


    def get_allocator(self):
        """get_allocator(VectorInt64 self) -> std::vector< long >::allocator_type"""
        return _SimpleITK.VectorInt64_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorInt64 self)"""
        return _SimpleITK.VectorInt64_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorInt64 self, std::vector< long >::iterator pos) -> std::vector< long >::iterator
        erase(VectorInt64 self, std::vector< long >::iterator first, std::vector< long >::iterator last) -> std::vector< long >::iterator
        """
        return _SimpleITK.VectorInt64_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int64_t)> self) -> VectorInt64
        __init__(std::vector<(int64_t)> self, VectorInt64 arg2) -> VectorInt64
        __init__(std::vector<(int64_t)> self, std::vector< long >::size_type size) -> VectorInt64
        __init__(std::vector<(int64_t)> self, std::vector< long >::size_type size, std::vector< long >::value_type const & value) -> VectorInt64
        """
        this = _SimpleITK.new_VectorInt64(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorInt64 self, std::vector< long >::value_type const & x)"""
        return _SimpleITK.VectorInt64_push_back(self, x)


    def front(self):
        """front(VectorInt64 self) -> std::vector< long >::value_type const &"""
        return _SimpleITK.VectorInt64_front(self)


    def back(self):
        """back(VectorInt64 self) -> std::vector< long >::value_type const &"""
        return _SimpleITK.VectorInt64_back(self)


    def assign(self, n, x):
        """assign(VectorInt64 self, std::vector< long >::size_type n, std::vector< long >::value_type const & x)"""
        return _SimpleITK.VectorInt64_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorInt64 self, std::vector< long >::size_type new_size)
        resize(VectorInt64 self, std::vector< long >::size_type new_size, std::vector< long >::value_type const & x)
        """
        return _SimpleITK.VectorInt64_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorInt64 self, std::vector< long >::iterator pos, std::vector< long >::value_type const & x) -> std::vector< long >::iterator
        insert(VectorInt64 self, std::vector< long >::iterator pos, std::vector< long >::size_type n, std::vector< long >::value_type const & x)
        """
        return _SimpleITK.VectorInt64_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorInt64 self, std::vector< long >::size_type n)"""
        return _SimpleITK.VectorInt64_reserve(self, n)


    def capacity(self):
        """capacity(VectorInt64 self) -> std::vector< long >::size_type"""
        return _SimpleITK.VectorInt64_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorInt64
    __del__ = lambda self: None
VectorInt64_swigregister = _SimpleITK.VectorInt64_swigregister
VectorInt64_swigregister(VectorInt64)

class VectorFloat(_object):
    """Proxy of C++ std::vector<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorFloat, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorFloat self) -> SwigPyIterator"""
        return _SimpleITK.VectorFloat_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorFloat self) -> bool"""
        return _SimpleITK.VectorFloat___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorFloat self) -> bool"""
        return _SimpleITK.VectorFloat___bool__(self)


    def __len__(self):
        """__len__(VectorFloat self) -> std::vector< float >::size_type"""
        return _SimpleITK.VectorFloat___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> VectorFloat"""
        return _SimpleITK.VectorFloat___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, VectorFloat v)
        """
        return _SimpleITK.VectorFloat___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _SimpleITK.VectorFloat___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorFloat self, std::vector< float >::difference_type i)
        __delitem__(VectorFloat self, PySliceObject * slice)
        """
        return _SimpleITK.VectorFloat___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorFloat self, PySliceObject * slice) -> VectorFloat
        __getitem__(VectorFloat self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _SimpleITK.VectorFloat___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorFloat self, PySliceObject * slice, VectorFloat v)
        __setitem__(VectorFloat self, PySliceObject * slice)
        __setitem__(VectorFloat self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _SimpleITK.VectorFloat___setitem__(self, *args)


    def pop(self):
        """pop(VectorFloat self) -> std::vector< float >::value_type"""
        return _SimpleITK.VectorFloat_pop(self)


    def append(self, x):
        """append(VectorFloat self, std::vector< float >::value_type const & x)"""
        return _SimpleITK.VectorFloat_append(self, x)


    def empty(self):
        """empty(VectorFloat self) -> bool"""
        return _SimpleITK.VectorFloat_empty(self)


    def size(self):
        """size(VectorFloat self) -> std::vector< float >::size_type"""
        return _SimpleITK.VectorFloat_size(self)


    def swap(self, v):
        """swap(VectorFloat self, VectorFloat v)"""
        return _SimpleITK.VectorFloat_swap(self, v)


    def begin(self):
        """begin(VectorFloat self) -> std::vector< float >::iterator"""
        return _SimpleITK.VectorFloat_begin(self)


    def end(self):
        """end(VectorFloat self) -> std::vector< float >::iterator"""
        return _SimpleITK.VectorFloat_end(self)


    def rbegin(self):
        """rbegin(VectorFloat self) -> std::vector< float >::reverse_iterator"""
        return _SimpleITK.VectorFloat_rbegin(self)


    def rend(self):
        """rend(VectorFloat self) -> std::vector< float >::reverse_iterator"""
        return _SimpleITK.VectorFloat_rend(self)


    def clear(self):
        """clear(VectorFloat self)"""
        return _SimpleITK.VectorFloat_clear(self)


    def get_allocator(self):
        """get_allocator(VectorFloat self) -> std::vector< float >::allocator_type"""
        return _SimpleITK.VectorFloat_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorFloat self)"""
        return _SimpleITK.VectorFloat_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorFloat self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(VectorFloat self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _SimpleITK.VectorFloat_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(float)> self) -> VectorFloat
        __init__(std::vector<(float)> self, VectorFloat arg2) -> VectorFloat
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> VectorFloat
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> VectorFloat
        """
        this = _SimpleITK.new_VectorFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorFloat self, std::vector< float >::value_type const & x)"""
        return _SimpleITK.VectorFloat_push_back(self, x)


    def front(self):
        """front(VectorFloat self) -> std::vector< float >::value_type const &"""
        return _SimpleITK.VectorFloat_front(self)


    def back(self):
        """back(VectorFloat self) -> std::vector< float >::value_type const &"""
        return _SimpleITK.VectorFloat_back(self)


    def assign(self, n, x):
        """assign(VectorFloat self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _SimpleITK.VectorFloat_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorFloat self, std::vector< float >::size_type new_size)
        resize(VectorFloat self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _SimpleITK.VectorFloat_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorFloat self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(VectorFloat self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _SimpleITK.VectorFloat_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorFloat self, std::vector< float >::size_type n)"""
        return _SimpleITK.VectorFloat_reserve(self, n)


    def capacity(self):
        """capacity(VectorFloat self) -> std::vector< float >::size_type"""
        return _SimpleITK.VectorFloat_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorFloat
    __del__ = lambda self: None
VectorFloat_swigregister = _SimpleITK.VectorFloat_swigregister
VectorFloat_swigregister(VectorFloat)

class VectorDouble(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorDouble, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorDouble self) -> SwigPyIterator"""
        return _SimpleITK.VectorDouble_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorDouble self) -> bool"""
        return _SimpleITK.VectorDouble___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorDouble self) -> bool"""
        return _SimpleITK.VectorDouble___bool__(self)


    def __len__(self):
        """__len__(VectorDouble self) -> std::vector< double >::size_type"""
        return _SimpleITK.VectorDouble___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> VectorDouble"""
        return _SimpleITK.VectorDouble___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, VectorDouble v)
        """
        return _SimpleITK.VectorDouble___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _SimpleITK.VectorDouble___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorDouble self, std::vector< double >::difference_type i)
        __delitem__(VectorDouble self, PySliceObject * slice)
        """
        return _SimpleITK.VectorDouble___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorDouble self, PySliceObject * slice) -> VectorDouble
        __getitem__(VectorDouble self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _SimpleITK.VectorDouble___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorDouble self, PySliceObject * slice, VectorDouble v)
        __setitem__(VectorDouble self, PySliceObject * slice)
        __setitem__(VectorDouble self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _SimpleITK.VectorDouble___setitem__(self, *args)


    def pop(self):
        """pop(VectorDouble self) -> std::vector< double >::value_type"""
        return _SimpleITK.VectorDouble_pop(self)


    def append(self, x):
        """append(VectorDouble self, std::vector< double >::value_type const & x)"""
        return _SimpleITK.VectorDouble_append(self, x)


    def empty(self):
        """empty(VectorDouble self) -> bool"""
        return _SimpleITK.VectorDouble_empty(self)


    def size(self):
        """size(VectorDouble self) -> std::vector< double >::size_type"""
        return _SimpleITK.VectorDouble_size(self)


    def swap(self, v):
        """swap(VectorDouble self, VectorDouble v)"""
        return _SimpleITK.VectorDouble_swap(self, v)


    def begin(self):
        """begin(VectorDouble self) -> std::vector< double >::iterator"""
        return _SimpleITK.VectorDouble_begin(self)


    def end(self):
        """end(VectorDouble self) -> std::vector< double >::iterator"""
        return _SimpleITK.VectorDouble_end(self)


    def rbegin(self):
        """rbegin(VectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _SimpleITK.VectorDouble_rbegin(self)


    def rend(self):
        """rend(VectorDouble self) -> std::vector< double >::reverse_iterator"""
        return _SimpleITK.VectorDouble_rend(self)


    def clear(self):
        """clear(VectorDouble self)"""
        return _SimpleITK.VectorDouble_clear(self)


    def get_allocator(self):
        """get_allocator(VectorDouble self) -> std::vector< double >::allocator_type"""
        return _SimpleITK.VectorDouble_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorDouble self)"""
        return _SimpleITK.VectorDouble_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorDouble self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(VectorDouble self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _SimpleITK.VectorDouble_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> VectorDouble
        __init__(std::vector<(double)> self, VectorDouble arg2) -> VectorDouble
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> VectorDouble
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> VectorDouble
        """
        this = _SimpleITK.new_VectorDouble(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorDouble self, std::vector< double >::value_type const & x)"""
        return _SimpleITK.VectorDouble_push_back(self, x)


    def front(self):
        """front(VectorDouble self) -> std::vector< double >::value_type const &"""
        return _SimpleITK.VectorDouble_front(self)


    def back(self):
        """back(VectorDouble self) -> std::vector< double >::value_type const &"""
        return _SimpleITK.VectorDouble_back(self)


    def assign(self, n, x):
        """assign(VectorDouble self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _SimpleITK.VectorDouble_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorDouble self, std::vector< double >::size_type new_size)
        resize(VectorDouble self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _SimpleITK.VectorDouble_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorDouble self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(VectorDouble self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _SimpleITK.VectorDouble_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorDouble self, std::vector< double >::size_type n)"""
        return _SimpleITK.VectorDouble_reserve(self, n)


    def capacity(self):
        """capacity(VectorDouble self) -> std::vector< double >::size_type"""
        return _SimpleITK.VectorDouble_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorDouble
    __del__ = lambda self: None
VectorDouble_swigregister = _SimpleITK.VectorDouble_swigregister
VectorDouble_swigregister(VectorDouble)

class VectorOfImage(_object):
    """Proxy of C++ std::vector<(itk::simple::Image)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorOfImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorOfImage, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorOfImage self) -> SwigPyIterator"""
        return _SimpleITK.VectorOfImage_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorOfImage self) -> bool"""
        return _SimpleITK.VectorOfImage___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorOfImage self) -> bool"""
        return _SimpleITK.VectorOfImage___bool__(self)


    def __len__(self):
        """__len__(VectorOfImage self) -> std::vector< itk::simple::Image >::size_type"""
        return _SimpleITK.VectorOfImage___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j) -> VectorOfImage"""
        return _SimpleITK.VectorOfImage___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j)
        __setslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j, VectorOfImage v)
        """
        return _SimpleITK.VectorOfImage___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, std::vector< itk::simple::Image >::difference_type j)"""
        return _SimpleITK.VectorOfImage___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i)
        __delitem__(VectorOfImage self, PySliceObject * slice)
        """
        return _SimpleITK.VectorOfImage___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorOfImage self, PySliceObject * slice) -> VectorOfImage
        __getitem__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i) -> Image
        """
        return _SimpleITK.VectorOfImage___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorOfImage self, PySliceObject * slice, VectorOfImage v)
        __setitem__(VectorOfImage self, PySliceObject * slice)
        __setitem__(VectorOfImage self, std::vector< itk::simple::Image >::difference_type i, Image x)
        """
        return _SimpleITK.VectorOfImage___setitem__(self, *args)


    def pop(self):
        """pop(VectorOfImage self) -> Image"""
        return _SimpleITK.VectorOfImage_pop(self)


    def append(self, x):
        """append(VectorOfImage self, Image x)"""
        return _SimpleITK.VectorOfImage_append(self, x)


    def empty(self):
        """empty(VectorOfImage self) -> bool"""
        return _SimpleITK.VectorOfImage_empty(self)


    def size(self):
        """size(VectorOfImage self) -> std::vector< itk::simple::Image >::size_type"""
        return _SimpleITK.VectorOfImage_size(self)


    def swap(self, v):
        """swap(VectorOfImage self, VectorOfImage v)"""
        return _SimpleITK.VectorOfImage_swap(self, v)


    def begin(self):
        """begin(VectorOfImage self) -> std::vector< itk::simple::Image >::iterator"""
        return _SimpleITK.VectorOfImage_begin(self)


    def end(self):
        """end(VectorOfImage self) -> std::vector< itk::simple::Image >::iterator"""
        return _SimpleITK.VectorOfImage_end(self)


    def rbegin(self):
        """rbegin(VectorOfImage self) -> std::vector< itk::simple::Image >::reverse_iterator"""
        return _SimpleITK.VectorOfImage_rbegin(self)


    def rend(self):
        """rend(VectorOfImage self) -> std::vector< itk::simple::Image >::reverse_iterator"""
        return _SimpleITK.VectorOfImage_rend(self)


    def clear(self):
        """clear(VectorOfImage self)"""
        return _SimpleITK.VectorOfImage_clear(self)


    def get_allocator(self):
        """get_allocator(VectorOfImage self) -> std::vector< itk::simple::Image >::allocator_type"""
        return _SimpleITK.VectorOfImage_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorOfImage self)"""
        return _SimpleITK.VectorOfImage_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorOfImage self, std::vector< itk::simple::Image >::iterator pos) -> std::vector< itk::simple::Image >::iterator
        erase(VectorOfImage self, std::vector< itk::simple::Image >::iterator first, std::vector< itk::simple::Image >::iterator last) -> std::vector< itk::simple::Image >::iterator
        """
        return _SimpleITK.VectorOfImage_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(itk::simple::Image)> self) -> VectorOfImage
        __init__(std::vector<(itk::simple::Image)> self, VectorOfImage arg2) -> VectorOfImage
        __init__(std::vector<(itk::simple::Image)> self, std::vector< itk::simple::Image >::size_type size) -> VectorOfImage
        __init__(std::vector<(itk::simple::Image)> self, std::vector< itk::simple::Image >::size_type size, Image value) -> VectorOfImage
        """
        this = _SimpleITK.new_VectorOfImage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorOfImage self, Image x)"""
        return _SimpleITK.VectorOfImage_push_back(self, x)


    def front(self):
        """front(VectorOfImage self) -> Image"""
        return _SimpleITK.VectorOfImage_front(self)


    def back(self):
        """back(VectorOfImage self) -> Image"""
        return _SimpleITK.VectorOfImage_back(self)


    def assign(self, n, x):
        """assign(VectorOfImage self, std::vector< itk::simple::Image >::size_type n, Image x)"""
        return _SimpleITK.VectorOfImage_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorOfImage self, std::vector< itk::simple::Image >::size_type new_size)
        resize(VectorOfImage self, std::vector< itk::simple::Image >::size_type new_size, Image x)
        """
        return _SimpleITK.VectorOfImage_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorOfImage self, std::vector< itk::simple::Image >::iterator pos, Image x) -> std::vector< itk::simple::Image >::iterator
        insert(VectorOfImage self, std::vector< itk::simple::Image >::iterator pos, std::vector< itk::simple::Image >::size_type n, Image x)
        """
        return _SimpleITK.VectorOfImage_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorOfImage self, std::vector< itk::simple::Image >::size_type n)"""
        return _SimpleITK.VectorOfImage_reserve(self, n)


    def capacity(self):
        """capacity(VectorOfImage self) -> std::vector< itk::simple::Image >::size_type"""
        return _SimpleITK.VectorOfImage_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorOfImage
    __del__ = lambda self: None
VectorOfImage_swigregister = _SimpleITK.VectorOfImage_swigregister
VectorOfImage_swigregister(VectorOfImage)

class VectorUIntList(_object):
    """Proxy of C++ std::vector<(std::vector<(unsigned int)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUIntList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUIntList, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorUIntList self) -> SwigPyIterator"""
        return _SimpleITK.VectorUIntList_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorUIntList self) -> bool"""
        return _SimpleITK.VectorUIntList___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorUIntList self) -> bool"""
        return _SimpleITK.VectorUIntList___bool__(self)


    def __len__(self):
        """__len__(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _SimpleITK.VectorUIntList___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j) -> VectorUIntList"""
        return _SimpleITK.VectorUIntList___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j)
        __setslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j, VectorUIntList v)
        """
        return _SimpleITK.VectorUIntList___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, std::vector< std::vector< unsigned int > >::difference_type j)"""
        return _SimpleITK.VectorUIntList___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i)
        __delitem__(VectorUIntList self, PySliceObject * slice)
        """
        return _SimpleITK.VectorUIntList___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorUIntList self, PySliceObject * slice) -> VectorUIntList
        __getitem__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i) -> VectorUInt32
        """
        return _SimpleITK.VectorUIntList___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorUIntList self, PySliceObject * slice, VectorUIntList v)
        __setitem__(VectorUIntList self, PySliceObject * slice)
        __setitem__(VectorUIntList self, std::vector< std::vector< unsigned int > >::difference_type i, VectorUInt32 x)
        """
        return _SimpleITK.VectorUIntList___setitem__(self, *args)


    def pop(self):
        """pop(VectorUIntList self) -> VectorUInt32"""
        return _SimpleITK.VectorUIntList_pop(self)


    def append(self, x):
        """append(VectorUIntList self, VectorUInt32 x)"""
        return _SimpleITK.VectorUIntList_append(self, x)


    def empty(self):
        """empty(VectorUIntList self) -> bool"""
        return _SimpleITK.VectorUIntList_empty(self)


    def size(self):
        """size(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _SimpleITK.VectorUIntList_size(self)


    def swap(self, v):
        """swap(VectorUIntList self, std::vector< std::vector< unsigned int,std::allocator< unsigned int > > > & v)"""
        return _SimpleITK.VectorUIntList_swap(self, v)


    def begin(self):
        """begin(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _SimpleITK.VectorUIntList_begin(self)


    def end(self):
        """end(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _SimpleITK.VectorUIntList_end(self)


    def rbegin(self):
        """rbegin(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _SimpleITK.VectorUIntList_rbegin(self)


    def rend(self):
        """rend(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _SimpleITK.VectorUIntList_rend(self)


    def clear(self):
        """clear(VectorUIntList self)"""
        return _SimpleITK.VectorUIntList_clear(self)


    def get_allocator(self):
        """get_allocator(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::allocator_type"""
        return _SimpleITK.VectorUIntList_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorUIntList self)"""
        return _SimpleITK.VectorUIntList_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator pos) -> std::vector< std::vector< unsigned int > >::iterator
        erase(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator first, std::vector< std::vector< unsigned int > >::iterator last) -> std::vector< std::vector< unsigned int > >::iterator
        """
        return _SimpleITK.VectorUIntList_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(unsigned int)>)> self) -> VectorUIntList
        __init__(std::vector<(std::vector<(unsigned int)>)> self, std::vector< std::vector< unsigned int,std::allocator< unsigned int > > > const & arg2) -> VectorUIntList
        __init__(std::vector<(std::vector<(unsigned int)>)> self, std::vector< std::vector< unsigned int > >::size_type size) -> VectorUIntList
        __init__(std::vector<(std::vector<(unsigned int)>)> self, std::vector< std::vector< unsigned int > >::size_type size, VectorUInt32 value) -> VectorUIntList
        """
        this = _SimpleITK.new_VectorUIntList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorUIntList self, VectorUInt32 x)"""
        return _SimpleITK.VectorUIntList_push_back(self, x)


    def front(self):
        """front(VectorUIntList self) -> VectorUInt32"""
        return _SimpleITK.VectorUIntList_front(self)


    def back(self):
        """back(VectorUIntList self) -> VectorUInt32"""
        return _SimpleITK.VectorUIntList_back(self)


    def assign(self, n, x):
        """assign(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type n, VectorUInt32 x)"""
        return _SimpleITK.VectorUIntList_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type new_size)
        resize(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type new_size, VectorUInt32 x)
        """
        return _SimpleITK.VectorUIntList_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator pos, VectorUInt32 x) -> std::vector< std::vector< unsigned int > >::iterator
        insert(VectorUIntList self, std::vector< std::vector< unsigned int > >::iterator pos, std::vector< std::vector< unsigned int > >::size_type n, VectorUInt32 x)
        """
        return _SimpleITK.VectorUIntList_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorUIntList self, std::vector< std::vector< unsigned int > >::size_type n)"""
        return _SimpleITK.VectorUIntList_reserve(self, n)


    def capacity(self):
        """capacity(VectorUIntList self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _SimpleITK.VectorUIntList_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorUIntList
    __del__ = lambda self: None
VectorUIntList_swigregister = _SimpleITK.VectorUIntList_swigregister
VectorUIntList_swigregister(VectorUIntList)

class VectorString(_object):
    """Proxy of C++ std::vector<(std::string)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorString, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(VectorString self) -> SwigPyIterator"""
        return _SimpleITK.VectorString_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(VectorString self) -> bool"""
        return _SimpleITK.VectorString___nonzero__(self)


    def __bool__(self):
        """__bool__(VectorString self) -> bool"""
        return _SimpleITK.VectorString___bool__(self)


    def __len__(self):
        """__len__(VectorString self) -> std::vector< std::string >::size_type"""
        return _SimpleITK.VectorString___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> VectorString"""
        return _SimpleITK.VectorString___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, VectorString v)
        """
        return _SimpleITK.VectorString___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _SimpleITK.VectorString___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(VectorString self, std::vector< std::string >::difference_type i)
        __delitem__(VectorString self, PySliceObject * slice)
        """
        return _SimpleITK.VectorString___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(VectorString self, PySliceObject * slice) -> VectorString
        __getitem__(VectorString self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _SimpleITK.VectorString___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(VectorString self, PySliceObject * slice, VectorString v)
        __setitem__(VectorString self, PySliceObject * slice)
        __setitem__(VectorString self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _SimpleITK.VectorString___setitem__(self, *args)


    def pop(self):
        """pop(VectorString self) -> std::vector< std::string >::value_type"""
        return _SimpleITK.VectorString_pop(self)


    def append(self, x):
        """append(VectorString self, std::vector< std::string >::value_type const & x)"""
        return _SimpleITK.VectorString_append(self, x)


    def empty(self):
        """empty(VectorString self) -> bool"""
        return _SimpleITK.VectorString_empty(self)


    def size(self):
        """size(VectorString self) -> std::vector< std::string >::size_type"""
        return _SimpleITK.VectorString_size(self)


    def swap(self, v):
        """swap(VectorString self, VectorString v)"""
        return _SimpleITK.VectorString_swap(self, v)


    def begin(self):
        """begin(VectorString self) -> std::vector< std::string >::iterator"""
        return _SimpleITK.VectorString_begin(self)


    def end(self):
        """end(VectorString self) -> std::vector< std::string >::iterator"""
        return _SimpleITK.VectorString_end(self)


    def rbegin(self):
        """rbegin(VectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _SimpleITK.VectorString_rbegin(self)


    def rend(self):
        """rend(VectorString self) -> std::vector< std::string >::reverse_iterator"""
        return _SimpleITK.VectorString_rend(self)


    def clear(self):
        """clear(VectorString self)"""
        return _SimpleITK.VectorString_clear(self)


    def get_allocator(self):
        """get_allocator(VectorString self) -> std::vector< std::string >::allocator_type"""
        return _SimpleITK.VectorString_get_allocator(self)


    def pop_back(self):
        """pop_back(VectorString self)"""
        return _SimpleITK.VectorString_pop_back(self)


    def erase(self, *args):
        """
        erase(VectorString self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(VectorString self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _SimpleITK.VectorString_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> VectorString
        __init__(std::vector<(std::string)> self, VectorString arg2) -> VectorString
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> VectorString
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> VectorString
        """
        this = _SimpleITK.new_VectorString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(VectorString self, std::vector< std::string >::value_type const & x)"""
        return _SimpleITK.VectorString_push_back(self, x)


    def front(self):
        """front(VectorString self) -> std::vector< std::string >::value_type const &"""
        return _SimpleITK.VectorString_front(self)


    def back(self):
        """back(VectorString self) -> std::vector< std::string >::value_type const &"""
        return _SimpleITK.VectorString_back(self)


    def assign(self, n, x):
        """assign(VectorString self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _SimpleITK.VectorString_assign(self, n, x)


    def resize(self, *args):
        """
        resize(VectorString self, std::vector< std::string >::size_type new_size)
        resize(VectorString self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _SimpleITK.VectorString_resize(self, *args)


    def insert(self, *args):
        """
        insert(VectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(VectorString self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _SimpleITK.VectorString_insert(self, *args)


    def reserve(self, n):
        """reserve(VectorString self, std::vector< std::string >::size_type n)"""
        return _SimpleITK.VectorString_reserve(self, n)


    def capacity(self):
        """capacity(VectorString self) -> std::vector< std::string >::size_type"""
        return _SimpleITK.VectorString_capacity(self)

    __swig_destroy__ = _SimpleITK.delete_VectorString
    __del__ = lambda self: None
VectorString_swigregister = _SimpleITK.VectorString_swigregister
VectorString_swigregister(VectorString)

class DoubleDoubleMap(_object):
    """Proxy of C++ std::map<(double,double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleDoubleMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleDoubleMap, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(DoubleDoubleMap self) -> SwigPyIterator"""
        return _SimpleITK.DoubleDoubleMap_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(DoubleDoubleMap self) -> bool"""
        return _SimpleITK.DoubleDoubleMap___nonzero__(self)


    def __bool__(self):
        """__bool__(DoubleDoubleMap self) -> bool"""
        return _SimpleITK.DoubleDoubleMap___bool__(self)


    def __len__(self):
        """__len__(DoubleDoubleMap self) -> std::map< double,double >::size_type"""
        return _SimpleITK.DoubleDoubleMap___len__(self)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        """__getitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key) -> std::map< double,double >::mapped_type const &"""
        return _SimpleITK.DoubleDoubleMap___getitem__(self, key)


    def __delitem__(self, key):
        """__delitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key)"""
        return _SimpleITK.DoubleDoubleMap___delitem__(self, key)


    def has_key(self, key):
        """has_key(DoubleDoubleMap self, std::map< double,double >::key_type const & key) -> bool"""
        return _SimpleITK.DoubleDoubleMap_has_key(self, key)


    def keys(self):
        """keys(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_keys(self)


    def values(self):
        """values(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_values(self)


    def items(self):
        """items(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_items(self)


    def __contains__(self, key):
        """__contains__(DoubleDoubleMap self, std::map< double,double >::key_type const & key) -> bool"""
        return _SimpleITK.DoubleDoubleMap___contains__(self, key)


    def key_iterator(self):
        """key_iterator(DoubleDoubleMap self) -> SwigPyIterator"""
        return _SimpleITK.DoubleDoubleMap_key_iterator(self)


    def value_iterator(self):
        """value_iterator(DoubleDoubleMap self) -> SwigPyIterator"""
        return _SimpleITK.DoubleDoubleMap_value_iterator(self)


    def __setitem__(self, *args):
        """
        __setitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key)
        __setitem__(DoubleDoubleMap self, std::map< double,double >::key_type const & key, std::map< double,double >::mapped_type const & x)
        """
        return _SimpleITK.DoubleDoubleMap___setitem__(self, *args)


    def asdict(self):
        """asdict(DoubleDoubleMap self) -> PyObject *"""
        return _SimpleITK.DoubleDoubleMap_asdict(self)


    def __init__(self, *args):
        """
        __init__(std::map<(double,double)> self, std::less< double > const & arg2) -> DoubleDoubleMap
        __init__(std::map<(double,double)> self) -> DoubleDoubleMap
        __init__(std::map<(double,double)> self, DoubleDoubleMap arg2) -> DoubleDoubleMap
        """
        this = _SimpleITK.new_DoubleDoubleMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        """empty(DoubleDoubleMap self) -> bool"""
        return _SimpleITK.DoubleDoubleMap_empty(self)


    def size(self):
        """size(DoubleDoubleMap self) -> std::map< double,double >::size_type"""
        return _SimpleITK.DoubleDoubleMap_size(self)


    def swap(self, v):
        """swap(DoubleDoubleMap self, DoubleDoubleMap v)"""
        return _SimpleITK.DoubleDoubleMap_swap(self, v)


    def begin(self):
        """begin(DoubleDoubleMap self) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_begin(self)


    def end(self):
        """end(DoubleDoubleMap self) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_end(self)


    def rbegin(self):
        """rbegin(DoubleDoubleMap self) -> std::map< double,double >::reverse_iterator"""
        return _SimpleITK.DoubleDoubleMap_rbegin(self)


    def rend(self):
        """rend(DoubleDoubleMap self) -> std::map< double,double >::reverse_iterator"""
        return _SimpleITK.DoubleDoubleMap_rend(self)


    def clear(self):
        """clear(DoubleDoubleMap self)"""
        return _SimpleITK.DoubleDoubleMap_clear(self)


    def get_allocator(self):
        """get_allocator(DoubleDoubleMap self) -> std::map< double,double >::allocator_type"""
        return _SimpleITK.DoubleDoubleMap_get_allocator(self)


    def count(self, x):
        """count(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::size_type"""
        return _SimpleITK.DoubleDoubleMap_count(self, x)


    def erase(self, *args):
        """
        erase(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::size_type
        erase(DoubleDoubleMap self, std::map< double,double >::iterator position)
        erase(DoubleDoubleMap self, std::map< double,double >::iterator first, std::map< double,double >::iterator last)
        """
        return _SimpleITK.DoubleDoubleMap_erase(self, *args)


    def find(self, x):
        """find(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_find(self, x)


    def lower_bound(self, x):
        """lower_bound(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_lower_bound(self, x)


    def upper_bound(self, x):
        """upper_bound(DoubleDoubleMap self, std::map< double,double >::key_type const & x) -> std::map< double,double >::iterator"""
        return _SimpleITK.DoubleDoubleMap_upper_bound(self, x)

    __swig_destroy__ = _SimpleITK.delete_DoubleDoubleMap
    __del__ = lambda self: None
DoubleDoubleMap_swigregister = _SimpleITK.DoubleDoubleMap_swigregister
DoubleDoubleMap_swigregister(DoubleDoubleMap)


import operator
import sys



HAVE_NUMPY = True
try:
    import numpy
except ImportError:
    HAVE_NUMPY = False


def _get_numpy_dtype( sitkImage ):
    """Given a SimpleITK image, returns the numpy.dtype which describes the data"""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')

# this is a mapping from sitk's pixel id to numpy's dtype
    _sitk_np = {sitkUInt8:numpy.uint8,
                sitkUInt16:numpy.uint16,
                sitkUInt32:numpy.uint32,
                sitkUInt64:numpy.uint64,
                sitkInt8:numpy.int8,
                sitkInt16:numpy.int16,
                sitkInt32:numpy.int32,
                sitkInt64:numpy.int64,
                sitkFloat32:numpy.float32,
                sitkFloat64:numpy.float64,
                sitkComplexFloat32:numpy.complex64,
                sitkComplexFloat64:numpy.complex128,
                sitkVectorUInt8:numpy.uint8,
                sitkVectorInt8:numpy.int8,
                sitkVectorUInt16:numpy.uint16,
                sitkVectorInt16:numpy.int16,
                sitkVectorUInt32:numpy.uint32,
                sitkVectorInt32:numpy.int32,
                sitkVectorUInt64:numpy.uint64,
                sitkVectorInt64:numpy.int64,
                sitkVectorFloat32:numpy.float32,
                sitkVectorFloat64:numpy.float64,
                sitkLabelUInt8:numpy.uint8,
                sitkLabelUInt16:numpy.uint16,
                sitkLabelUInt32:numpy.uint32,
                sitkLabelUInt64:numpy.uint64
                }

    return _sitk_np[ sitkImage.GetPixelIDValue() ]



def _get_sitk_pixelid(numpy_array_type):
    """Returns a SimpleITK PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')

# This is a Mapping from numpy array types to sitks pixel types.
    _np_sitk = {numpy.character:sitkUInt8,
                numpy.uint8:sitkUInt8,
                numpy.uint16:sitkUInt16,
                numpy.uint32:sitkUInt32,
                numpy.uint64:sitkUInt64,
                numpy.int8:sitkInt8,
                numpy.int16:sitkInt16,
                numpy.int32:sitkInt32,
                numpy.int64:sitkInt64,
                numpy.float32:sitkFloat32,
                numpy.float64:sitkFloat64,
                numpy.complex64:sitkComplexFloat32,
                numpy.complex128:sitkComplexFloat64
                }

    try:
        return _np_sitk[numpy_array_type.dtype]
    except KeyError:
        for key in _np_sitk:
            if numpy.issubdtype(numpy_array_type.dtype, key):
                return _np_sitk[key]

def _get_sitk_vector_pixelid(numpy_array_type):
    """Returns a SimpleITK vecotr PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')

# This is a Mapping from numpy array types to sitks pixel types.
    _np_sitk = {numpy.character:sitkVectorUInt8,
                numpy.uint8:sitkVectorUInt8,
                numpy.uint16:sitkVectorUInt16,
                numpy.uint32:sitkVectorUInt32,
                numpy.uint64:sitkVectorUInt64,
                numpy.int8:sitkVectorInt8,
                numpy.int16:sitkVectorInt16,
                numpy.int32:sitkVectorInt32,
                numpy.int64:sitkVectorInt64,
                numpy.float32:sitkVectorFloat32,
                numpy.float64:sitkVectorFloat64,
                }

    try:
        return _np_sitk[numpy_array_type.dtype]
    except KeyError:
        for key in _np_sitk:
            if numpy.issubdtype(numpy_array_type.dtype, key):
                return _np_sitk[key]


# SimplyITK <-> Numpy Array conversion support.

def GetArrayViewFromImage(image):
    """Get a NumPy ndarray view of a SimpleITK Image.

    Returns a Numpy ndarray object as a "view" of the SimpleITK's Image buffer. This reduces pixel buffer copies, but requires that the SimpleITK image object is kept around while the buffer is being used.


    """

    if not HAVE_NUMPY:
        raise ImportError('NumPy not available.')


    pixelID = image.GetPixelIDValue()
    assert pixelID != sitkUnknown, "An SimpleITK image of Unknown pixel type should not exists!"

    dtype = _get_numpy_dtype( image )

    shape = image.GetSize();
    if image.GetNumberOfComponentsPerPixel() > 1:
      shape = ( image.GetNumberOfComponentsPerPixel(), ) + shape

    image.MakeUnique()

    imageMemoryView =  _SimpleITK._GetMemoryViewFromImage(image)
    arrayView = numpy.asarray(imageMemoryView).view(dtype = dtype)
    arrayView.shape = shape[::-1]

    return arrayView

def GetArrayFromImage(image):
    """Get a NumPy ndarray from a SimpleITK Image.

    This is a deep copy of the image buffer and is completely safe and without potential side effects.
    """

# TODO: If the image is already not unique then a second copy may be made before the numpy copy is done.
    arrayView = GetArrayViewFromImage(image)

# perform deep copy of the image buffer
    return numpy.array(arrayView, copy=True)


def GetImageFromArray( arr, isVector=False):
    """Get a SimpleITK Image from a numpy array. If isVector is True, then a 3D array will be treated as a 2D vector image, otherwise it will be treated as a 3D image"""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')

    z = numpy.asarray( arr )

    assert z.ndim in ( 2, 3, 4 ), \
      "Only arrays of 2, 3 or 4 dimensions are supported."

    if ( z.ndim == 3 and isVector ) or (z.ndim == 4):
      id = _get_sitk_vector_pixelid( z )
      img = Image( z.shape[-2::-1] , id, z.shape[-1] )
    elif z.ndim in ( 2, 3 ):
      id = _get_sitk_pixelid( z )
      img = Image( z.shape[::-1], id )

    _SimpleITK._SetImageFromArray( z.tostring(), img )

    return img

SITK_ITK_VERSION_MAJOR = _SimpleITK.SITK_ITK_VERSION_MAJOR
SITK_ITK_VERSION_MINOR = _SimpleITK.SITK_ITK_VERSION_MINOR
SITK_ITK_VERSION_PATCH = _SimpleITK.SITK_ITK_VERSION_PATCH
class Version(_object):
    """


    Version info for SimpleITK.

    C++ includes: sitkVersion.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr

    def MajorVersion():
        """MajorVersion() -> unsigned int"""
        return _SimpleITK.Version_MajorVersion()

    MajorVersion = staticmethod(MajorVersion)

    def MinorVersion():
        """MinorVersion() -> unsigned int"""
        return _SimpleITK.Version_MinorVersion()

    MinorVersion = staticmethod(MinorVersion)

    def PatchVersion():
        """PatchVersion() -> unsigned int"""
        return _SimpleITK.Version_PatchVersion()

    PatchVersion = staticmethod(PatchVersion)

    def TweakVersion():
        """TweakVersion() -> unsigned int"""
        return _SimpleITK.Version_TweakVersion()

    TweakVersion = staticmethod(TweakVersion)

    def VersionString():
        """VersionString() -> std::string const &"""
        return _SimpleITK.Version_VersionString()

    VersionString = staticmethod(VersionString)

    def BuildDate():
        """BuildDate() -> std::string const &"""
        return _SimpleITK.Version_BuildDate()

    BuildDate = staticmethod(BuildDate)

    def ITKMajorVersion():
        """ITKMajorVersion() -> unsigned int"""
        return _SimpleITK.Version_ITKMajorVersion()

    ITKMajorVersion = staticmethod(ITKMajorVersion)

    def ITKMinorVersion():
        """ITKMinorVersion() -> unsigned int"""
        return _SimpleITK.Version_ITKMinorVersion()

    ITKMinorVersion = staticmethod(ITKMinorVersion)

    def ITKPatchVersion():
        """ITKPatchVersion() -> unsigned int"""
        return _SimpleITK.Version_ITKPatchVersion()

    ITKPatchVersion = staticmethod(ITKPatchVersion)

    def ITKVersionString():
        """ITKVersionString() -> std::string const &"""
        return _SimpleITK.Version_ITKVersionString()

    ITKVersionString = staticmethod(ITKVersionString)

    def ExtendedVersionString():
        """ExtendedVersionString() -> std::string const &"""
        return _SimpleITK.Version_ExtendedVersionString()

    ExtendedVersionString = staticmethod(ExtendedVersionString)

    def __str__(self):
        """
        __str__(Version self) -> std::string



        """
        return _SimpleITK.Version___str__(self)


    def __init__(self):
        """__init__(itk::simple::Version self) -> Version"""
        this = _SimpleITK.new_Version()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_Version
    __del__ = lambda self: None
Version_swigregister = _SimpleITK.Version_swigregister
Version_swigregister(Version)
_GetMemoryViewFromImage = _SimpleITK._GetMemoryViewFromImage
_SetImageFromArray = _SimpleITK._SetImageFromArray

def Version_MajorVersion():
    """Version_MajorVersion() -> unsigned int"""
    return _SimpleITK.Version_MajorVersion()

def Version_MinorVersion():
    """Version_MinorVersion() -> unsigned int"""
    return _SimpleITK.Version_MinorVersion()

def Version_PatchVersion():
    """Version_PatchVersion() -> unsigned int"""
    return _SimpleITK.Version_PatchVersion()

def Version_TweakVersion():
    """Version_TweakVersion() -> unsigned int"""
    return _SimpleITK.Version_TweakVersion()

def Version_VersionString():
    """Version_VersionString() -> std::string const &"""
    return _SimpleITK.Version_VersionString()

def Version_BuildDate():
    """Version_BuildDate() -> std::string const &"""
    return _SimpleITK.Version_BuildDate()

def Version_ITKMajorVersion():
    """Version_ITKMajorVersion() -> unsigned int"""
    return _SimpleITK.Version_ITKMajorVersion()

def Version_ITKMinorVersion():
    """Version_ITKMinorVersion() -> unsigned int"""
    return _SimpleITK.Version_ITKMinorVersion()

def Version_ITKPatchVersion():
    """Version_ITKPatchVersion() -> unsigned int"""
    return _SimpleITK.Version_ITKPatchVersion()

def Version_ITKVersionString():
    """Version_ITKVersionString() -> std::string const &"""
    return _SimpleITK.Version_ITKVersionString()

def Version_ExtendedVersionString():
    """Version_ExtendedVersionString() -> std::string const &"""
    return _SimpleITK.Version_ExtendedVersionString()

sitkUnknown = _SimpleITK.sitkUnknown
sitkUInt8 = _SimpleITK.sitkUInt8
sitkInt8 = _SimpleITK.sitkInt8
sitkUInt16 = _SimpleITK.sitkUInt16
sitkInt16 = _SimpleITK.sitkInt16
sitkUInt32 = _SimpleITK.sitkUInt32
sitkInt32 = _SimpleITK.sitkInt32
sitkUInt64 = _SimpleITK.sitkUInt64
sitkInt64 = _SimpleITK.sitkInt64
sitkFloat32 = _SimpleITK.sitkFloat32
sitkFloat64 = _SimpleITK.sitkFloat64
sitkComplexFloat32 = _SimpleITK.sitkComplexFloat32
sitkComplexFloat64 = _SimpleITK.sitkComplexFloat64
sitkVectorUInt8 = _SimpleITK.sitkVectorUInt8
sitkVectorInt8 = _SimpleITK.sitkVectorInt8
sitkVectorUInt16 = _SimpleITK.sitkVectorUInt16
sitkVectorInt16 = _SimpleITK.sitkVectorInt16
sitkVectorUInt32 = _SimpleITK.sitkVectorUInt32
sitkVectorInt32 = _SimpleITK.sitkVectorInt32
sitkVectorUInt64 = _SimpleITK.sitkVectorUInt64
sitkVectorInt64 = _SimpleITK.sitkVectorInt64
sitkVectorFloat32 = _SimpleITK.sitkVectorFloat32
sitkVectorFloat64 = _SimpleITK.sitkVectorFloat64
sitkLabelUInt8 = _SimpleITK.sitkLabelUInt8
sitkLabelUInt16 = _SimpleITK.sitkLabelUInt16
sitkLabelUInt32 = _SimpleITK.sitkLabelUInt32
sitkLabelUInt64 = _SimpleITK.sitkLabelUInt64

def GetPixelIDValueAsString(type):
    """
    GetPixelIDValueAsString(itk::simple::PixelIDValueEnum type) -> std::string const



    """
    return _SimpleITK.GetPixelIDValueAsString(type)

def GetPixelIDValueFromString(enumString):
    """
    GetPixelIDValueFromString(std::string const & enumString) -> itk::simple::PixelIDValueType



    Function mapping enumeration names in std::string to values.


    This function is intended for use by the R bindings. R stores the
    enumeration values using the names : "sitkUnkown", "sitkUInt8",
    etc from PixelIDValueEnum above. This function is used to provide the
    integer values using calls like:

    val = GetPixelIDValueFromString("sitkInt32")

    If the pixel type has not been instantiated then the sitkUnknown value
    (-1) will be returned. If the pixel type string is not recognised
    (i.e. is not in the set of tested names) then the return value is -99.
    The idea is to provide a warning (via the R package) if this function
    needs to be updated to match changes to PixelIDValueEnum - i.e. if a
    new pixel type is added.


    """
    return _SimpleITK.GetPixelIDValueFromString(enumString)
class Image(_object):
    """


    The main Image class for SimpleITK.

    C++ includes: sitkImage.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Image, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Image, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Image
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(itk::simple::Image self) -> Image
        __init__(itk::simple::Image self, Image img) -> Image
        __init__(itk::simple::Image self, unsigned int width, unsigned int height, itk::simple::PixelIDValueEnum valueEnum) -> Image
        __init__(itk::simple::Image self, unsigned int width, unsigned int height, unsigned int depth, itk::simple::PixelIDValueEnum valueEnum) -> Image
        __init__(itk::simple::Image self, VectorUInt32 size, itk::simple::PixelIDValueEnum valueEnum, unsigned int numberOfComponents=0) -> Image



        """
        this = _SimpleITK.new_Image(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetITKBase(self, *args):
        """
        GetITKBase(Image self) -> itk::DataObject
        GetITKBase(Image self) -> itk::DataObject const *
        """
        return _SimpleITK.Image_GetITKBase(self, *args)


    def GetPixelID(self):
        """
        GetPixelID(Image self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.Image_GetPixelID(self)


    def GetPixelIDValue(self):
        """
        GetPixelIDValue(Image self) -> itk::simple::PixelIDValueType



        """
        return _SimpleITK.Image_GetPixelIDValue(self)


    def GetDimension(self):
        """
        GetDimension(Image self) -> unsigned int



        """
        return _SimpleITK.Image_GetDimension(self)


    def GetNumberOfComponentsPerPixel(self):
        """
        GetNumberOfComponentsPerPixel(Image self) -> unsigned int



        Get the number of components for each pixel.


        For scalar images this methods returns 1. For vector images the number
        of components for each pixel is returned.


        """
        return _SimpleITK.Image_GetNumberOfComponentsPerPixel(self)


    def GetNumberOfPixels(self):
        """
        GetNumberOfPixels(Image self) -> uint64_t



        Get the number of pixels in the image.


        To Calculate the total number of values stored continuously for the
        image's buffer, the NumberOfPixels should be multiplied by
        NumberOfComponentsPerPixel in order to account for multiple component
        images.


        """
        return _SimpleITK.Image_GetNumberOfPixels(self)


    def GetOrigin(self):
        """GetOrigin(Image self) -> VectorDouble"""
        return _SimpleITK.Image_GetOrigin(self)


    def SetOrigin(self, origin):
        """SetOrigin(Image self, VectorDouble origin)"""
        return _SimpleITK.Image_SetOrigin(self, origin)


    def GetSpacing(self):
        """GetSpacing(Image self) -> VectorDouble"""
        return _SimpleITK.Image_GetSpacing(self)


    def SetSpacing(self, spacing):
        """SetSpacing(Image self, VectorDouble spacing)"""
        return _SimpleITK.Image_SetSpacing(self, spacing)


    def GetDirection(self):
        """GetDirection(Image self) -> VectorDouble"""
        return _SimpleITK.Image_GetDirection(self)


    def SetDirection(self, direction):
        """SetDirection(Image self, VectorDouble direction)"""
        return _SimpleITK.Image_SetDirection(self, direction)


    def TransformIndexToPhysicalPoint(self, index):
        """
        TransformIndexToPhysicalPoint(Image self, VectorInt64 index) -> VectorDouble



        Transform index to physical point


        """
        return _SimpleITK.Image_TransformIndexToPhysicalPoint(self, index)


    def TransformPhysicalPointToIndex(self, point):
        """
        TransformPhysicalPointToIndex(Image self, VectorDouble point) -> VectorInt64



        Transform physical point to index


        """
        return _SimpleITK.Image_TransformPhysicalPointToIndex(self, point)


    def TransformPhysicalPointToContinuousIndex(self, point):
        """
        TransformPhysicalPointToContinuousIndex(Image self, VectorDouble point) -> VectorDouble



        Transform physical point to continuous index


        """
        return _SimpleITK.Image_TransformPhysicalPointToContinuousIndex(self, point)


    def TransformContinuousIndexToPhysicalPoint(self, index):
        """
        TransformContinuousIndexToPhysicalPoint(Image self, VectorDouble index) -> VectorDouble



        Transform continuous index to physical point


        """
        return _SimpleITK.Image_TransformContinuousIndexToPhysicalPoint(self, index)


    def GetSize(self):
        """
        GetSize(Image self) -> VectorUInt32



        """
        return _SimpleITK.Image_GetSize(self)


    def GetHeight(self):
        """
        GetHeight(Image self) -> unsigned int



        """
        return _SimpleITK.Image_GetHeight(self)


    def GetWidth(self):
        """
        GetWidth(Image self) -> unsigned int



        """
        return _SimpleITK.Image_GetWidth(self)


    def GetDepth(self):
        """
        GetDepth(Image self) -> unsigned int



        """
        return _SimpleITK.Image_GetDepth(self)


    def CopyInformation(self, srcImage):
        """
        CopyInformation(Image self, Image srcImage)



        Copy common meta-data from an image to this one.


        Copies the Origin, Spacing, and Direction from the source image to
        this image. The meta-data dictionary is not copied.

        It is required for the source Image's dimension and size to match, this image's attributes, otherwise an
        exception will be generated.


        """
        return _SimpleITK.Image_CopyInformation(self, srcImage)


    def GetMetaDataKeys(self):
        """
        GetMetaDataKeys(Image self) -> VectorString



        get a vector of keys in from the meta-data dictionary


        Returns a vector of keys to the key/value entries in the image's meta-
        data dictionary. Iterate through with these keys to get the values.


        """
        return _SimpleITK.Image_GetMetaDataKeys(self)


    def HasMetaDataKey(self, key):
        """
        HasMetaDataKey(Image self, std::string const & key) -> bool



        Query the meta-data dictionary for the existence of a key.


        """
        return _SimpleITK.Image_HasMetaDataKey(self, key)


    def GetMetaData(self, key):
        """
        GetMetaData(Image self, std::string const & key) -> std::string



        Get the value of a meta-data dictionary entry as a string.


        If the key is not in the dictionary then an exception is thrown.

        string types in the dictionary are returned as their native strings.
        Other types are printed to string before returning.


        """
        return _SimpleITK.Image_GetMetaData(self, key)


    def SetMetaData(self, key, value):
        """
        SetMetaData(Image self, std::string const & key, std::string const & value)



        Set an entry in the meta-data dictionary.


        Replaces or creates an entry in the image's meta-data dictionary.


        """
        return _SimpleITK.Image_SetMetaData(self, key, value)


    def EraseMetaData(self, key):
        """
        EraseMetaData(Image self, std::string const & key) -> bool



        Remove an entry from the meta-data dictionary.


        Returns true, when the value exists in the dictionary and is removed,
        false otherwise.


        """
        return _SimpleITK.Image_EraseMetaData(self, key)


    def GetPixelIDTypeAsString(self):
        """
        GetPixelIDTypeAsString(Image self) -> std::string



        """
        return _SimpleITK.Image_GetPixelIDTypeAsString(self)


    def __str__(self):
        """
        __str__(Image self) -> std::string



        """
        return _SimpleITK.Image___str__(self)


    def __GetPixelAsInt8__(self, idx):
        """__GetPixelAsInt8__(Image self, VectorUInt32 idx) -> int8_t"""
        return _SimpleITK.Image___GetPixelAsInt8__(self, idx)


    def __GetPixelAsUInt8__(self, idx):
        """__GetPixelAsUInt8__(Image self, VectorUInt32 idx) -> uint8_t"""
        return _SimpleITK.Image___GetPixelAsUInt8__(self, idx)


    def __GetPixelAsInt16__(self, idx):
        """__GetPixelAsInt16__(Image self, VectorUInt32 idx) -> int16_t"""
        return _SimpleITK.Image___GetPixelAsInt16__(self, idx)


    def __GetPixelAsUInt16__(self, idx):
        """__GetPixelAsUInt16__(Image self, VectorUInt32 idx) -> uint16_t"""
        return _SimpleITK.Image___GetPixelAsUInt16__(self, idx)


    def __GetPixelAsInt32__(self, idx):
        """__GetPixelAsInt32__(Image self, VectorUInt32 idx) -> int32_t"""
        return _SimpleITK.Image___GetPixelAsInt32__(self, idx)


    def __GetPixelAsUInt32__(self, idx):
        """__GetPixelAsUInt32__(Image self, VectorUInt32 idx) -> uint32_t"""
        return _SimpleITK.Image___GetPixelAsUInt32__(self, idx)


    def __GetPixelAsInt64__(self, idx):
        """__GetPixelAsInt64__(Image self, VectorUInt32 idx) -> int64_t"""
        return _SimpleITK.Image___GetPixelAsInt64__(self, idx)


    def __GetPixelAsUInt64__(self, idx):
        """__GetPixelAsUInt64__(Image self, VectorUInt32 idx) -> uint64_t"""
        return _SimpleITK.Image___GetPixelAsUInt64__(self, idx)


    def __GetPixelAsFloat__(self, idx):
        """__GetPixelAsFloat__(Image self, VectorUInt32 idx) -> float"""
        return _SimpleITK.Image___GetPixelAsFloat__(self, idx)


    def __GetPixelAsDouble__(self, idx):
        """__GetPixelAsDouble__(Image self, VectorUInt32 idx) -> double"""
        return _SimpleITK.Image___GetPixelAsDouble__(self, idx)


    def __GetPixelAsVectorInt8__(self, idx):
        """__GetPixelAsVectorInt8__(Image self, VectorUInt32 idx) -> VectorInt8"""
        return _SimpleITK.Image___GetPixelAsVectorInt8__(self, idx)


    def __GetPixelAsVectorUInt8__(self, idx):
        """__GetPixelAsVectorUInt8__(Image self, VectorUInt32 idx) -> VectorUInt8"""
        return _SimpleITK.Image___GetPixelAsVectorUInt8__(self, idx)


    def __GetPixelAsVectorInt16__(self, idx):
        """__GetPixelAsVectorInt16__(Image self, VectorUInt32 idx) -> VectorInt16"""
        return _SimpleITK.Image___GetPixelAsVectorInt16__(self, idx)


    def __GetPixelAsVectorUInt16__(self, idx):
        """__GetPixelAsVectorUInt16__(Image self, VectorUInt32 idx) -> VectorUInt16"""
        return _SimpleITK.Image___GetPixelAsVectorUInt16__(self, idx)


    def __GetPixelAsVectorInt32__(self, idx):
        """__GetPixelAsVectorInt32__(Image self, VectorUInt32 idx) -> VectorInt32"""
        return _SimpleITK.Image___GetPixelAsVectorInt32__(self, idx)


    def __GetPixelAsVectorUInt32__(self, idx):
        """__GetPixelAsVectorUInt32__(Image self, VectorUInt32 idx) -> VectorUInt32"""
        return _SimpleITK.Image___GetPixelAsVectorUInt32__(self, idx)


    def __GetPixelAsVectorInt64__(self, idx):
        """__GetPixelAsVectorInt64__(Image self, VectorUInt32 idx) -> VectorInt64"""
        return _SimpleITK.Image___GetPixelAsVectorInt64__(self, idx)


    def __GetPixelAsVectorUInt64__(self, idx):
        """__GetPixelAsVectorUInt64__(Image self, VectorUInt32 idx) -> VectorUInt64"""
        return _SimpleITK.Image___GetPixelAsVectorUInt64__(self, idx)


    def __GetPixelAsVectorFloat32__(self, idx):
        """__GetPixelAsVectorFloat32__(Image self, VectorUInt32 idx) -> VectorFloat"""
        return _SimpleITK.Image___GetPixelAsVectorFloat32__(self, idx)


    def __GetPixelAsVectorFloat64__(self, idx):
        """__GetPixelAsVectorFloat64__(Image self, VectorUInt32 idx) -> VectorDouble"""
        return _SimpleITK.Image___GetPixelAsVectorFloat64__(self, idx)


    def __GetPixelAsComplexFloat32__(self, idx):
        """__GetPixelAsComplexFloat32__(Image self, VectorUInt32 idx) -> std::complex< float >"""
        return _SimpleITK.Image___GetPixelAsComplexFloat32__(self, idx)


    def GetPixelAsComplexFloat64(self, idx):
        """GetPixelAsComplexFloat64(Image self, VectorUInt32 idx) -> std::complex< double >"""
        return _SimpleITK.Image_GetPixelAsComplexFloat64(self, idx)


    def __SetPixelAsInt8__(self, idx, v):
        """__SetPixelAsInt8__(Image self, VectorUInt32 idx, int8_t v)"""
        return _SimpleITK.Image___SetPixelAsInt8__(self, idx, v)


    def __SetPixelAsUInt8__(self, idx, v):
        """__SetPixelAsUInt8__(Image self, VectorUInt32 idx, uint8_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt8__(self, idx, v)


    def __SetPixelAsInt16__(self, idx, v):
        """__SetPixelAsInt16__(Image self, VectorUInt32 idx, int16_t v)"""
        return _SimpleITK.Image___SetPixelAsInt16__(self, idx, v)


    def __SetPixelAsUInt16__(self, idx, v):
        """__SetPixelAsUInt16__(Image self, VectorUInt32 idx, uint16_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt16__(self, idx, v)


    def __SetPixelAsInt32__(self, idx, v):
        """__SetPixelAsInt32__(Image self, VectorUInt32 idx, int32_t v)"""
        return _SimpleITK.Image___SetPixelAsInt32__(self, idx, v)


    def __SetPixelAsUInt32__(self, idx, v):
        """__SetPixelAsUInt32__(Image self, VectorUInt32 idx, uint32_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt32__(self, idx, v)


    def __SetPixelAsInt64__(self, idx, v):
        """__SetPixelAsInt64__(Image self, VectorUInt32 idx, int64_t v)"""
        return _SimpleITK.Image___SetPixelAsInt64__(self, idx, v)


    def __SetPixelAsUInt64__(self, idx, v):
        """__SetPixelAsUInt64__(Image self, VectorUInt32 idx, uint64_t v)"""
        return _SimpleITK.Image___SetPixelAsUInt64__(self, idx, v)


    def __SetPixelAsFloat__(self, idx, v):
        """__SetPixelAsFloat__(Image self, VectorUInt32 idx, float v)"""
        return _SimpleITK.Image___SetPixelAsFloat__(self, idx, v)


    def __SetPixelAsDouble__(self, idx, v):
        """__SetPixelAsDouble__(Image self, VectorUInt32 idx, double v)"""
        return _SimpleITK.Image___SetPixelAsDouble__(self, idx, v)


    def __SetPixelAsVectorInt8__(self, idx, v):
        """__SetPixelAsVectorInt8__(Image self, VectorUInt32 idx, VectorInt8 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt8__(self, idx, v)


    def __SetPixelAsVectorUInt8__(self, idx, v):
        """__SetPixelAsVectorUInt8__(Image self, VectorUInt32 idx, VectorUInt8 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt8__(self, idx, v)


    def __SetPixelAsVectorInt16__(self, idx, v):
        """__SetPixelAsVectorInt16__(Image self, VectorUInt32 idx, VectorInt16 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt16__(self, idx, v)


    def __SetPixelAsVectorUInt16__(self, idx, v):
        """__SetPixelAsVectorUInt16__(Image self, VectorUInt32 idx, VectorUInt16 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt16__(self, idx, v)


    def __SetPixelAsVectorInt32__(self, idx, v):
        """__SetPixelAsVectorInt32__(Image self, VectorUInt32 idx, VectorInt32 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt32__(self, idx, v)


    def __SetPixelAsVectorUInt32__(self, idx, v):
        """__SetPixelAsVectorUInt32__(Image self, VectorUInt32 idx, VectorUInt32 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt32__(self, idx, v)


    def __SetPixelAsVectorInt64__(self, idx, v):
        """__SetPixelAsVectorInt64__(Image self, VectorUInt32 idx, VectorInt64 v)"""
        return _SimpleITK.Image___SetPixelAsVectorInt64__(self, idx, v)


    def __SetPixelAsVectorUInt64__(self, idx, v):
        """__SetPixelAsVectorUInt64__(Image self, VectorUInt32 idx, VectorUInt64 v)"""
        return _SimpleITK.Image___SetPixelAsVectorUInt64__(self, idx, v)


    def __SetPixelAsVectorFloat32__(self, idx, v):
        """__SetPixelAsVectorFloat32__(Image self, VectorUInt32 idx, VectorFloat v)"""
        return _SimpleITK.Image___SetPixelAsVectorFloat32__(self, idx, v)


    def __SetPixelAsVectorFloat64__(self, idx, v):
        """__SetPixelAsVectorFloat64__(Image self, VectorUInt32 idx, VectorDouble v)"""
        return _SimpleITK.Image___SetPixelAsVectorFloat64__(self, idx, v)


    def __SetPixelAsComplexFloat32__(self, idx, v):
        """__SetPixelAsComplexFloat32__(Image self, VectorUInt32 idx, std::complex< float > const v)"""
        return _SimpleITK.Image___SetPixelAsComplexFloat32__(self, idx, v)


    def SetPixelAsComplexFloat64(self, idx, v):
        """SetPixelAsComplexFloat64(Image self, VectorUInt32 idx, std::complex< double > const v)"""
        return _SimpleITK.Image_SetPixelAsComplexFloat64(self, idx, v)


    def MakeUnique(self):
        """
        MakeUnique(Image self)



        Performs actually coping if needed to make object unique.


        The Image class by default performs lazy coping and assignment. This method
        make sure that coping actually happens to the itk::Image pointed to is only pointed to by this object.


        """
        return _SimpleITK.Image_MakeUnique(self)



            # mathematical operators

    def __add__( self, other ):
        if isinstance( other, Image ):
           return Add( self, other )
        try:
           return Add( self, float(other)  )
        except ValueError:
           return NotImplemented
    def __sub__( self, other ):
        if isinstance( other, Image ):
           return Subtract( self, other )
        try:
           return Subtract( self, float(other) )
        except ValueError:
           return NotImplemented
    def __mul__( self, other ):
        if isinstance( other, Image ):
           return Multiply( self, other )
        try:
           return Multiply( self, float(other) )
        except ValueError:
           return NotImplemented
    def __div__( self, other ):
        if isinstance( other, Image ):
           return Divide( self, other )
        try:
           return Divide( self, float(other) )
        except ValueError:
           return NotImplemented
    def __floordiv__( self, other ):
        if isinstance( other, Image ):
           return DivideFloor( self, other )
        try:
           return DivideFloor( self, float(other) )
        except ValueError:
           return NotImplemented
    def __truediv__( self, other ):
        if isinstance( other, Image ):
           return DivideReal( self, other )
        try:
           return DivideReal( self, float(other) )
        except ValueError:
           return NotImplemented


    def __neg__( self ):
        return UnaryMinus( self )
    def __pos__( self ):
        return self

    # NOTE: for the reverse methods other cannot be an image, so
    # therefore other should be able to be considered a constant.

    def __radd__( self, other ):
        try:
           return Add( float(other), self )
        except ValueError:
           return NotImplemented
    def __rsub__( self, other ):
        try:
           return Subtract( float(other), self )
        except ValueError:
           return NotImplemented
    def __rmul__( self, other ):
        try:
           return Multiply( float(other), self )
        except ValueError:
           return NotImplemented
    def __rdiv__( self, other ):
        try:
           return Divide( float(other), self )
        except ValueError:
           return NotImplemented
    def __rfloordiv__( self, other ):
        try:
           return DivideFloor( float(other), self )
        except ValueError:
           return NotImplemented
    def __rtruediv__( self, other ):
        try:
           return DivideReal( float(other), self )
        except ValueError:
           return NotImplemented



    # NOTE: the __i*__ methods are not implemented because there
    # currently in no way to make the underlying filters run
    # inplace. But python will implement a default version based
    # on the standard method
    def __iadd__ ( self, other ):
        self = Add( self, other )
        return self;

    # logic operators

    def __and__( self, other ):
        if isinstance( other, Image ):
           return And( self, other )
        try:
           return And( self, int(other) )
        except ValueError:
           return NotImplemented
    def __rand__( self, other ):
        try:
           return And( int(other), self )
        except ValueError:
           return NotImplemented
    def __or__( self, other ):
        if isinstance( other, Image ):
           return Or( self, other )
        try:
           return Or( self, int(other) )
        except ValueError:
           return NotImplemented
    def __ror__( self, other ):
        try:
           return Or( int(other), self )
        except ValueError:
           return NotImplemented
    def __xor__( self, other ):
        if isinstance( other, Image ):
           return Xor( self, other )
        try:
           return Xor( self, int(other) )
        except ValueError:
           return NotImplemented
    def __rxor__( self, other ):
        try:
           return Xor( int(other), self )
        except ValueError:
           return NotImplemented
    def __invert__( self ): return BitwiseNot( self )

    # Relational and Equality operators

    def __lt__( self, other ):
        if isinstance( other, Image ):
           return Less( self, other )
        try:
           return Less( self, float(other) )
        except (ValueError, TypeError):
           return NotImplemented
    def __le__( self, other ):
        if isinstance( other, Image ):
           return LessEqual( self, other )
        try:
           return LessEqual( self, float(other) )
        except (ValueError, TypeError):
           return NotImplemented
    def __eq__( self, other ):
        if isinstance( other, Image ):
           return Equal( self, other )
        try:
           return Equal( self, float(other) )
        except (ValueError, TypeError):
           return NotImplemented
    def __ne__( self, other ):
        if isinstance( other, Image ):
           return NotEqual( self, other )
        try:
           return NotEqual( self, float(other) )
        except (ValueError, TypeError):
           return NotImplemented
    def __gt__( self, other ):
        if isinstance( other, Image ):
           return Greater( self, other )
        try:
           return Greater( self, float(other) )
        except (ValueError, TypeError):
           return NotImplemented
    def __ge__( self, other ):
        if isinstance( other, Image ):
           return GreaterEqual( self, other )
        try:
           return GreaterEqual( self, float(other) )
        except (ValueError, TypeError):
           return NotImplemented


    # "function" operators

    def __pow__( self, other ):
        if isinstance( other, Image ):
           return Pow( self, other )
        try:
           return Pow( self, float(other) )
        except ValueError:
           return NotImplemented
    def __rpow__( self, other ):
        try:
           return Pow( float(other), self )
        except ValueError:
           return NotImplemented
    def __mod__( self, other ): return Modulus( self, other )
    def __abs__( self ): return Abs( self )

    # iterator and container methods

    def __iter__( self ):

        if len(self) == 0:
          raise StopIteration

        dim = self.GetDimension()
        size = self.GetSize()
        idx = [0] * dim

        while idx[dim-1] < size[dim-1]:

          yield self[ idx ]

    # increment the idx
          for d in range( 0, dim ):
            idx[d] += 1
            if idx[d] >= size[d] and d != dim  - 1:
               idx[d] = 0
            else:
               break

        return

    def __len__( self ):
        l = 1
        for ds in self.GetSize():
          l *= ds
        return l

    # set/get pixel methods

    def __getitem__( self, idx ):
        """ Get an pixel value or a sliced image.

        This operator implements basic indexing where idx is
        arguments or a squence of integers the same dimension as
        the image. The result will be a pixel value from that
        index.

        Multi-dimension extended slice based indexing is also
        implemented. The return is a copy of a new image. The
        standard sliced based indices are supported including
        negative indices, to indicate location relative to the
        end, along with negative step sized to indicate reversing
        of direction.

        If the length of idx is less than the number of dimension
        of the image it will be padded with the defaults slice
        ":".

        A 2D image can be extracted from a 3D image by providing
        one argument being an integer instead of a slice."""

        if sys.version_info[0] < 3:
          def isint( i ):
            return type(i) == int or type(i) == long
        else:
          def isint( i ):
            return type(i) == int

        dim = self.GetDimension()
        size = self.GetSize()

        try:
          if (len(idx) < dim):
    # if the argument tuple has fewer elements then the dimension of the image then extend to match that of the image
            idx = tuple(idx) + (slice(None),)*(dim-len(idx))
        except TypeError:
    # if the len function didn't work then, assume is a
    # non-iterable, and make it a single element in a tuple.
          idx = (idx,) + (slice(None),)*(dim-1)

        if (len(idx) > dim):
           raise IndexError("invalid index")

    # All the indices are integers just return GetPixel value
        if all( isint(i) for i in idx ):
    # if any of the arguments are negative integers subract them for the size
          idx = [idx[i] if idx[i] >= 0 else (size[i] + idx[i]) for i in range(len(idx))]

          if any( idx[i] < 0 or idx[i] >= size[i] for i in range(len(idx))):
            raise IndexError("index out of bounds")

          return self.GetPixel(*tuple(idx))


    # If we have a 3D image, we can extract 2D image if one index is an int and the reset are slices
        slice_dim = -1
        if ( dim == 3 ):
    # find only a single dimension with has an integer index
          for i in range(len(idx)):
            if type(idx[i]) is slice:
              continue
            elif isint(idx[i]):
              if(slice_dim == -1):
                slice_dim = abs(i)
              else:
                slice_dim = -1
                break

        if slice_dim != -1:
    # replace int slice_dim with a slice
          s = idx[slice_dim]
          if s < 0:
            s += size[slice_dim]

          if s < 0 or s >= size[slice_dim]:
             raise IndexError("index  out of bounds")

          idx = tuple(idx[:slice_dim]) + (slice(s, s+1),)+ tuple(idx[slice_dim+1:])

    # Use the slice filter when all the elements are slices ( or have been processed to be )
        if all( type(i) is slice for i in idx ):

    # perform standard slice indexing, to clamp to ranges and add in defaults
          sidx = [ idx[i].indices(size[i]) for i in range(len(idx ))]

    # extract each element of the indices rages together
          (start, stop, step) = zip(*sidx)

    # run the slice filter
          img = Slice(self, start=start, stop=stop, step=step)

          if (slice_dim != -1):

    # the stop is on the wrong side of step
            if any( (s[1]-s[0])//s[2] <= 0 for s in sidx ):
              raise IndexError("invalid range")

            size = img.GetSize();

    # set the slice dimension size to 0
            size = size[:slice_dim]+(0,)+size[slice_dim+1:]

    # reduce the 3D image to a 2D
            img = Extract( img, size )

          return img


    # the index parameter was an invalid set of objects
        raise IndexError("invalid index")


    def __setitem__( self, idx, value ):
        """Sets the pixel value at index idx to value.

        The dimension of idx should match that of the image."""

        if sys.version_info[0] < 3:
          def isint( i ):
            return type(i) == int or type(i) == long
        else:
          def isint( i ):
            return type(i) == int

        dim = self.GetDimension()
        size = self.GetSize()

        if (len(idx) > dim):
           raise IndexError("invalid index")

    # All the indices are integers just return SetPixel value
        if all( isint(i) for i in idx ):
    # if any of the arguments are negative integers subract them for the size
          idx = [idx[i] if idx[i] >= 0 else (size[i] + idx[i]) for i in range(len(idx))]

          if any( idx[i] < 0 or idx[i] >= size[i] for i in range(len(idx))):
            raise IndexError("index out of bounds")

          return self.SetPixel(*(tuple(idx)+(value,)))

    # the index parameter was an invalid set of objects
        raise IndexError("invalid index")


    def GetPixel(self, *idx):
      """Returns the value of a pixel.

         This method takes 2 parameters in 2D: the x and y index,
         and 3 parameters in 3D: the x, y and z index."""

      if len(idx) == 1:
       idx = idx[0]

      pixelID = self.GetPixelIDValue()
      if pixelID == sitkUnknown:
        raise Exception("invalid pixel type")
      if pixelID == sitkInt8:
        return self.__GetPixelAsInt8__( idx )
      if pixelID == sitkUInt8 or pixelID == sitkLabelUInt8:
        return self.__GetPixelAsUInt8__( idx )
      if pixelID == sitkInt16:
        return self.__GetPixelAsInt16__( idx )
      if pixelID == sitkUInt16 or pixelID == sitkLabelUInt16:
        return self.__GetPixelAsUInt16__( idx )
      if pixelID == sitkInt32:
        return self.__GetPixelAsInt32__( idx )
      if pixelID == sitkUInt32 or pixelID == sitkLabelUInt32:
        return self.__GetPixelAsUInt32__( idx )
      if pixelID == sitkInt64:
        return self.__GetPixelAsInt64__( idx )
      if pixelID == sitkUInt64 or pixelID == sitkLabelUInt64:
        return self.__GetPixelAsUInt64__( idx )
      if pixelID == sitkFloat32:
        return self.__GetPixelAsFloat__( idx )
      if pixelID == sitkFloat64:
        return self.__GetPixelAsDouble__( idx )

      if pixelID == sitkVectorInt8:
        return self.__GetPixelAsVectorInt8__( idx )
      if pixelID == sitkVectorUInt8:
        return self.__GetPixelAsVectorUInt8__( idx )
      if pixelID == sitkVectorInt16:
        return self.__GetPixelAsVectorInt16__( idx )
      if pixelID == sitkVectorUInt16:
        return self.__GetPixelAsVectorUInt16__( idx )
      if pixelID == sitkVectorInt32:
        return self.__GetPixelAsVectorInt32__( idx )
      if pixelID == sitkVectorUInt32:
        return self.__GetPixelAsVectorUInt32__( idx )
      if pixelID == sitkVectorInt64:
        return self.__GetPixelAsVectorInt64__( idx )
      if pixelID == sitkVectorUInt64:
        return self.__GetPixelAsVectorUInt64__( idx )
      if pixelID == sitkVectorFloat32:
        return self.__GetPixelAsVectorFloat32__( idx )
      if pixelID == sitkVectorFloat64:
        return self.__GetPixelAsVectorFloat64__( idx )

      if pixelID == sitkComplexFloat32:
        return self.__GetPixelAsComplexFloat32__( idx )
      if pixelID == sitkComplexFloat64:
        return self.__GetPixelAsComplexFloat64__( idx )

      raise Exception("unknown pixel type")

    def SetPixel(self, *args):
      """Sets the value of a pixel.

       This method takes 3 parameters in 2D: the x and y index then the value,
       and 4 parameters in 3D: the x, y and z index then the value."""


      pixelID = self.GetPixelIDValue()
      if pixelID == sitkUnknown:
        raise Exception("invalid pixel type")

      if len(args) < 2:
        raise Exception( "Wrong number of arguments, coordinates arguments then value" )
      idx = args[:len(args)-1]
      if len(idx) == 1:
        idx = idx[0]
      value = args[-1]

      if pixelID == sitkInt8:
        return self.__SetPixelAsInt8__( idx, value )
      if pixelID == sitkUInt8 or pixelID == sitkLabelUInt8:
        return self.__SetPixelAsUInt8__( idx, value )
      if pixelID == sitkInt16:
        return self.__SetPixelAsInt16__( idx, value )
      if pixelID == sitkUInt16 or pixelID == sitkLabelUInt16:
        return self.__SetPixelAsUInt16__( idx, value )
      if pixelID == sitkInt32:
        return self.__SetPixelAsInt32__( idx, value )
      if pixelID == sitkUInt32 or pixelID == sitkLabelUInt32:
        return self.__SetPixelAsUInt32__( idx, value )
      if pixelID == sitkInt64:
        return self.__SetPixelAsInt64__( idx, value )
      if pixelID == sitkUInt64 or pixelID == sitkLabelUInt64:
        return self.__SetPixelAsUInt64__( idx, value )
      if pixelID == sitkFloat32:
        return self.__SetPixelAsFloat__( idx, value )
      if pixelID == sitkFloat64:
        return self.__SetPixelAsDouble__( idx, value )

      if pixelID == sitkVectorInt8:
        return self.__SetPixelAsVectorInt8__( idx, value )
      if pixelID == sitkVectorUInt8:
        return self.__SetPixelAsVectorUInt8__( idx, value )
      if pixelID == sitkVectorInt16:
        return self.__SetPixelAsVectorInt16__( idx, value )
      if pixelID == sitkVectorUInt16:
        return self.__SetPixelAsVectorUInt16__( idx, value )
      if pixelID == sitkVectorInt32:
        return self.__SetPixelAsVectorInt32__( idx, value )
      if pixelID == sitkVectorUInt32:
        return self.__SetPixelAsVectorUInt32__( idx, value )
      if pixelID == sitkVectorInt64:
        return self.__SetPixelAsVectorInt64__( idx, value )
      if pixelID == sitkVectorUInt64:
        return self.__SetPixelAsVectorUInt64__( idx, value )
      if pixelID == sitkVectorFloat32:
        return self.__SetPixelAsVectorFloat32__( idx, value )
      if pixelID == sitkVectorFloat64:
        return self.__SetPixelAsVectorFloat64__( idx, value )

      if pixelID == sitkComplexFloat32:
        return self.__SetPixelAsComplexFloat32__( idx, value )
      if pixelID == sitkComplexFloat64:
        return self.__SetPixelAsComplexFloat64__( idx, value )

      raise Exception("unknown pixel type")



Image_swigregister = _SimpleITK.Image_swigregister
Image_swigregister(Image)

class Command(_object):
    """


    An implementation of the Command design pattern for callback.


    This class provides a callback mechanism for event that occur from the ProcessObject. These commands can be utilized to observe these events.

    The Command can be created on the stack, and will automatically unregistered it's
    self when destroyed.

    For more information see the page Commands and Events for SimpleITK.

    C++ includes: sitkCommand.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Command, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Command, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::Command self) -> Command



        Default Constructor.


        """
        if self.__class__ == Command:
            _self = None
        else:
            _self = self
        this = _SimpleITK.new_Command(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_Command
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(Command self) -> std::string



        Set/Get Command Name


        """
        return _SimpleITK.Command_GetName(self)


    def SetName(self, name):
        """
        SetName(Command self, std::string const & name)



        """
        return _SimpleITK.Command_SetName(self, name)


    def Execute(self):
        """
        Execute(Command self)



        The method that defines action to be taken by the command


        """
        return _SimpleITK.Command_Execute(self)

    def __disown__(self):
        self.this.disown()
        _SimpleITK.disown_Command(self)
        return weakref_proxy(self)
Command_swigregister = _SimpleITK.Command_swigregister
Command_swigregister(Command)

sitkNearestNeighbor = _SimpleITK.sitkNearestNeighbor
sitkLinear = _SimpleITK.sitkLinear
sitkBSpline = _SimpleITK.sitkBSpline
sitkGaussian = _SimpleITK.sitkGaussian
sitkLabelGaussian = _SimpleITK.sitkLabelGaussian
sitkHammingWindowedSinc = _SimpleITK.sitkHammingWindowedSinc
sitkCosineWindowedSinc = _SimpleITK.sitkCosineWindowedSinc
sitkWelchWindowedSinc = _SimpleITK.sitkWelchWindowedSinc
sitkLanczosWindowedSinc = _SimpleITK.sitkLanczosWindowedSinc
sitkBlackmanWindowedSinc = _SimpleITK.sitkBlackmanWindowedSinc
sitkAnnulus = _SimpleITK.sitkAnnulus
sitkBall = _SimpleITK.sitkBall
sitkBox = _SimpleITK.sitkBox
sitkCross = _SimpleITK.sitkCross
sitkPolygon3 = _SimpleITK.sitkPolygon3
sitkPolygon4 = _SimpleITK.sitkPolygon4
sitkPolygon5 = _SimpleITK.sitkPolygon5
sitkPolygon6 = _SimpleITK.sitkPolygon6
sitkPolygon7 = _SimpleITK.sitkPolygon7
sitkPolygon8 = _SimpleITK.sitkPolygon8
sitkPolygon9 = _SimpleITK.sitkPolygon9
sitkAnyEvent = _SimpleITK.sitkAnyEvent
sitkAbortEvent = _SimpleITK.sitkAbortEvent
sitkDeleteEvent = _SimpleITK.sitkDeleteEvent
sitkEndEvent = _SimpleITK.sitkEndEvent
sitkIterationEvent = _SimpleITK.sitkIterationEvent
sitkProgressEvent = _SimpleITK.sitkProgressEvent
sitkStartEvent = _SimpleITK.sitkStartEvent
sitkMultiResolutionIterationEvent = _SimpleITK.sitkMultiResolutionIterationEvent
sitkUserEvent = _SimpleITK.sitkUserEvent
sitkWallClock = _SimpleITK.sitkWallClock
sitkIdentity = _SimpleITK.sitkIdentity
sitkTranslation = _SimpleITK.sitkTranslation
sitkScale = _SimpleITK.sitkScale
sitkScaleLogarithmic = _SimpleITK.sitkScaleLogarithmic
sitkEuler = _SimpleITK.sitkEuler
sitkSimilarity = _SimpleITK.sitkSimilarity
sitkQuaternionRigid = _SimpleITK.sitkQuaternionRigid
sitkVersor = _SimpleITK.sitkVersor
sitkVersorRigid = _SimpleITK.sitkVersorRigid
sitkScaleSkewVersor = _SimpleITK.sitkScaleSkewVersor
sitkAffine = _SimpleITK.sitkAffine
sitkComposite = _SimpleITK.sitkComposite
sitkDisplacementField = _SimpleITK.sitkDisplacementField
sitkBSplineTransform = _SimpleITK.sitkBSplineTransform
class Transform(_object):
    """


    A simplified wrapper around a variety of ITK transforms.


    The interface to ITK transform objects to be used with the ImageRegistrationMethod, ResampleImageFilter and other SimpleITK process objects. The transforms are designed to
    have a serialized array of parameters to facilitate optimization for
    registration.

    Provides a base class interface to any type of ITK transform. Objects
    of this type may have their interface converted to a derived interface
    while keeping the same reference to the ITK object.

    Additionally, this class provides a basic interface to a composite
    transforms.


    See:
     itk::CompositeTransform


    C++ includes: sitkTransform.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Transform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Transform, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_Transform
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(itk::simple::Transform self) -> Transform
        __init__(itk::simple::Transform self, itk::TransformBase * transform) -> Transform
        __init__(itk::simple::Transform self, unsigned int dimensions, itk::simple::TransformEnum type) -> Transform
        __init__(itk::simple::Transform self, Image displacement, itk::simple::TransformEnum type) -> Transform
        __init__(itk::simple::Transform self, Transform arg2) -> Transform



        Use an image to construct a transform.


        The input displacement image is transferred to the constructed
        transform object. The input image is modified to be a default
        constructed Image object.

        Only the sitkDisplacementField transformation type can currently be
        constructed this way. Image must be of sitkVectorFloat64 pixel type with the number of components
        equal to the image dimension.

        Deprecated
        This constructor will be removed in future releases.



        """
        this = _SimpleITK.new_Transform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetITKBase(self, *args):
        """
        GetITKBase(Transform self) -> itk::TransformBase
        GetITKBase(Transform self) -> itk::TransformBase const *
        """
        return _SimpleITK.Transform_GetITKBase(self, *args)


    def GetDimension(self):
        """
        GetDimension(Transform self) -> unsigned int



        Return the dimension of the Transform ( 2D or 3D )


        """
        return _SimpleITK.Transform_GetDimension(self)


    def SetParameters(self, parameters):
        """SetParameters(Transform self, VectorDouble parameters)"""
        return _SimpleITK.Transform_SetParameters(self, parameters)


    def GetParameters(self):
        """GetParameters(Transform self) -> VectorDouble"""
        return _SimpleITK.Transform_GetParameters(self)


    def SetFixedParameters(self, parameters):
        """SetFixedParameters(Transform self, VectorDouble parameters)"""
        return _SimpleITK.Transform_SetFixedParameters(self, parameters)


    def GetFixedParameters(self):
        """GetFixedParameters(Transform self) -> VectorDouble"""
        return _SimpleITK.Transform_GetFixedParameters(self)


    def AddTransform(self, t):
        """
        AddTransform(Transform self, Transform t)



        """
        return _SimpleITK.Transform_AddTransform(self, t)


    def TransformPoint(self, point):
        """
        TransformPoint(Transform self, VectorDouble point) -> VectorDouble



        """
        return _SimpleITK.Transform_TransformPoint(self, point)


    def WriteTransform(self, filename):
        """
        WriteTransform(Transform self, std::string const & filename)



        """
        return _SimpleITK.Transform_WriteTransform(self, filename)


    def IsLinear(self):
        """
        IsLinear(Transform self) -> bool



        """
        return _SimpleITK.Transform_IsLinear(self)


    def SetIdentity(self):
        """
        SetIdentity(Transform self)



        """
        return _SimpleITK.Transform_SetIdentity(self)


    def SetInverse(self):
        """
        SetInverse(Transform self) -> bool



        Try to change the current transform to it's inverse.


        If the transform has an inverse, i.e. non-singular linear transforms,
        then a new ITK transform is created of the same type and this object
        is set to it.

        However not all transform have a direct inverse, if the inverse does
        not exist or fails false will be returned and this transform will not
        be modified.


        """
        return _SimpleITK.Transform_SetInverse(self)


    def GetInverse(self):
        """
        GetInverse(Transform self) -> Transform



        Return a new inverse transform of the same type as this.


        Creates a new transform object and tries to set the value to the
        inverse. As not all transform types have inverse and some transforms
        are not invertable, an exception will be throw is there is no inverse.


        """
        return _SimpleITK.Transform_GetInverse(self)


    def __str__(self):
        """
        __str__(Transform self) -> std::string



        """
        return _SimpleITK.Transform___str__(self)


    def GetName(self):
        """
        GetName(Transform self) -> std::string



        return user readable name for the SimpleITK transform


        """
        return _SimpleITK.Transform_GetName(self)


    def MakeUnique(self):
        """
        MakeUnique(Transform self)



        Performs actually coping if needed to make object unique.


        The Transform class by default performs lazy coping and assignment. This method
        make sure that coping actually happens to the itk::Transform pointed to is only pointed to by this object.


        """
        return _SimpleITK.Transform_MakeUnique(self)

Transform_swigregister = _SimpleITK.Transform_swigregister
Transform_swigregister(Transform)


def ReadTransform(filename):
    """
    ReadTransform(std::string const & filename) -> Transform



    """
    return _SimpleITK.ReadTransform(filename)

def WriteTransform(transform, filename):
    """
    WriteTransform(Transform transform, std::string const & filename)



    """
    return _SimpleITK.WriteTransform(transform, filename)
class BSplineTransform(Transform):
    """


    A deformable transform over a bounded spatial domain using a BSpline
    representation for a 2D or 3D coordinate space.



    See:
     itk::BSplineTransform


    C++ includes: sitkBSplineTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BSplineTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BSplineTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::BSplineTransform self, unsigned int dimensions, unsigned int order=3) -> BSplineTransform
        __init__(itk::simple::BSplineTransform self, BSplineTransform arg2) -> BSplineTransform
        __init__(itk::simple::BSplineTransform self, Transform arg2) -> BSplineTransform



        """
        this = _SimpleITK.new_BSplineTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(BSplineTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.BSplineTransform_GetName(self)


    def SetTransformDomainDirection(self, arg2):
        """
        SetTransformDomainDirection(BSplineTransform self, VectorDouble arg2)



        parameters fixed parameter


        """
        return _SimpleITK.BSplineTransform_SetTransformDomainDirection(self, arg2)


    def GetTransformDomainDirection(self):
        """
        GetTransformDomainDirection(BSplineTransform self) -> VectorDouble



        """
        return _SimpleITK.BSplineTransform_GetTransformDomainDirection(self)


    def SetTransformDomainMeshSize(self, arg2):
        """
        SetTransformDomainMeshSize(BSplineTransform self, VectorUInt32 arg2)



        """
        return _SimpleITK.BSplineTransform_SetTransformDomainMeshSize(self, arg2)


    def GetTransformDomainMeshSize(self):
        """
        GetTransformDomainMeshSize(BSplineTransform self) -> VectorUInt32



        """
        return _SimpleITK.BSplineTransform_GetTransformDomainMeshSize(self)


    def SetTransformDomainOrigin(self, arg2):
        """
        SetTransformDomainOrigin(BSplineTransform self, VectorDouble arg2)



        """
        return _SimpleITK.BSplineTransform_SetTransformDomainOrigin(self, arg2)


    def GetTransformDomainOrigin(self):
        """
        GetTransformDomainOrigin(BSplineTransform self) -> VectorDouble



        """
        return _SimpleITK.BSplineTransform_GetTransformDomainOrigin(self)


    def SetTransformDomainPhysicalDimensions(self, arg2):
        """
        SetTransformDomainPhysicalDimensions(BSplineTransform self, VectorDouble arg2)



        """
        return _SimpleITK.BSplineTransform_SetTransformDomainPhysicalDimensions(self, arg2)


    def GetTransformDomainPhysicalDimensions(self):
        """
        GetTransformDomainPhysicalDimensions(BSplineTransform self) -> VectorDouble



        """
        return _SimpleITK.BSplineTransform_GetTransformDomainPhysicalDimensions(self)


    def GetCoefficientImages(self):
        """
        GetCoefficientImages(BSplineTransform self) -> VectorOfImage



        Get a vector of the coefficient images representing the BSpline.


        A lazy shallow copy of the images from ITK are performed. If they are
        modified in SimpleITK a deep copy will occur. However, if the
        coefficients are modified in ITK, then no copy will occur and the
        images help by SimpleITK may change.


        """
        return _SimpleITK.BSplineTransform_GetCoefficientImages(self)


    def GetOrder(self):
        """
        GetOrder(BSplineTransform self) -> unsigned int



        """
        return _SimpleITK.BSplineTransform_GetOrder(self)

    __swig_destroy__ = _SimpleITK.delete_BSplineTransform
    __del__ = lambda self: None
BSplineTransform_swigregister = _SimpleITK.BSplineTransform_swigregister
BSplineTransform_swigregister(BSplineTransform)

class DisplacementFieldTransform(Transform):
    """


    A dense deformable transform over a bounded spatial domain for 2D or
    3D coordinates space.



    See:
     itk::DisplacementFieldTransform


    C++ includes: sitkDisplacementFieldTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DisplacementFieldTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DisplacementFieldTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::DisplacementFieldTransform self, unsigned int dimensions) -> DisplacementFieldTransform
        __init__(itk::simple::DisplacementFieldTransform self, Image arg2) -> DisplacementFieldTransform
        __init__(itk::simple::DisplacementFieldTransform self, DisplacementFieldTransform arg2) -> DisplacementFieldTransform
        __init__(itk::simple::DisplacementFieldTransform self, Transform arg2) -> DisplacementFieldTransform



        """
        this = _SimpleITK.new_DisplacementFieldTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(DisplacementFieldTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.DisplacementFieldTransform_GetName(self)


    def SetDisplacementField(self, arg2):
        """
        SetDisplacementField(DisplacementFieldTransform self, Image arg2)



        Consume an image, and set the displacement field.


        parameters
        WARNING:
        The ownership of the input displacement image is transferred to the
        constructed transform object. The input image is modified to be a
        default constructed Image object.
        Image must be of sitkVectorFloat64 pixel type with the number of components
        equal to the image dimension.


        """
        return _SimpleITK.DisplacementFieldTransform_SetDisplacementField(self, arg2)


    def GetDisplacementField(self):
        """
        GetDisplacementField(DisplacementFieldTransform self) -> Image



        Todo
        The returned image should not directly modify the internal
        displacement field.



        """
        return _SimpleITK.DisplacementFieldTransform_GetDisplacementField(self)


    def SetInverseDisplacementField(self, arg2):
        """
        SetInverseDisplacementField(DisplacementFieldTransform self, Image arg2)



        fixed parameter


        """
        return _SimpleITK.DisplacementFieldTransform_SetInverseDisplacementField(self, arg2)


    def GetInverseDisplacementField(self):
        """
        GetInverseDisplacementField(DisplacementFieldTransform self) -> Image



        Todo
        The returned image is should not directly modify the internal
        displacement field.



        """
        return _SimpleITK.DisplacementFieldTransform_GetInverseDisplacementField(self)


    def SetInterpolator(self, interp):
        """
        SetInterpolator(DisplacementFieldTransform self, itk::simple::InterpolatorEnum interp)



        Set the interpolator used between the field voxels.


        """
        return _SimpleITK.DisplacementFieldTransform_SetInterpolator(self, interp)


    def SetSmoothingOff(self):
        """
        SetSmoothingOff(DisplacementFieldTransform self)



        """
        return _SimpleITK.DisplacementFieldTransform_SetSmoothingOff(self)


    def SetSmoothingGaussianOnUpdate(self, varianceForUpdateField=1.75, varianceForTotalField=0.5):
        """
        SetSmoothingGaussianOnUpdate(DisplacementFieldTransform self, double varianceForUpdateField=1.75, double varianceForTotalField=0.5)



        """
        return _SimpleITK.DisplacementFieldTransform_SetSmoothingGaussianOnUpdate(self, varianceForUpdateField, varianceForTotalField)


    def SetSmoothingBSplineOnUpdate(self, *args, **kwargs):
        """
        SetSmoothingBSplineOnUpdate(DisplacementFieldTransform self, VectorUInt32 numberOfControlPointsForUpdateField, VectorUInt32 numberOfControlPointsForTotalField, bool enforceStationaryBoundary=True, unsigned int order=3)



        """
        return _SimpleITK.DisplacementFieldTransform_SetSmoothingBSplineOnUpdate(self, *args, **kwargs)

    __swig_destroy__ = _SimpleITK.delete_DisplacementFieldTransform
    __del__ = lambda self: None
DisplacementFieldTransform_swigregister = _SimpleITK.DisplacementFieldTransform_swigregister
DisplacementFieldTransform_swigregister(DisplacementFieldTransform)

class AffineTransform(Transform):
    """


    An affine transformation about a fixed center with translation for a
    2D or 3D coordinate.



    See:
     itk::AffineTransform


    C++ includes: sitkAffineTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AffineTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AffineTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::AffineTransform self, unsigned int dimensions) -> AffineTransform
        __init__(itk::simple::AffineTransform self, AffineTransform arg2) -> AffineTransform
        __init__(itk::simple::AffineTransform self, Transform arg2) -> AffineTransform
        __init__(itk::simple::AffineTransform self, VectorDouble matrix, VectorDouble translation, VectorDouble fixedCenter) -> AffineTransform



        """
        this = _SimpleITK.new_AffineTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(AffineTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.AffineTransform_GetName(self)


    def GetTranslation(self):
        """
        GetTranslation(AffineTransform self) -> VectorDouble



        parameters


        """
        return _SimpleITK.AffineTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(AffineTransform self, VectorDouble translation)



        """
        return _SimpleITK.AffineTransform_SetTranslation(self, translation)


    def SetMatrix(self, matrix):
        """
        SetMatrix(AffineTransform self, VectorDouble matrix)



        """
        return _SimpleITK.AffineTransform_SetMatrix(self, matrix)


    def GetMatrix(self):
        """
        GetMatrix(AffineTransform self) -> VectorDouble



        """
        return _SimpleITK.AffineTransform_GetMatrix(self)


    def SetCenter(self, params):
        """
        SetCenter(AffineTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.AffineTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(AffineTransform self) -> VectorDouble



        """
        return _SimpleITK.AffineTransform_GetCenter(self)


    def Scale(self, *args):
        """
        Scale(AffineTransform self, VectorDouble factor, bool pre=False)
        Scale(AffineTransform self, double factor, bool pre=False)



        """
        return _SimpleITK.AffineTransform_Scale(self, *args)


    def Shear(self, axis1, axis2, coef, pre=False):
        """
        Shear(AffineTransform self, int axis1, int axis2, double coef, bool pre=False)



        """
        return _SimpleITK.AffineTransform_Shear(self, axis1, axis2, coef, pre)


    def Translate(self, offset, pre=False):
        """
        Translate(AffineTransform self, VectorDouble offset, bool pre=False)



        """
        return _SimpleITK.AffineTransform_Translate(self, offset, pre)


    def Rotate(self, axis1, axis2, angle, pre=False):
        """
        Rotate(AffineTransform self, int axis1, int axis2, double angle, bool pre=False)



        """
        return _SimpleITK.AffineTransform_Rotate(self, axis1, axis2, angle, pre)

    __swig_destroy__ = _SimpleITK.delete_AffineTransform
    __del__ = lambda self: None
AffineTransform_swigregister = _SimpleITK.AffineTransform_swigregister
AffineTransform_swigregister(AffineTransform)

class Euler3DTransform(Transform):
    """


    A rigid 3D transform with rotation in radians around a fixed center
    with translation.



    See:
     itk::Euler3DTransform


    C++ includes: sitkEuler3DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Euler3DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Euler3DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::Euler3DTransform self) -> Euler3DTransform
        __init__(itk::simple::Euler3DTransform self, VectorDouble fixedCenter, double angleX=0.0, double angleY=0.0, double angleZ=0.0, VectorDouble translation) -> Euler3DTransform
        __init__(itk::simple::Euler3DTransform self, Euler3DTransform arg2) -> Euler3DTransform
        __init__(itk::simple::Euler3DTransform self, Transform arg2) -> Euler3DTransform



        """
        this = _SimpleITK.new_Euler3DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(Euler3DTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.Euler3DTransform_GetName(self)


    def SetCenter(self, params):
        """
        SetCenter(Euler3DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.Euler3DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(Euler3DTransform self) -> VectorDouble



        """
        return _SimpleITK.Euler3DTransform_GetCenter(self)


    def GetAngleX(self):
        """
        GetAngleX(Euler3DTransform self) -> double



        """
        return _SimpleITK.Euler3DTransform_GetAngleX(self)


    def GetAngleY(self):
        """
        GetAngleY(Euler3DTransform self) -> double



        """
        return _SimpleITK.Euler3DTransform_GetAngleY(self)


    def GetAngleZ(self):
        """
        GetAngleZ(Euler3DTransform self) -> double



        """
        return _SimpleITK.Euler3DTransform_GetAngleZ(self)


    def SetRotation(self, angleX, angleY, angleZ):
        """
        SetRotation(Euler3DTransform self, double angleX, double angleY, double angleZ)



        parameter


        """
        return _SimpleITK.Euler3DTransform_SetRotation(self, angleX, angleY, angleZ)


    def GetTranslation(self):
        """
        GetTranslation(Euler3DTransform self) -> VectorDouble



        """
        return _SimpleITK.Euler3DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(Euler3DTransform self, VectorDouble translation)



        """
        return _SimpleITK.Euler3DTransform_SetTranslation(self, translation)


    def SetComputeZYX(self, _arg):
        """
        SetComputeZYX(Euler3DTransform self, bool _arg)



        """
        return _SimpleITK.Euler3DTransform_SetComputeZYX(self, _arg)


    def GetComputeZYX(self):
        """
        GetComputeZYX(Euler3DTransform self) -> bool



        """
        return _SimpleITK.Euler3DTransform_GetComputeZYX(self)


    def ComputeZYXOn(self):
        """
        ComputeZYXOn(Euler3DTransform self)



        """
        return _SimpleITK.Euler3DTransform_ComputeZYXOn(self)


    def ComputeZYXOff(self):
        """
        ComputeZYXOff(Euler3DTransform self)



        """
        return _SimpleITK.Euler3DTransform_ComputeZYXOff(self)


    def GetMatrix(self):
        """
        GetMatrix(Euler3DTransform self) -> VectorDouble



        additional methods


        """
        return _SimpleITK.Euler3DTransform_GetMatrix(self)


    def SetMatrix(self, matrix, tolerance=1e-10):
        """
        SetMatrix(Euler3DTransform self, VectorDouble matrix, double tolerance=1e-10)



        """
        return _SimpleITK.Euler3DTransform_SetMatrix(self, matrix, tolerance)

    __swig_destroy__ = _SimpleITK.delete_Euler3DTransform
    __del__ = lambda self: None
Euler3DTransform_swigregister = _SimpleITK.Euler3DTransform_swigregister
Euler3DTransform_swigregister(Euler3DTransform)

class Euler2DTransform(Transform):
    """


    A rigid 2D transform with rotation in radians around a fixed center
    with translation.



    See:
     itk::Euler2DTransform


    C++ includes: sitkEuler2DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Euler2DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Euler2DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::Euler2DTransform self) -> Euler2DTransform
        __init__(itk::simple::Euler2DTransform self, VectorDouble fixedCenter, double angle=0.0, VectorDouble translation) -> Euler2DTransform
        __init__(itk::simple::Euler2DTransform self, Euler2DTransform arg2) -> Euler2DTransform
        __init__(itk::simple::Euler2DTransform self, Transform arg2) -> Euler2DTransform



        """
        this = _SimpleITK.new_Euler2DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(Euler2DTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.Euler2DTransform_GetName(self)


    def SetCenter(self, params):
        """
        SetCenter(Euler2DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.Euler2DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(Euler2DTransform self) -> VectorDouble



        """
        return _SimpleITK.Euler2DTransform_GetCenter(self)


    def SetAngle(self, angle):
        """
        SetAngle(Euler2DTransform self, double angle)



        parameter


        """
        return _SimpleITK.Euler2DTransform_SetAngle(self, angle)


    def GetAngle(self):
        """
        GetAngle(Euler2DTransform self) -> double



        """
        return _SimpleITK.Euler2DTransform_GetAngle(self)


    def GetTranslation(self):
        """
        GetTranslation(Euler2DTransform self) -> VectorDouble



        """
        return _SimpleITK.Euler2DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(Euler2DTransform self, VectorDouble translation)



        """
        return _SimpleITK.Euler2DTransform_SetTranslation(self, translation)


    def GetMatrix(self):
        """
        GetMatrix(Euler2DTransform self) -> VectorDouble



        additional methods


        """
        return _SimpleITK.Euler2DTransform_GetMatrix(self)


    def SetMatrix(self, matrix, tolerance=1e-10):
        """
        SetMatrix(Euler2DTransform self, VectorDouble matrix, double tolerance=1e-10)



        """
        return _SimpleITK.Euler2DTransform_SetMatrix(self, matrix, tolerance)

    __swig_destroy__ = _SimpleITK.delete_Euler2DTransform
    __del__ = lambda self: None
Euler2DTransform_swigregister = _SimpleITK.Euler2DTransform_swigregister
Euler2DTransform_swigregister(Euler2DTransform)

class ScaleTransform(Transform):
    """


    A 2D or 3D anisotropic scale of coordinate space around a fixed
    center.



    See:
     itk::ScaleTransform


    C++ includes: sitkScaleTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScaleTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScaleTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::ScaleTransform self, unsigned int dimensions, VectorDouble scale) -> ScaleTransform
        __init__(itk::simple::ScaleTransform self, ScaleTransform arg2) -> ScaleTransform
        __init__(itk::simple::ScaleTransform self, Transform arg2) -> ScaleTransform



        """
        this = _SimpleITK.new_ScaleTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(ScaleTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScaleTransform_GetName(self)


    def SetScale(self, params):
        """
        SetScale(ScaleTransform self, VectorDouble params)



        """
        return _SimpleITK.ScaleTransform_SetScale(self, params)


    def GetScale(self):
        """
        GetScale(ScaleTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleTransform_GetScale(self)


    def SetCenter(self, params):
        """
        SetCenter(ScaleTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.ScaleTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(ScaleTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleTransform_GetCenter(self)


    def GetMatrix(self):
        """
        GetMatrix(ScaleTransform self) -> VectorDouble



        additional methods


        """
        return _SimpleITK.ScaleTransform_GetMatrix(self)

    __swig_destroy__ = _SimpleITK.delete_ScaleTransform
    __del__ = lambda self: None
ScaleTransform_swigregister = _SimpleITK.ScaleTransform_swigregister
ScaleTransform_swigregister(ScaleTransform)

class ScaleSkewVersor3DTransform(Transform):
    """


    A over parameterized 3D Affine transform composed of the addition of a
    versor rotation matrix, a scale matrix and a skew matrix around a
    fixed center with translation.



    See:
     itk::ScaleSkewVersor3DTransform


    C++ includes: sitkScaleSkewVersor3DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScaleSkewVersor3DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScaleSkewVersor3DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::ScaleSkewVersor3DTransform self) -> ScaleSkewVersor3DTransform
        __init__(itk::simple::ScaleSkewVersor3DTransform self, ScaleSkewVersor3DTransform arg2) -> ScaleSkewVersor3DTransform
        __init__(itk::simple::ScaleSkewVersor3DTransform self, Transform arg2) -> ScaleSkewVersor3DTransform
        __init__(itk::simple::ScaleSkewVersor3DTransform self, VectorDouble scale, VectorDouble skew, VectorDouble versor, VectorDouble translation, VectorDouble fixedCenter) -> ScaleSkewVersor3DTransform
        __init__(itk::simple::ScaleSkewVersor3DTransform self, VectorDouble scale, VectorDouble skew, VectorDouble axis, double angle, VectorDouble translation, VectorDouble fixedCenter) -> ScaleSkewVersor3DTransform



        """
        this = _SimpleITK.new_ScaleSkewVersor3DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(ScaleSkewVersor3DTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetName(self)


    def SetCenter(self, params):
        """
        SetCenter(ScaleSkewVersor3DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(ScaleSkewVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetCenter(self)


    def SetRotation(self, *args):
        """
        SetRotation(ScaleSkewVersor3DTransform self, VectorDouble versor)
        SetRotation(ScaleSkewVersor3DTransform self, VectorDouble axis, double angle)



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetRotation(self, *args)


    def GetVersor(self):
        """
        GetVersor(ScaleSkewVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetVersor(self)


    def GetTranslation(self):
        """
        GetTranslation(ScaleSkewVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(ScaleSkewVersor3DTransform self, VectorDouble translation)



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetTranslation(self, translation)


    def GetScale(self):
        """
        GetScale(ScaleSkewVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetScale(self)


    def SetScale(self, scale):
        """
        SetScale(ScaleSkewVersor3DTransform self, VectorDouble scale)



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetScale(self, scale)


    def GetSkew(self):
        """
        GetSkew(ScaleSkewVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetSkew(self)


    def SetSkew(self, skew):
        """
        SetSkew(ScaleSkewVersor3DTransform self, VectorDouble skew)



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_SetSkew(self, skew)


    def Translate(self, offset):
        """
        Translate(ScaleSkewVersor3DTransform self, VectorDouble offset)



        additional methods


        """
        return _SimpleITK.ScaleSkewVersor3DTransform_Translate(self, offset)


    def GetMatrix(self):
        """
        GetMatrix(ScaleSkewVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleSkewVersor3DTransform_GetMatrix(self)

    __swig_destroy__ = _SimpleITK.delete_ScaleSkewVersor3DTransform
    __del__ = lambda self: None
ScaleSkewVersor3DTransform_swigregister = _SimpleITK.ScaleSkewVersor3DTransform_swigregister
ScaleSkewVersor3DTransform_swigregister(ScaleSkewVersor3DTransform)

class ScaleVersor3DTransform(Transform):
    """


    A parameterized 3D transform composed of the addition of a versor
    rotation matrix and a scale matrix around a fixed center with
    translation.



    See:
     itk::ScaleVersor3DTransform


    C++ includes: sitkScaleVersor3DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScaleVersor3DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScaleVersor3DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::ScaleVersor3DTransform self) -> ScaleVersor3DTransform
        __init__(itk::simple::ScaleVersor3DTransform self, ScaleVersor3DTransform arg2) -> ScaleVersor3DTransform
        __init__(itk::simple::ScaleVersor3DTransform self, Transform arg2) -> ScaleVersor3DTransform
        __init__(itk::simple::ScaleVersor3DTransform self, VectorDouble scale, VectorDouble versor, VectorDouble translation, VectorDouble fixedCenter) -> ScaleVersor3DTransform
        __init__(itk::simple::ScaleVersor3DTransform self, VectorDouble scale, VectorDouble axis, double angle, VectorDouble translation, VectorDouble fixedCenter) -> ScaleVersor3DTransform



        """
        this = _SimpleITK.new_ScaleVersor3DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(ScaleVersor3DTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScaleVersor3DTransform_GetName(self)


    def SetCenter(self, params):
        """
        SetCenter(ScaleVersor3DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.ScaleVersor3DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(ScaleVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleVersor3DTransform_GetCenter(self)


    def SetRotation(self, *args):
        """
        SetRotation(ScaleVersor3DTransform self, VectorDouble versor)
        SetRotation(ScaleVersor3DTransform self, VectorDouble axis, double angle)



        """
        return _SimpleITK.ScaleVersor3DTransform_SetRotation(self, *args)


    def GetVersor(self):
        """
        GetVersor(ScaleVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleVersor3DTransform_GetVersor(self)


    def GetTranslation(self):
        """
        GetTranslation(ScaleVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleVersor3DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(ScaleVersor3DTransform self, VectorDouble translation)



        """
        return _SimpleITK.ScaleVersor3DTransform_SetTranslation(self, translation)


    def GetScale(self):
        """
        GetScale(ScaleVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleVersor3DTransform_GetScale(self)


    def SetScale(self, scale):
        """
        SetScale(ScaleVersor3DTransform self, VectorDouble scale)



        """
        return _SimpleITK.ScaleVersor3DTransform_SetScale(self, scale)


    def Translate(self, offset):
        """
        Translate(ScaleVersor3DTransform self, VectorDouble offset)



        additional methods


        """
        return _SimpleITK.ScaleVersor3DTransform_Translate(self, offset)


    def GetMatrix(self):
        """
        GetMatrix(ScaleVersor3DTransform self) -> VectorDouble



        """
        return _SimpleITK.ScaleVersor3DTransform_GetMatrix(self)

    __swig_destroy__ = _SimpleITK.delete_ScaleVersor3DTransform
    __del__ = lambda self: None
ScaleVersor3DTransform_swigregister = _SimpleITK.ScaleVersor3DTransform_swigregister
ScaleVersor3DTransform_swigregister(ScaleVersor3DTransform)

class Similarity2DTransform(Transform):
    """


    A similarity 2D transform with rotation in radians and isotropic
    scaling around a fixed center with translation.



    See:
     itk::Similarity2DTransform


    C++ includes: sitkSimilarity2DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Similarity2DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Similarity2DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::Similarity2DTransform self) -> Similarity2DTransform
        __init__(itk::simple::Similarity2DTransform self, double scaleFactor, double angle=0.0, VectorDouble translation, VectorDouble fixedCenter) -> Similarity2DTransform
        __init__(itk::simple::Similarity2DTransform self, Similarity2DTransform arg2) -> Similarity2DTransform
        __init__(itk::simple::Similarity2DTransform self, Transform arg2) -> Similarity2DTransform



        """
        this = _SimpleITK.new_Similarity2DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(Similarity2DTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.Similarity2DTransform_GetName(self)


    def SetCenter(self, params):
        """
        SetCenter(Similarity2DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.Similarity2DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(Similarity2DTransform self) -> VectorDouble



        """
        return _SimpleITK.Similarity2DTransform_GetCenter(self)


    def SetAngle(self, angle):
        """
        SetAngle(Similarity2DTransform self, double angle)



        parameter


        """
        return _SimpleITK.Similarity2DTransform_SetAngle(self, angle)


    def GetAngle(self):
        """
        GetAngle(Similarity2DTransform self) -> double



        """
        return _SimpleITK.Similarity2DTransform_GetAngle(self)


    def GetTranslation(self):
        """
        GetTranslation(Similarity2DTransform self) -> VectorDouble



        """
        return _SimpleITK.Similarity2DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(Similarity2DTransform self, VectorDouble translation)



        """
        return _SimpleITK.Similarity2DTransform_SetTranslation(self, translation)


    def SetScale(self, scale):
        """
        SetScale(Similarity2DTransform self, double scale)



        """
        return _SimpleITK.Similarity2DTransform_SetScale(self, scale)


    def GetScale(self):
        """
        GetScale(Similarity2DTransform self) -> double



        """
        return _SimpleITK.Similarity2DTransform_GetScale(self)


    def GetMatrix(self):
        """
        GetMatrix(Similarity2DTransform self) -> VectorDouble



        additional methods


        """
        return _SimpleITK.Similarity2DTransform_GetMatrix(self)


    def SetMatrix(self, matrix, tolerance=1e-10):
        """
        SetMatrix(Similarity2DTransform self, VectorDouble matrix, double tolerance=1e-10)



        """
        return _SimpleITK.Similarity2DTransform_SetMatrix(self, matrix, tolerance)

    __swig_destroy__ = _SimpleITK.delete_Similarity2DTransform
    __del__ = lambda self: None
Similarity2DTransform_swigregister = _SimpleITK.Similarity2DTransform_swigregister
Similarity2DTransform_swigregister(Similarity2DTransform)

class Similarity3DTransform(Transform):
    """


    A similarity 3D transform with rotation as a versor, and isotropic
    scaling around a fixed center with translation.



    See:
     itk::Similarity3DTransform


    C++ includes: sitkSimilarity3DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Similarity3DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Similarity3DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::Similarity3DTransform self) -> Similarity3DTransform
        __init__(itk::simple::Similarity3DTransform self, Similarity3DTransform arg2) -> Similarity3DTransform
        __init__(itk::simple::Similarity3DTransform self, Transform arg2) -> Similarity3DTransform
        __init__(itk::simple::Similarity3DTransform self, double scaleFactor, VectorDouble versor, VectorDouble translation, VectorDouble fixedCenter) -> Similarity3DTransform
        __init__(itk::simple::Similarity3DTransform self, double scaleFactor, VectorDouble axis, double angle, VectorDouble translation, VectorDouble fixedCenter) -> Similarity3DTransform



        """
        this = _SimpleITK.new_Similarity3DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(Similarity3DTransform self) -> std::string



        Name of this class


        """
        return _SimpleITK.Similarity3DTransform_GetName(self)


    def SetCenter(self, params):
        """
        SetCenter(Similarity3DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.Similarity3DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(Similarity3DTransform self) -> VectorDouble



        """
        return _SimpleITK.Similarity3DTransform_GetCenter(self)


    def SetRotation(self, *args):
        """
        SetRotation(Similarity3DTransform self, VectorDouble versor)
        SetRotation(Similarity3DTransform self, VectorDouble axis, double angle)



        """
        return _SimpleITK.Similarity3DTransform_SetRotation(self, *args)


    def GetVersor(self):
        """
        GetVersor(Similarity3DTransform self) -> VectorDouble



        """
        return _SimpleITK.Similarity3DTransform_GetVersor(self)


    def SetScale(self, scale):
        """
        SetScale(Similarity3DTransform self, double scale)



        """
        return _SimpleITK.Similarity3DTransform_SetScale(self, scale)


    def GetScale(self):
        """
        GetScale(Similarity3DTransform self) -> double



        """
        return _SimpleITK.Similarity3DTransform_GetScale(self)


    def GetTranslation(self):
        """
        GetTranslation(Similarity3DTransform self) -> VectorDouble



        """
        return _SimpleITK.Similarity3DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(Similarity3DTransform self, VectorDouble translation)



        """
        return _SimpleITK.Similarity3DTransform_SetTranslation(self, translation)


    def Translate(self, offset):
        """
        Translate(Similarity3DTransform self, VectorDouble offset)



        additional methods


        """
        return _SimpleITK.Similarity3DTransform_Translate(self, offset)


    def GetMatrix(self):
        """
        GetMatrix(Similarity3DTransform self) -> VectorDouble



        """
        return _SimpleITK.Similarity3DTransform_GetMatrix(self)


    def SetMatrix(self, matrix, tolerance=1e-10):
        """
        SetMatrix(Similarity3DTransform self, VectorDouble matrix, double tolerance=1e-10)



        """
        return _SimpleITK.Similarity3DTransform_SetMatrix(self, matrix, tolerance)

    __swig_destroy__ = _SimpleITK.delete_Similarity3DTransform
    __del__ = lambda self: None
Similarity3DTransform_swigregister = _SimpleITK.Similarity3DTransform_swigregister
Similarity3DTransform_swigregister(Similarity3DTransform)

class TranslationTransform(Transform):
    """


    Translation of a 2D or 3D coordinate space.



    See:
     itk::TranslationTransform


    C++ includes: sitkTranslationTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::TranslationTransform self, unsigned int dimensions, VectorDouble offset) -> TranslationTransform
        __init__(itk::simple::TranslationTransform self, TranslationTransform arg2) -> TranslationTransform
        __init__(itk::simple::TranslationTransform self, Transform arg2) -> TranslationTransform



        """
        this = _SimpleITK.new_TranslationTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetOffset(self, params):
        """
        SetOffset(TranslationTransform self, VectorDouble params)



        """
        return _SimpleITK.TranslationTransform_SetOffset(self, params)


    def GetOffset(self):
        """
        GetOffset(TranslationTransform self) -> VectorDouble



        """
        return _SimpleITK.TranslationTransform_GetOffset(self)

    __swig_destroy__ = _SimpleITK.delete_TranslationTransform
    __del__ = lambda self: None
TranslationTransform_swigregister = _SimpleITK.TranslationTransform_swigregister
TranslationTransform_swigregister(TranslationTransform)

class VersorTransform(Transform):
    """


    A 3D rotation transfrom with rotation as a versor around a fixed
    center.



    See:
     itk::VersorTransform


    C++ includes: sitkVersorTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VersorTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VersorTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::VersorTransform self) -> VersorTransform
        __init__(itk::simple::VersorTransform self, VersorTransform arg2) -> VersorTransform
        __init__(itk::simple::VersorTransform self, Transform arg2) -> VersorTransform
        __init__(itk::simple::VersorTransform self, VectorDouble versor, VectorDouble fixedCenter) -> VersorTransform
        __init__(itk::simple::VersorTransform self, VectorDouble axis, double angle, VectorDouble fixedCenter) -> VersorTransform



        """
        this = _SimpleITK.new_VersorTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCenter(self, params):
        """
        SetCenter(VersorTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.VersorTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(VersorTransform self) -> VectorDouble



        """
        return _SimpleITK.VersorTransform_GetCenter(self)


    def SetRotation(self, *args):
        """
        SetRotation(VersorTransform self, VectorDouble versor)
        SetRotation(VersorTransform self, VectorDouble axis, double angle)



        """
        return _SimpleITK.VersorTransform_SetRotation(self, *args)


    def GetVersor(self):
        """
        GetVersor(VersorTransform self) -> VectorDouble



        """
        return _SimpleITK.VersorTransform_GetVersor(self)


    def GetMatrix(self):
        """
        GetMatrix(VersorTransform self) -> VectorDouble



        additional methods


        """
        return _SimpleITK.VersorTransform_GetMatrix(self)


    def SetMatrix(self, matrix, tolerance=1e-10):
        """
        SetMatrix(VersorTransform self, VectorDouble matrix, double tolerance=1e-10)



        """
        return _SimpleITK.VersorTransform_SetMatrix(self, matrix, tolerance)

    __swig_destroy__ = _SimpleITK.delete_VersorTransform
    __del__ = lambda self: None
VersorTransform_swigregister = _SimpleITK.VersorTransform_swigregister
VersorTransform_swigregister(VersorTransform)

class VersorRigid3DTransform(Transform):
    """


    A rotation as a versor around a fixed center with translation of a 3D
    coordinate space.



    See:
     itk::VersorRigid3DTransform


    C++ includes: sitkVersorRigid3DTransform.h

    """

    __swig_setmethods__ = {}
    for _s in [Transform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VersorRigid3DTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [Transform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VersorRigid3DTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itk::simple::VersorRigid3DTransform self) -> VersorRigid3DTransform
        __init__(itk::simple::VersorRigid3DTransform self, VersorRigid3DTransform arg2) -> VersorRigid3DTransform
        __init__(itk::simple::VersorRigid3DTransform self, Transform arg2) -> VersorRigid3DTransform
        __init__(itk::simple::VersorRigid3DTransform self, VectorDouble versor, VectorDouble translation, VectorDouble fixedCenter) -> VersorRigid3DTransform
        __init__(itk::simple::VersorRigid3DTransform self, VectorDouble axis, double angle, VectorDouble translation, VectorDouble fixedCenter) -> VersorRigid3DTransform



        """
        this = _SimpleITK.new_VersorRigid3DTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCenter(self, params):
        """
        SetCenter(VersorRigid3DTransform self, VectorDouble params)



        fixed parameter


        """
        return _SimpleITK.VersorRigid3DTransform_SetCenter(self, params)


    def GetCenter(self):
        """
        GetCenter(VersorRigid3DTransform self) -> VectorDouble



        """
        return _SimpleITK.VersorRigid3DTransform_GetCenter(self)


    def SetRotation(self, *args):
        """
        SetRotation(VersorRigid3DTransform self, VectorDouble versor)
        SetRotation(VersorRigid3DTransform self, VectorDouble axis, double angle)



        """
        return _SimpleITK.VersorRigid3DTransform_SetRotation(self, *args)


    def GetVersor(self):
        """
        GetVersor(VersorRigid3DTransform self) -> VectorDouble



        """
        return _SimpleITK.VersorRigid3DTransform_GetVersor(self)


    def GetTranslation(self):
        """
        GetTranslation(VersorRigid3DTransform self) -> VectorDouble



        """
        return _SimpleITK.VersorRigid3DTransform_GetTranslation(self)


    def SetTranslation(self, translation):
        """
        SetTranslation(VersorRigid3DTransform self, VectorDouble translation)



        """
        return _SimpleITK.VersorRigid3DTransform_SetTranslation(self, translation)


    def Translate(self, offset):
        """
        Translate(VersorRigid3DTransform self, VectorDouble offset)



        additional methods


        """
        return _SimpleITK.VersorRigid3DTransform_Translate(self, offset)


    def GetMatrix(self):
        """
        GetMatrix(VersorRigid3DTransform self) -> VectorDouble



        """
        return _SimpleITK.VersorRigid3DTransform_GetMatrix(self)


    def SetMatrix(self, matrix, tolerance=1e-10):
        """
        SetMatrix(VersorRigid3DTransform self, VectorDouble matrix, double tolerance=1e-10)



        """
        return _SimpleITK.VersorRigid3DTransform_SetMatrix(self, matrix, tolerance)

    __swig_destroy__ = _SimpleITK.delete_VersorRigid3DTransform
    __del__ = lambda self: None
VersorRigid3DTransform_swigregister = _SimpleITK.VersorRigid3DTransform_swigregister
VersorRigid3DTransform_swigregister(VersorRigid3DTransform)

class ProcessObject(_object):
    """


    Base class for SimpleITK classes based on ProcessObject.

    C++ includes: sitkProcessObject.h

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProcessObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ProcessObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ProcessObject
    __del__ = lambda self: None

    def __str__(self):
        """
        __str__(ProcessObject self) -> std::string



        """
        return _SimpleITK.ProcessObject___str__(self)


    def GetName(self):
        """
        GetName(ProcessObject self) -> std::string



        return user readable name for the filter


        """
        return _SimpleITK.ProcessObject_GetName(self)


    def DebugOn(self):
        """DebugOn(ProcessObject self)"""
        return _SimpleITK.ProcessObject_DebugOn(self)


    def DebugOff(self):
        """DebugOff(ProcessObject self)"""
        return _SimpleITK.ProcessObject_DebugOff(self)


    def GetDebug(self):
        """GetDebug(ProcessObject self) -> bool"""
        return _SimpleITK.ProcessObject_GetDebug(self)


    def SetDebug(self, debugFlag):
        """SetDebug(ProcessObject self, bool debugFlag)"""
        return _SimpleITK.ProcessObject_SetDebug(self, debugFlag)


    def GlobalDefaultDebugOn():
        """GlobalDefaultDebugOn()"""
        return _SimpleITK.ProcessObject_GlobalDefaultDebugOn()

    GlobalDefaultDebugOn = staticmethod(GlobalDefaultDebugOn)

    def GlobalDefaultDebugOff():
        """GlobalDefaultDebugOff()"""
        return _SimpleITK.ProcessObject_GlobalDefaultDebugOff()

    GlobalDefaultDebugOff = staticmethod(GlobalDefaultDebugOff)

    def GetGlobalDefaultDebug():
        """GetGlobalDefaultDebug() -> bool"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultDebug()

    GetGlobalDefaultDebug = staticmethod(GetGlobalDefaultDebug)

    def SetGlobalDefaultDebug(debugFlag):
        """SetGlobalDefaultDebug(bool debugFlag)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultDebug(debugFlag)

    SetGlobalDefaultDebug = staticmethod(SetGlobalDefaultDebug)

    def GlobalWarningDisplayOn():
        """GlobalWarningDisplayOn()"""
        return _SimpleITK.ProcessObject_GlobalWarningDisplayOn()

    GlobalWarningDisplayOn = staticmethod(GlobalWarningDisplayOn)

    def GlobalWarningDisplayOff():
        """GlobalWarningDisplayOff()"""
        return _SimpleITK.ProcessObject_GlobalWarningDisplayOff()

    GlobalWarningDisplayOff = staticmethod(GlobalWarningDisplayOff)

    def SetGlobalWarningDisplay(flag):
        """SetGlobalWarningDisplay(bool flag)"""
        return _SimpleITK.ProcessObject_SetGlobalWarningDisplay(flag)

    SetGlobalWarningDisplay = staticmethod(SetGlobalWarningDisplay)

    def GetGlobalWarningDisplay():
        """GetGlobalWarningDisplay() -> bool"""
        return _SimpleITK.ProcessObject_GetGlobalWarningDisplay()

    GetGlobalWarningDisplay = staticmethod(GetGlobalWarningDisplay)

    def SetGlobalDefaultNumberOfThreads(n):
        """SetGlobalDefaultNumberOfThreads(unsigned int n)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultNumberOfThreads(n)

    SetGlobalDefaultNumberOfThreads = staticmethod(SetGlobalDefaultNumberOfThreads)

    def GetGlobalDefaultNumberOfThreads():
        """GetGlobalDefaultNumberOfThreads() -> unsigned int"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultNumberOfThreads()

    GetGlobalDefaultNumberOfThreads = staticmethod(GetGlobalDefaultNumberOfThreads)

    def GetGlobalDefaultCoordinateTolerance():
        """GetGlobalDefaultCoordinateTolerance() -> double"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultCoordinateTolerance()

    GetGlobalDefaultCoordinateTolerance = staticmethod(GetGlobalDefaultCoordinateTolerance)

    def SetGlobalDefaultCoordinateTolerance(arg1):
        """SetGlobalDefaultCoordinateTolerance(double arg1)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultCoordinateTolerance(arg1)

    SetGlobalDefaultCoordinateTolerance = staticmethod(SetGlobalDefaultCoordinateTolerance)

    def GetGlobalDefaultDirectionTolerance():
        """GetGlobalDefaultDirectionTolerance() -> double"""
        return _SimpleITK.ProcessObject_GetGlobalDefaultDirectionTolerance()

    GetGlobalDefaultDirectionTolerance = staticmethod(GetGlobalDefaultDirectionTolerance)

    def SetGlobalDefaultDirectionTolerance(arg1):
        """SetGlobalDefaultDirectionTolerance(double arg1)"""
        return _SimpleITK.ProcessObject_SetGlobalDefaultDirectionTolerance(arg1)

    SetGlobalDefaultDirectionTolerance = staticmethod(SetGlobalDefaultDirectionTolerance)

    def SetNumberOfThreads(self, n):
        """SetNumberOfThreads(ProcessObject self, unsigned int n)"""
        return _SimpleITK.ProcessObject_SetNumberOfThreads(self, n)


    def GetNumberOfThreads(self):
        """GetNumberOfThreads(ProcessObject self) -> unsigned int"""
        return _SimpleITK.ProcessObject_GetNumberOfThreads(self)


    def RemoveAllCommands(self):
        """
        RemoveAllCommands(ProcessObject self)



        Remove all registered commands.


        Calling when this object is invoking anther command will produce
        undefined behavior.


        """
        return _SimpleITK.ProcessObject_RemoveAllCommands(self)


    def HasCommand(self, event):
        """
        HasCommand(ProcessObject self, itk::simple::EventEnum event) -> bool



        Query of this object has any registered commands for event.


        """
        return _SimpleITK.ProcessObject_HasCommand(self, event)


    def GetProgress(self):
        """
        GetProgress(ProcessObject self) -> float



        An Active Measurement of the progress of execution.


        Get the execution progress of the current process object. The progress
        is a floating number in [0,1] with 0 meaning no progress and 1 meaning
        the filter has completed execution (or aborted).

        This is an Active Measurement so it can be accessed during Events
        during the execution.


        """
        return _SimpleITK.ProcessObject_GetProgress(self)


    def Abort(self):
        """
        Abort(ProcessObject self)



        Sets an abort flag on the active process.

        Requests the current active process to abort. Additional, progress or
        iteration event may occur. If aborted then, an AbortEvent should
        occur. The Progress should be set to 1.0 after aborting.

        The expected behavior is that not exception should be throw out of
        this processes Execute method. Additionally, the results returned are
        valid but undefined content. The content may be only partially
        updated, uninitialized or the a of size zero.

        If there is no active process the method has no effect.


        """
        return _SimpleITK.ProcessObject_Abort(self)


    def AddCommand(self, *args):
        """
        AddCommand(ProcessObject self, itk::simple::EventEnum event, Command cmd) -> int
        AddCommand(ProcessObject self, itk::simple::EventEnum e, PyObject * obj) -> int



        Add a Command Object to observer the event.


        The Command object's Execute method will be invoked when the internal ITK Object has the event. These events only occur during this ProcessObject's Execute method when the ITK filter is running. The command occurs
        in the same thread as this objects Execute methods was called in.

        An internal reference is made between the Command and this ProcessObject which enable automatic removal of the command when deleted. This
        enables both object to exist as stack based object and be
        automatically cleaned up.

        Unless specified otherwise, it's safe to get any value during
        execution. "Measurements" will have valid values only after the
        Execute method has returned. "Active Measurements" will have valid
        values during events, and access the underlying ITK object.

        Deleting a command this object has during a command call-back will
        produce undefined behavior.

        For more information see the page Commands and Events for SimpleITK.


        The return value is reserved for latter usage.



        """
        return _SimpleITK.ProcessObject_AddCommand(self, *args)

ProcessObject_swigregister = _SimpleITK.ProcessObject_swigregister
ProcessObject_swigregister(ProcessObject)

def ProcessObject_GlobalDefaultDebugOn():
    """ProcessObject_GlobalDefaultDebugOn()"""
    return _SimpleITK.ProcessObject_GlobalDefaultDebugOn()

def ProcessObject_GlobalDefaultDebugOff():
    """ProcessObject_GlobalDefaultDebugOff()"""
    return _SimpleITK.ProcessObject_GlobalDefaultDebugOff()

def ProcessObject_GetGlobalDefaultDebug():
    """ProcessObject_GetGlobalDefaultDebug() -> bool"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultDebug()

def ProcessObject_SetGlobalDefaultDebug(debugFlag):
    """ProcessObject_SetGlobalDefaultDebug(bool debugFlag)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultDebug(debugFlag)

def ProcessObject_GlobalWarningDisplayOn():
    """ProcessObject_GlobalWarningDisplayOn()"""
    return _SimpleITK.ProcessObject_GlobalWarningDisplayOn()

def ProcessObject_GlobalWarningDisplayOff():
    """ProcessObject_GlobalWarningDisplayOff()"""
    return _SimpleITK.ProcessObject_GlobalWarningDisplayOff()

def ProcessObject_SetGlobalWarningDisplay(flag):
    """ProcessObject_SetGlobalWarningDisplay(bool flag)"""
    return _SimpleITK.ProcessObject_SetGlobalWarningDisplay(flag)

def ProcessObject_GetGlobalWarningDisplay():
    """ProcessObject_GetGlobalWarningDisplay() -> bool"""
    return _SimpleITK.ProcessObject_GetGlobalWarningDisplay()

def ProcessObject_SetGlobalDefaultNumberOfThreads(n):
    """ProcessObject_SetGlobalDefaultNumberOfThreads(unsigned int n)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultNumberOfThreads(n)

def ProcessObject_GetGlobalDefaultNumberOfThreads():
    """ProcessObject_GetGlobalDefaultNumberOfThreads() -> unsigned int"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultNumberOfThreads()

def ProcessObject_GetGlobalDefaultCoordinateTolerance():
    """ProcessObject_GetGlobalDefaultCoordinateTolerance() -> double"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultCoordinateTolerance()

def ProcessObject_SetGlobalDefaultCoordinateTolerance(arg2):
    """ProcessObject_SetGlobalDefaultCoordinateTolerance(double arg2)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultCoordinateTolerance(arg2)

def ProcessObject_GetGlobalDefaultDirectionTolerance():
    """ProcessObject_GetGlobalDefaultDirectionTolerance() -> double"""
    return _SimpleITK.ProcessObject_GetGlobalDefaultDirectionTolerance()

def ProcessObject_SetGlobalDefaultDirectionTolerance(arg2):
    """ProcessObject_SetGlobalDefaultDirectionTolerance(double arg2)"""
    return _SimpleITK.ProcessObject_SetGlobalDefaultDirectionTolerance(arg2)

class ImageFilter_0(ProcessObject):
    """


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFilter_0, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFilter_0, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter_0
    __del__ = lambda self: None
ImageFilter_0_swigregister = _SimpleITK.ImageFilter_0_swigregister
ImageFilter_0_swigregister(ImageFilter_0)

class ImageFilter_1(ProcessObject):
    """


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFilter_1, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFilter_1, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter_1
    __del__ = lambda self: None
ImageFilter_1_swigregister = _SimpleITK.ImageFilter_1_swigregister
ImageFilter_1_swigregister(ImageFilter_1)

class ImageFilter_2(ProcessObject):
    """


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFilter_2, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFilter_2, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter_2
    __del__ = lambda self: None
ImageFilter_2_swigregister = _SimpleITK.ImageFilter_2_swigregister
ImageFilter_2_swigregister(ImageFilter_2)

class ImageFilter_3(ProcessObject):
    """


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFilter_3, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFilter_3, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter_3
    __del__ = lambda self: None
ImageFilter_3_swigregister = _SimpleITK.ImageFilter_3_swigregister
ImageFilter_3_swigregister(ImageFilter_3)

class ImageFilter_4(ProcessObject):
    """


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFilter_4, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFilter_4, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter_4
    __del__ = lambda self: None
ImageFilter_4_swigregister = _SimpleITK.ImageFilter_4_swigregister
ImageFilter_4_swigregister(ImageFilter_4)

class ImageFilter_5(ProcessObject):
    """


    The base interface for SimpleITK filters that take one input image.


    All SimpleITK filters which take one input image should inherit from
    this class

    C++ includes: sitkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFilter_5, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFilter_5, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SimpleITK.delete_ImageFilter_5
    __del__ = lambda self: None
ImageFilter_5_swigregister = _SimpleITK.ImageFilter_5_swigregister
ImageFilter_5_swigregister(ImageFilter_5)


def Show(*args, **kwargs):
    """
    Show(Image image, std::string const & title, bool const debugOn=False)



    Display an image using Fiji, ImageJ or another application.

    This function requires that Fiji ( https://fiji.sc ) or ImageJ ( http://rsb.info.nih.gov/ij/) be properly installed for Mac and Windows, and in the user's path
    for Linux. ImageJ must have a plugin for reading Nifti formatted files
    ( http://www.loci.wisc.edu/bio-formats/imagej).

    Nifti is the default file format used to export images. A different
    format can be chosen by setting the SITK_SHOW_EXTENSION environment
    variable. For example, set SITK_SHOW_EXTENSION to ".png" to use PNG
    format.

    The user can specify an application other than ImageJ to view images
    via the SITK_SHOW_COMMAND environment variable.

    The user can also select applications specifically for color images or
    3D images using the SITK_SHOW_COLOR_COMMAND and SITK_SHOW_3D_COMMAND
    environment variables.

    SITK_SHOW_COMMAND, SITK_SHOW_COLOR_COMMAND and SITK_SHOW_3D_COMMAND
    allow the following tokens in their strings.\\li \\c "%a"  for the ImageJ application \\li \\c "%f"
    for SimpleITK's temporary image file

    For example, the default SITK_SHOW_COMMAND string on Linux systems is:


    After token substitution it may become:


    For another example, the default SITK_SHOW_COLOR_COMMAND string on Mac
    OS X is:


    After token substitution the string may become:


    The string after "-eval" is an ImageJ macro the opens the file and runs ImageJ's Make
    Composite command to display the image in color.

    If the "%f" token is not found in the command string, the temporary file name is
    automatically appended to the command argument list.

    When invoked, Show searches for Fiji first, and then ImageJ. Fiji is
    the most update-to-date version of ImageJ and includes a lot of
    plugins which facilitate scientific image analysis. By default, for a
    64-bit build of SimpleITK on Macs, sitkShow searches for ImageJ64.app.
    For a 32-bit Mac build, sitkShow searches for ImageJ.app. If the user
    prefers a different version of ImageJ (or a different image viewer
    altogether), it can be specified using the SITK_SHOW_COMMAND
    environment variable.

    The boolean parameter debugOn prints the search path Show uses to find
    ImageJ, the full path to the ImageJ it found, and the full command
    line used to invoke ImageJ.


    """
    return _SimpleITK.Show(*args, **kwargs)
class ImageFileWriter(ProcessObject):
    """


    Write out a SimpleITK image to the specified file location.


    This writer tries to write the image out using the image's type to the
    location specified in FileName. If writing fails, an ITK exception is
    thrown.


    See:
     itk::simple::WriteImage for the procedural interface


    C++ includes: sitkImageFileWriter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFileWriter, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFileWriter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ImageFileWriter self) -> ImageFileWriter



        """
        this = _SimpleITK.new_ImageFileWriter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """
        __str__(ImageFileWriter self) -> std::string



        Print ourselves to string


        """
        return _SimpleITK.ImageFileWriter___str__(self)


    def GetName(self):
        """
        GetName(ImageFileWriter self) -> std::string



        return user readable name fo the filter


        """
        return _SimpleITK.ImageFileWriter_GetName(self)


    def SetUseCompression(self, UseCompression):
        """SetUseCompression(ImageFileWriter self, bool UseCompression)"""
        return _SimpleITK.ImageFileWriter_SetUseCompression(self, UseCompression)


    def GetUseCompression(self):
        """GetUseCompression(ImageFileWriter self) -> bool"""
        return _SimpleITK.ImageFileWriter_GetUseCompression(self)


    def UseCompressionOn(self):
        """UseCompressionOn(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_UseCompressionOn(self)


    def UseCompressionOff(self):
        """UseCompressionOff(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_UseCompressionOff(self)


    def SetKeepOriginalImageUID(self, KeepOriginalImageUID):
        """SetKeepOriginalImageUID(ImageFileWriter self, bool KeepOriginalImageUID)"""
        return _SimpleITK.ImageFileWriter_SetKeepOriginalImageUID(self, KeepOriginalImageUID)


    def GetKeepOriginalImageUID(self):
        """GetKeepOriginalImageUID(ImageFileWriter self) -> bool"""
        return _SimpleITK.ImageFileWriter_GetKeepOriginalImageUID(self)


    def KeepOriginalImageUIDOn(self):
        """KeepOriginalImageUIDOn(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_KeepOriginalImageUIDOn(self)


    def KeepOriginalImageUIDOff(self):
        """KeepOriginalImageUIDOff(ImageFileWriter self)"""
        return _SimpleITK.ImageFileWriter_KeepOriginalImageUIDOff(self)


    def SetFileName(self, fileName):
        """
        SetFileName(ImageFileWriter self, std::string const & fileName)



        """
        return _SimpleITK.ImageFileWriter_SetFileName(self, fileName)


    def GetFileName(self):
        """
        GetFileName(ImageFileWriter self) -> std::string



        """
        return _SimpleITK.ImageFileWriter_GetFileName(self)


    def Execute(self, *args):
        """
        Execute(ImageFileWriter self, Image arg2)
        Execute(ImageFileWriter self, Image arg2, std::string const & inFileName, bool inUseCompression)



        """
        return _SimpleITK.ImageFileWriter_Execute(self, *args)

    __swig_destroy__ = _SimpleITK.delete_ImageFileWriter
    __del__ = lambda self: None
ImageFileWriter_swigregister = _SimpleITK.ImageFileWriter_swigregister
ImageFileWriter_swigregister(ImageFileWriter)

class ImageSeriesWriter(ProcessObject):
    """


    Writer series of image from a SimpleITK image.


    The ImageSeriesWriter is for writing a 3D image as a series of 2D images. A list of names
    for the series of 2D images must be provided, and an exception will be
    generated if the number of file names does not match the size of the
    image in the z-direction.

    DICOM series cannot be written with this class, as an exception will
    be generated. To write a DICOM series the individual slices must be
    extracted, proper DICOM tags must be added to the dictionaries, then
    written with the ImageFileWriter.


    See:
     itk::simple::WriteImage for the procedural interface


    C++ includes: sitkImageSeriesWriter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageSeriesWriter, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageSeriesWriter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ImageSeriesWriter self) -> ImageSeriesWriter



        """
        this = _SimpleITK.new_ImageSeriesWriter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """
        __str__(ImageSeriesWriter self) -> std::string



        Print ourselves to string


        """
        return _SimpleITK.ImageSeriesWriter___str__(self)


    def GetName(self):
        """
        GetName(ImageSeriesWriter self) -> std::string



        return user readable name fo the filter


        """
        return _SimpleITK.ImageSeriesWriter_GetName(self)


    def SetUseCompression(self, UseCompression):
        """SetUseCompression(ImageSeriesWriter self, bool UseCompression)"""
        return _SimpleITK.ImageSeriesWriter_SetUseCompression(self, UseCompression)


    def GetUseCompression(self):
        """GetUseCompression(ImageSeriesWriter self) -> bool"""
        return _SimpleITK.ImageSeriesWriter_GetUseCompression(self)


    def UseCompressionOn(self):
        """UseCompressionOn(ImageSeriesWriter self)"""
        return _SimpleITK.ImageSeriesWriter_UseCompressionOn(self)


    def UseCompressionOff(self):
        """UseCompressionOff(ImageSeriesWriter self)"""
        return _SimpleITK.ImageSeriesWriter_UseCompressionOff(self)


    def SetFileNames(self, fileNames):
        """SetFileNames(ImageSeriesWriter self, VectorString fileNames)"""
        return _SimpleITK.ImageSeriesWriter_SetFileNames(self, fileNames)


    def GetFileNames(self):
        """GetFileNames(ImageSeriesWriter self) -> VectorString"""
        return _SimpleITK.ImageSeriesWriter_GetFileNames(self)


    def Execute(self, *args):
        """
        Execute(ImageSeriesWriter self, Image arg2)
        Execute(ImageSeriesWriter self, Image image, VectorString inFileNames, bool inUseCompression)



        """
        return _SimpleITK.ImageSeriesWriter_Execute(self, *args)

    __swig_destroy__ = _SimpleITK.delete_ImageSeriesWriter
    __del__ = lambda self: None
ImageSeriesWriter_swigregister = _SimpleITK.ImageSeriesWriter_swigregister
ImageSeriesWriter_swigregister(ImageSeriesWriter)


def WriteImage(*args):
    """
    WriteImage(Image image, std::string const & fileName, bool useCompression=False)
    WriteImage(Image image, VectorString fileNames, bool inUseCompression=False)



    """
    return _SimpleITK.WriteImage(*args)
class ImageReaderBase(ProcessObject):
    """


    An abract base class for image readers.

    C++ includes: sitkImageReaderBase.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageReaderBase, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageReaderBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetOutputPixelType(self, pixelID):
        """SetOutputPixelType(ImageReaderBase self, itk::simple::PixelIDValueEnum pixelID)"""
        return _SimpleITK.ImageReaderBase_SetOutputPixelType(self, pixelID)


    def GetOutputPixelType(self):
        """GetOutputPixelType(ImageReaderBase self) -> itk::simple::PixelIDValueEnum"""
        return _SimpleITK.ImageReaderBase_GetOutputPixelType(self)


    def Execute(self):
        """
        Execute(ImageReaderBase self) -> Image



        """
        return _SimpleITK.ImageReaderBase_Execute(self)


    def __str__(self):
        """
        __str__(ImageReaderBase self) -> std::string



        """
        return _SimpleITK.ImageReaderBase___str__(self)


    def SetLoadPrivateTags(self, loadPrivateTags):
        """SetLoadPrivateTags(ImageReaderBase self, bool loadPrivateTags) -> ImageReaderBase"""
        return _SimpleITK.ImageReaderBase_SetLoadPrivateTags(self, loadPrivateTags)


    def GetLoadPrivateTags(self):
        """GetLoadPrivateTags(ImageReaderBase self) -> bool"""
        return _SimpleITK.ImageReaderBase_GetLoadPrivateTags(self)


    def LoadPrivateTagsOn(self):
        """LoadPrivateTagsOn(ImageReaderBase self)"""
        return _SimpleITK.ImageReaderBase_LoadPrivateTagsOn(self)


    def LoadPrivateTagsOff(self):
        """LoadPrivateTagsOff(ImageReaderBase self)"""
        return _SimpleITK.ImageReaderBase_LoadPrivateTagsOff(self)

    __swig_destroy__ = _SimpleITK.delete_ImageReaderBase
    __del__ = lambda self: None
ImageReaderBase_swigregister = _SimpleITK.ImageReaderBase_swigregister
ImageReaderBase_swigregister(ImageReaderBase)

class ImageSeriesReader(ImageReaderBase):
    """


    Read series of image into a SimpleITK image.



    See:
     itk::simple::ReadImage for the procedural interface


    C++ includes: sitkImageSeriesReader.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageReaderBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageSeriesReader, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageReaderBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageSeriesReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ImageSeriesReader self) -> ImageSeriesReader



        """
        this = _SimpleITK.new_ImageSeriesReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        """
        __str__(ImageSeriesReader self) -> std::string



        Print ourselves to string


        """
        return _SimpleITK.ImageSeriesReader___str__(self)


    def GetName(self):
        """
        GetName(ImageSeriesReader self) -> std::string



        return user readable name fo the filter


        """
        return _SimpleITK.ImageSeriesReader_GetName(self)


    def GetGDCMSeriesFileNames(*args, **kwargs):
        """GetGDCMSeriesFileNames(std::string const & directory, std::string const & seriesID, bool useSeriesDetails=False, bool recursive=False, bool loadSequences=False) -> VectorString"""
        return _SimpleITK.ImageSeriesReader_GetGDCMSeriesFileNames(*args, **kwargs)

    GetGDCMSeriesFileNames = staticmethod(GetGDCMSeriesFileNames)

    def GetGDCMSeriesIDs(directory):
        """GetGDCMSeriesIDs(std::string const & directory) -> VectorString"""
        return _SimpleITK.ImageSeriesReader_GetGDCMSeriesIDs(directory)

    GetGDCMSeriesIDs = staticmethod(GetGDCMSeriesIDs)

    def SetFileNames(self, fileNames):
        """
        SetFileNames(ImageSeriesReader self, VectorString fileNames)



        """
        return _SimpleITK.ImageSeriesReader_SetFileNames(self, fileNames)


    def GetFileNames(self):
        """
        GetFileNames(ImageSeriesReader self) -> VectorString



        """
        return _SimpleITK.ImageSeriesReader_GetFileNames(self)


    def Execute(self):
        """
        Execute(ImageSeriesReader self) -> Image



        """
        return _SimpleITK.ImageSeriesReader_Execute(self)

    __swig_destroy__ = _SimpleITK.delete_ImageSeriesReader
    __del__ = lambda self: None
ImageSeriesReader_swigregister = _SimpleITK.ImageSeriesReader_swigregister
ImageSeriesReader_swigregister(ImageSeriesReader)

def ImageSeriesReader_GetGDCMSeriesFileNames(*args, **kwargs):
    """ImageSeriesReader_GetGDCMSeriesFileNames(std::string const & directory, std::string const & seriesID, bool useSeriesDetails=False, bool recursive=False, bool loadSequences=False) -> VectorString"""
    return _SimpleITK.ImageSeriesReader_GetGDCMSeriesFileNames(*args, **kwargs)

def ImageSeriesReader_GetGDCMSeriesIDs(directory):
    """ImageSeriesReader_GetGDCMSeriesIDs(std::string const & directory) -> VectorString"""
    return _SimpleITK.ImageSeriesReader_GetGDCMSeriesIDs(directory)

class ImageFileReader(ImageReaderBase):
    """


    Read a 2D or 3D image and return a smart pointer to a SimpleITK image.


    This reader handles scalar and vector images and returns an image with
    the same type as the file on disk.


    See:
     itk::simple::ReadImage for the procedural interface


    C++ includes: sitkImageFileReader.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageReaderBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFileReader, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageReaderBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFileReader, name)
    __repr__ = _swig_repr

    def __str__(self):
        """
        __str__(ImageFileReader self) -> std::string



        Print ourselves to string


        """
        return _SimpleITK.ImageFileReader___str__(self)


    def GetName(self):
        """
        GetName(ImageFileReader self) -> std::string



        return user readable name fo the filter


        """
        return _SimpleITK.ImageFileReader_GetName(self)


    def SetFileName(self, fn):
        """
        SetFileName(ImageFileReader self, std::string const & fn)



        """
        return _SimpleITK.ImageFileReader_SetFileName(self, fn)


    def GetFileName(self):
        """
        GetFileName(ImageFileReader self) -> std::string



        """
        return _SimpleITK.ImageFileReader_GetFileName(self)


    def Execute(self):
        """
        Execute(ImageFileReader self) -> Image



        """
        return _SimpleITK.ImageFileReader_Execute(self)


    def __init__(self):
        """
        __init__(itk::simple::ImageFileReader self) -> ImageFileReader



        """
        this = _SimpleITK.new_ImageFileReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ImageFileReader
    __del__ = lambda self: None
ImageFileReader_swigregister = _SimpleITK.ImageFileReader_swigregister
ImageFileReader_swigregister(ImageFileReader)


def ReadImage(*args):
    """
    ReadImage(VectorString fileNames, itk::simple::PixelIDValueEnum outputPixelType) -> Image
    ReadImage(std::string const & filename, itk::simple::PixelIDValueEnum outputPixelType) -> Image



    ReadImage is a procedural interface to the ImageSeriesReader class which is convenient for most image reading tasks.


    Note that when reading a series of images that have meta-data
    associated with them (e.g. a DICOM series) the resulting image will
    have an empty meta-data dictionary. It is possible to programmatically
    add a meta-data dictionary to the compounded image by reading in one
    or more images from the series using the ImageFileReader class,
    analyzing the meta-dictionary associated with each of those images and
    creating one that is relevant for the compounded image.


    See:
     itk::simple::ImageFileReader for reading a single file



    """
    return _SimpleITK.ReadImage(*args)
class HashImageFilter(ProcessObject):
    """


    Compute the sha1 or md5 hash of an image.



    See:
     itk::simple::Hash for the procedural interface


    C++ includes: sitkHashImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HashImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HashImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HashImageFilter self) -> HashImageFilter



        """
        this = _SimpleITK.new_HashImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    SHA1 = _SimpleITK.HashImageFilter_SHA1
    MD5 = _SimpleITK.HashImageFilter_MD5

    def SetHashFunction(self, hashFunction):
        """
        SetHashFunction(HashImageFilter self, itk::simple::HashImageFilter::HashFunction hashFunction)



        """
        return _SimpleITK.HashImageFilter_SetHashFunction(self, hashFunction)


    def GetHashFunction(self):
        """
        GetHashFunction(HashImageFilter self) -> itk::simple::HashImageFilter::HashFunction



        """
        return _SimpleITK.HashImageFilter_GetHashFunction(self)


    def GetName(self):
        """
        GetName(HashImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HashImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HashImageFilter self) -> std::string



        """
        return _SimpleITK.HashImageFilter___str__(self)


    def Execute(self, arg2):
        """
        Execute(HashImageFilter self, Image arg2) -> std::string



        """
        return _SimpleITK.HashImageFilter_Execute(self, arg2)

    __swig_destroy__ = _SimpleITK.delete_HashImageFilter
    __del__ = lambda self: None
HashImageFilter_swigregister = _SimpleITK.HashImageFilter_swigregister
HashImageFilter_swigregister(HashImageFilter)


def Hash(*args, **kwargs):
    """
    Hash(Image image, itk::simple::HashImageFilter::HashFunction function) -> std::string



    """
    return _SimpleITK.Hash(*args, **kwargs)
class BSplineTransformInitializerFilter(ProcessObject):
    """


    BSplineTransformInitializerFilter is a helper class intended to initialize the control point grid such
    that it has a physically consistent definition. It sets the transform
    domain origin, physical dimensions and direction from information
    obtained from the image. It also sets the mesh size if asked to do so
    by calling SetTransformDomainMeshSize()before calling InitializeTransform().



    Luis Ibanez
     Nick Tustison
    See:
     itk::simple::BSplineTransformInitializer for the procedural interface

     itk::BSplineTransformInitializer for the Doxygen on the original ITK class.


    C++ includes: sitkBSplineTransformInitializerFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BSplineTransformInitializerFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BSplineTransformInitializerFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BSplineTransformInitializerFilter self) -> BSplineTransformInitializerFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BSplineTransformInitializerFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BSplineTransformInitializerFilter
    __del__ = lambda self: None

    def SetTransformDomainMeshSize(self, TransformDomainMeshSize):
        """
        SetTransformDomainMeshSize(BSplineTransformInitializerFilter self, VectorUInt32 TransformDomainMeshSize)



        Allow the user to set the mesh size of the transform via the
        initializer even though the initializer does not do anything with that
        information. Defeault = 1^ImageDimension.


        """
        return _SimpleITK.BSplineTransformInitializerFilter_SetTransformDomainMeshSize(self, TransformDomainMeshSize)


    def GetTransformDomainMeshSize(self):
        """
        GetTransformDomainMeshSize(BSplineTransformInitializerFilter self) -> VectorUInt32



        """
        return _SimpleITK.BSplineTransformInitializerFilter_GetTransformDomainMeshSize(self)


    def SetOrder(self, order):
        """
        SetOrder(BSplineTransformInitializerFilter self, unsigned int order)



        The order of the bspline in the output BSplineTransform. This value effects the number of control points.


        """
        return _SimpleITK.BSplineTransformInitializerFilter_SetOrder(self, order)


    def GetOrder(self):
        """
        GetOrder(BSplineTransformInitializerFilter self) -> unsigned int



        """
        return _SimpleITK.BSplineTransformInitializerFilter_GetOrder(self)


    def GetName(self):
        """
        GetName(BSplineTransformInitializerFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BSplineTransformInitializerFilter_GetName(self)


    def __str__(self):
        """
        __str__(BSplineTransformInitializerFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BSplineTransformInitializerFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BSplineTransformInitializerFilter self, Image image1) -> BSplineTransform
        Execute(BSplineTransformInitializerFilter self, Image image1, VectorUInt32 transformDomainMeshSize, unsigned int order) -> BSplineTransform



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BSplineTransformInitializerFilter_Execute(self, *args)

BSplineTransformInitializerFilter_swigregister = _SimpleITK.BSplineTransformInitializerFilter_swigregister
BSplineTransformInitializerFilter_swigregister(BSplineTransformInitializerFilter)


def BSplineTransformInitializer(*args, **kwargs):
    """
    BSplineTransformInitializer(Image image1, VectorUInt32 transformDomainMeshSize, unsigned int order=3) -> BSplineTransform



    BSplineTransformInitializerFilter is a helper class intended to initialize the control point grid such
    that it has a physically consistent definition. It sets the transform
    domain origin, physical dimensions and direction from information
    obtained from the image. It also sets the mesh size if asked to do so
    by calling SetTransformDomainMeshSize()before calling
    InitializeTransform().


    This function directly calls the execute method of BSplineTransformInitializerFilter in order to support a procedural API


    See:
     itk::simple::BSplineTransformInitializerFilter for the object oriented interface



    """
    return _SimpleITK.BSplineTransformInitializer(*args, **kwargs)
class CenteredTransformInitializerFilter(ProcessObject):
    """


    CenteredTransformInitializerFilter is a helper class intended to initialize the center of rotation and
    the translation of Transforms having the center of rotation among
    their parameters.


    This class is connected to the fixed image, moving image and transform
    involved in the registration. Two modes of operation are possible:


    Geometrical,

    Center of mass
     In the first mode, the geometrical center of the moving image is
    passed as initial center of rotation to the transform and the vector
    from the center of the fixed image to the center of the moving image
    is passed as the initial translation. This mode basically assumes that
    the anatomical objects to be registered are centered in their
    respective images. Hence the best initial guess for the registration
    is the one that superimposes those two centers.

    In the second mode, the moments of gray level values are computed for
    both images. The center of mass of the moving image is then used as
    center of rotation. The vector between the two centers of mass is
    passes as the initial translation to the transform. This second
    approach assumes that the moments of the anatomical objects are
    similar for both images and hence the best initial guess for
    registration is to superimpose both mass centers. Note that this
    assumption will probably not hold in multi-modality registration.   \\sa itk::CenteredTransformInitializer

    C++ includes: sitkCenteredTransformInitializerFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CenteredTransformInitializerFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CenteredTransformInitializerFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CenteredTransformInitializerFilter self) -> CenteredTransformInitializerFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CenteredTransformInitializerFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CenteredTransformInitializerFilter
    __del__ = lambda self: None
    GEOMETRY = _SimpleITK.CenteredTransformInitializerFilter_GEOMETRY
    MOMENTS = _SimpleITK.CenteredTransformInitializerFilter_MOMENTS

    def SetOperationMode(self, OperationMode):
        """
        SetOperationMode(CenteredTransformInitializerFilter self, itk::simple::CenteredTransformInitializerFilter::OperationModeType OperationMode)



        """
        return _SimpleITK.CenteredTransformInitializerFilter_SetOperationMode(self, OperationMode)


    def GetOperationMode(self):
        """
        GetOperationMode(CenteredTransformInitializerFilter self) -> itk::simple::CenteredTransformInitializerFilter::OperationModeType



        """
        return _SimpleITK.CenteredTransformInitializerFilter_GetOperationMode(self)


    def GetName(self):
        """
        GetName(CenteredTransformInitializerFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CenteredTransformInitializerFilter_GetName(self)


    def __str__(self):
        """
        __str__(CenteredTransformInitializerFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CenteredTransformInitializerFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CenteredTransformInitializerFilter self, Image fixedImage, Image movingImage, Transform transform) -> Transform
        Execute(CenteredTransformInitializerFilter self, Image fixedImage, Image movingImage, Transform transform, itk::simple::CenteredTransformInitializerFilter::OperationModeType operationMode) -> Transform



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CenteredTransformInitializerFilter_Execute(self, *args)


    def MomentsOn(self):
        """
        MomentsOn(CenteredTransformInitializerFilter self)



        Select between using the geometrical center of the images or using the
        center of mass given by the image intensities.


        """
        return _SimpleITK.CenteredTransformInitializerFilter_MomentsOn(self)


    def GeometryOn(self):
        """
        GeometryOn(CenteredTransformInitializerFilter self)



        Select between using the geometrical center of the images or using the
        center of mass given by the image intensities.


        """
        return _SimpleITK.CenteredTransformInitializerFilter_GeometryOn(self)

CenteredTransformInitializerFilter_swigregister = _SimpleITK.CenteredTransformInitializerFilter_swigregister
CenteredTransformInitializerFilter_swigregister(CenteredTransformInitializerFilter)


def CenteredTransformInitializer(*args, **kwargs):
    """
    CenteredTransformInitializer(Image fixedImage, Image movingImage, Transform transform, itk::simple::CenteredTransformInitializerFilter::OperationModeType operationMode) -> Transform



    CenteredTransformInitializer is a helper class intended to initialize the center of rotation and
    the translation of Transforms having the center of rotation among
    their parameters.


    This function directly calls the execute method of CenteredTransformInitializerFilter in order to support a procedural API


    See:
     itk::simple::CenteredTransformInitializerFilter for the object oriented interface



    """
    return _SimpleITK.CenteredTransformInitializer(*args, **kwargs)
class CenteredVersorTransformInitializerFilter(ProcessObject):
    """


    CenteredVersorTransformInitializerFilter is a helper class intended to initialize the center of rotation,
    versor, and translation of the VersorRigid3DTransform.


    This class derived from the CenteredTransformInitializerand uses it in
    a more constrained context. It always uses the Moments mode, and also
    takes advantage of the second order moments in order to initialize the
    Versorrepresenting rotation.


    See:
     itk::CenteredVersorTransformInitializer for the Doxygen on the original ITK class.


    C++ includes: sitkCenteredVersorTransformInitializerFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CenteredVersorTransformInitializerFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CenteredVersorTransformInitializerFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CenteredVersorTransformInitializerFilter self) -> CenteredVersorTransformInitializerFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CenteredVersorTransformInitializerFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CenteredVersorTransformInitializerFilter
    __del__ = lambda self: None

    def SetComputeRotation(self, ComputeRotation):
        """
        SetComputeRotation(CenteredVersorTransformInitializerFilter self, bool ComputeRotation)



        Enable the use of the principal axes of each image to compute an
        initial rotation that will align them.


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_SetComputeRotation(self, ComputeRotation)


    def ComputeRotationOn(self):
        """
        ComputeRotationOn(CenteredVersorTransformInitializerFilter self)



        Set the value of ComputeRotation to true or false respectfully.


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_ComputeRotationOn(self)


    def ComputeRotationOff(self):
        """
        ComputeRotationOff(CenteredVersorTransformInitializerFilter self)



        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_ComputeRotationOff(self)


    def GetComputeRotation(self):
        """
        GetComputeRotation(CenteredVersorTransformInitializerFilter self) -> bool



        Enable the use of the principal axes of each image to compute an
        initial rotation that will align them.


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_GetComputeRotation(self)


    def GetName(self):
        """
        GetName(CenteredVersorTransformInitializerFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_GetName(self)


    def __str__(self):
        """
        __str__(CenteredVersorTransformInitializerFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CenteredVersorTransformInitializerFilter self, Image fixedImage, Image movingImage, Transform transform) -> Transform
        Execute(CenteredVersorTransformInitializerFilter self, Image fixedImage, Image movingImage, Transform transform, bool computeRotation) -> Transform



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CenteredVersorTransformInitializerFilter_Execute(self, *args)

CenteredVersorTransformInitializerFilter_swigregister = _SimpleITK.CenteredVersorTransformInitializerFilter_swigregister
CenteredVersorTransformInitializerFilter_swigregister(CenteredVersorTransformInitializerFilter)


def CenteredVersorTransformInitializer(fixedImage, movingImage, transform, computeRotation=False):
    """
    CenteredVersorTransformInitializer(Image fixedImage, Image movingImage, Transform transform, bool computeRotation=False) -> Transform



    CenteredVersorTransformInitializer is a helper class intended to initialize the center of rotation,
    versor, and translation of the VersorRigid3DTransform.


    This function directly calls the execute method of
    CenteredVectorTransformInitializerFilter in order to support a
    procedural API.


    See:
     itk::simple::CenteredVersorTransformInitializerFilter for the object oriented interface



    """
    return _SimpleITK.CenteredVersorTransformInitializer(fixedImage, movingImage, transform, computeRotation)
class LandmarkBasedTransformInitializerFilter(ImageFilter_0):
    """


    This class computes the transform that aligns the fixed and moving
    images given a set of pair landmarks. The class is templated over the Transform type as well as fixed image and moving image types. The transform
    computed gives the best fit transform that maps the fixed and moving
    images in a least squares sense. The indices are taken to correspond,
    so point 1 in the first set will get mapped close to point 1 in the
    second set, etc.

    Currently, the following transforms are supported by the class: VersorRigid3DTransform Rigid2DTransform AffineTransform BSplineTransform

    An equal number of fixed and moving landmarks need to be specified
    using SetFixedLandmarks() and SetMovingLandmarks() . Any number of landmarks may be specified. In the case of using
    Affine or BSpline transforms, each landmark pair can contribute in the
    final transform based on its defined weight. Number of weights should
    be equal to the number of landmarks and can be specified using SetLandmarkWeight() . By defaults are weights are set to one. Call InitializeTransform()
    to initialize the transform.

    The class is based in part on Hybrid/vtkLandmarkTransform originally
    implemented in python by David G. Gobbi.

    The solution is based on Berthold K. P. Horn (1987), "Closed-form
    solution of absolute orientation using unit quaternions," http://people.csail.mit.edu/bkph/papers/Absolute_Orientation.pdf

    The Affine Transform initializer is based on an algorithm by H Spaeth, and is described in
    the Insight Journal Article "Affine Transformation for Landmark Based
    Registration Initializer in ITK" by Kim E.Y., Johnson H., Williams N.
    available at http://midasjournal.com/browse/publication/825

    Wiki Examples:

    All Examples

    Rigidly register one image to another using manually specified
    landmarks
    See:
     itk::simple::LandmarkBasedTransformInitializerFilter for the procedural interface

     itk::LandmarkBasedTransformInitializer for the Doxygen on the original ITK class.



    C++ includes: sitkLandmarkBasedTransformInitializerFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LandmarkBasedTransformInitializerFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LandmarkBasedTransformInitializerFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LandmarkBasedTransformInitializerFilter self) -> LandmarkBasedTransformInitializerFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LandmarkBasedTransformInitializerFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LandmarkBasedTransformInitializerFilter
    __del__ = lambda self: None

    def SetFixedLandmarks(self, FixedLandmarks):
        """
        SetFixedLandmarks(LandmarkBasedTransformInitializerFilter self, VectorDouble FixedLandmarks)



        Set the Fixed landmark point containers


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetFixedLandmarks(self, FixedLandmarks)


    def GetFixedLandmarks(self):
        """
        GetFixedLandmarks(LandmarkBasedTransformInitializerFilter self) -> VectorDouble



        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetFixedLandmarks(self)


    def SetMovingLandmarks(self, MovingLandmarks):
        """
        SetMovingLandmarks(LandmarkBasedTransformInitializerFilter self, VectorDouble MovingLandmarks)



        Set the Moving landmark point containers


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetMovingLandmarks(self, MovingLandmarks)


    def GetMovingLandmarks(self):
        """
        GetMovingLandmarks(LandmarkBasedTransformInitializerFilter self) -> VectorDouble



        Get the shrink factors.


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetMovingLandmarks(self)


    def SetLandmarkWeight(self, LandmarkWeight):
        """
        SetLandmarkWeight(LandmarkBasedTransformInitializerFilter self, VectorDouble LandmarkWeight)



        Set the landmark weight point containers Weight includes diagonal
        elements of weight matrix


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetLandmarkWeight(self, LandmarkWeight)


    def GetLandmarkWeight(self):
        """
        GetLandmarkWeight(LandmarkBasedTransformInitializerFilter self) -> VectorDouble



        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetLandmarkWeight(self)


    def SetReferenceImage(self, ReferenceImage):
        """
        SetReferenceImage(LandmarkBasedTransformInitializerFilter self, Image ReferenceImage)



        Set the reference image to define the parametric domain for the
        BSpline transform


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetReferenceImage(self, ReferenceImage)


    def GetReferenceImage(self):
        """
        GetReferenceImage(LandmarkBasedTransformInitializerFilter self) -> Image



        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetReferenceImage(self)


    def SetBSplineNumberOfControlPoints(self, BSplineNumberOfControlPoints):
        """
        SetBSplineNumberOfControlPoints(LandmarkBasedTransformInitializerFilter self, unsigned int BSplineNumberOfControlPoints)



        Set/Get the number of control points


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_SetBSplineNumberOfControlPoints(self, BSplineNumberOfControlPoints)


    def GetBSplineNumberOfControlPoints(self):
        """
        GetBSplineNumberOfControlPoints(LandmarkBasedTransformInitializerFilter self) -> unsigned int



        Set/Get the number of control points


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetBSplineNumberOfControlPoints(self)


    def GetName(self):
        """
        GetName(LandmarkBasedTransformInitializerFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_GetName(self)


    def __str__(self):
        """
        __str__(LandmarkBasedTransformInitializerFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LandmarkBasedTransformInitializerFilter self, Transform transform) -> Transform
        Execute(LandmarkBasedTransformInitializerFilter self, Transform transform, VectorDouble fixedLandmarks, VectorDouble movingLandmarks, VectorDouble landmarkWeight, Image referenceImage, unsigned int numberOfControlPoints) -> Transform



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LandmarkBasedTransformInitializerFilter_Execute(self, *args)

LandmarkBasedTransformInitializerFilter_swigregister = _SimpleITK.LandmarkBasedTransformInitializerFilter_swigregister
LandmarkBasedTransformInitializerFilter_swigregister(LandmarkBasedTransformInitializerFilter)


def LandmarkBasedTransformInitializer(*args, **kwargs):
    """
    LandmarkBasedTransformInitializer(Transform transform, VectorDouble fixedLandmarks, VectorDouble movingLandmarks, VectorDouble landmarkWeight, Image referenceImage, unsigned int numberOfControlPoints=4) -> Transform



    itk::simple::LandmarkBasedTransformInitializerFilter Procedural Interface


    This function directly calls the execute method of LandmarkBasedTransformInitializerFilter in order to support a procedural API


    See:
     itk::simple::LandmarkBasedTransformInitializerFilter for the object oriented interface



    """
    return _SimpleITK.LandmarkBasedTransformInitializer(*args, **kwargs)
class CastImageFilter(ImageFilter_1):
    """


    A hybrid cast image filter to convert images to other types of images.


    Several different ITK classes are implemented under the hood, to
    convert between different image types.


    See:
     itk::simple::Cast for the procedural interface


    C++ includes: sitkCastImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CastImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CastImageFilter, name)
    __repr__ = _swig_repr

    def SetOutputPixelType(self, pixelID):
        """
        SetOutputPixelType(CastImageFilter self, itk::simple::PixelIDValueEnum pixelID)



        Set/Get the output pixel type


        """
        return _SimpleITK.CastImageFilter_SetOutputPixelType(self, pixelID)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(CastImageFilter self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.CastImageFilter_GetOutputPixelType(self)


    def __init__(self):
        """
        __init__(itk::simple::CastImageFilter self) -> CastImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CastImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self):
        """
        GetName(CastImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CastImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CastImageFilter self) -> std::string



        """
        return _SimpleITK.CastImageFilter___str__(self)


    def Execute(self, arg2):
        """
        Execute(CastImageFilter self, Image arg2) -> Image



        """
        return _SimpleITK.CastImageFilter_Execute(self, arg2)

    __swig_destroy__ = _SimpleITK.delete_CastImageFilter
    __del__ = lambda self: None
CastImageFilter_swigregister = _SimpleITK.CastImageFilter_swigregister
CastImageFilter_swigregister(CastImageFilter)


def Cast(image, pixelID):
    """
    Cast(Image image, itk::simple::PixelIDValueEnum pixelID) -> Image



    """
    return _SimpleITK.Cast(image, pixelID)

def Resample(*args):
    """
    Resample(Image image1, Transform transform, itk::simple::InterpolatorEnum interpolator, double defaultPixelValue=0.0, itk::simple::PixelIDValueEnum outputPixelType) -> Image
    Resample(Image image1, Image referenceImage, Transform transform, itk::simple::InterpolatorEnum interpolator, double defaultPixelValue=0.0, itk::simple::PixelIDValueEnum outputPixelType) -> Image
    Resample(Image image1, VectorUInt32 size, Transform transform, itk::simple::InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double defaultPixelValue=0.0, itk::simple::PixelIDValueEnum outputPixelType) -> Image
    """
    return _SimpleITK.Resample(*args)

def PatchBasedDenoising(*args):
    """
    PatchBasedDenoising(Image image1, itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType noiseModel, double kernelBandwidthSigma=400.0, uint32_t patchRadius=4, uint32_t numberOfIterations=1, uint32_t numberOfSamplePatches=200, double sampleVariance=400.0, double noiseSigma=0.0, double noiseModelFidelityWeight=0.0) -> Image
    PatchBasedDenoising(Image image1, double kernelBandwidthSigma=400.0, uint32_t patchRadius=4, uint32_t numberOfIterations=1, uint32_t numberOfSamplePatches=200, double sampleVariance=400.0) -> Image



    """
    return _SimpleITK.PatchBasedDenoising(*args)
class ImageRegistrationMethod(ProcessObject):
    """


    An interface method to the modular ITKv4 registration framework.


    This interface method class encapsulates typical registration usage by
    incorporating all the necessary elements for performing a simple image
    registration between two images. This method also allows for
    multistage registration whereby each stage is characterized by
    possibly different transforms and different image metrics. For
    example, many users will want to perform a linear registration
    followed by deformable registration where both stages are performed in
    multiple levels. Each level can be characterized by:


    the resolution of the virtual domain image (see below)

    smoothing of the fixed and moving images
     Multiple stages are handled by linking multiple instantiations of
    this class where the output transform is added to the optional
    composite transform input.


    See:
     itk::ImageRegistrationMethodv4

     itk::ImageToImageMetricv4

     itk::ObjectToObjectOptimizerBaseTemplate


    C++ includes: sitkImageRegistrationMethod.h

    """

    __swig_setmethods__ = {}
    for _s in [ProcessObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRegistrationMethod, name, value)
    __swig_getmethods__ = {}
    for _s in [ProcessObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRegistrationMethod, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ImageRegistrationMethod self) -> ImageRegistrationMethod



        """
        this = _SimpleITK.new_ImageRegistrationMethod()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ImageRegistrationMethod
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ImageRegistrationMethod self) -> std::string



        return user readable name for the filter


        """
        return _SimpleITK.ImageRegistrationMethod_GetName(self)


    def __str__(self):
        """
        __str__(ImageRegistrationMethod self) -> std::string



        Print the information about the object to a string.


        If called when the process is being executed ( during a callback ),
        the ITK Optimizer and Transform objects will be printed.


        """
        return _SimpleITK.ImageRegistrationMethod___str__(self)


    def GetInterpolator(self):
        """GetInterpolator(ImageRegistrationMethod self) -> itk::simple::InterpolatorEnum"""
        return _SimpleITK.ImageRegistrationMethod_GetInterpolator(self)


    def SetInterpolator(self, Interpolator):
        """SetInterpolator(ImageRegistrationMethod self, itk::simple::InterpolatorEnum Interpolator)"""
        return _SimpleITK.ImageRegistrationMethod_SetInterpolator(self, Interpolator)


    def SetInitialTransform(self, transform, inPlace=True):
        """SetInitialTransform(ImageRegistrationMethod self, Transform transform, bool inPlace=True)"""
        return _SimpleITK.ImageRegistrationMethod_SetInitialTransform(self, transform, inPlace)


    def GetInitialTransform(self):
        """GetInitialTransform(ImageRegistrationMethod self) -> Transform"""
        return _SimpleITK.ImageRegistrationMethod_GetInitialTransform(self)


    def GetInitialTransformInPlace(self):
        """GetInitialTransformInPlace(ImageRegistrationMethod self) -> bool"""
        return _SimpleITK.ImageRegistrationMethod_GetInitialTransformInPlace(self)


    def SetMovingInitialTransform(self, transform):
        """SetMovingInitialTransform(ImageRegistrationMethod self, Transform transform)"""
        return _SimpleITK.ImageRegistrationMethod_SetMovingInitialTransform(self, transform)


    def GetMovingInitialTransform(self):
        """GetMovingInitialTransform(ImageRegistrationMethod self) -> Transform"""
        return _SimpleITK.ImageRegistrationMethod_GetMovingInitialTransform(self)


    def SetFixedInitialTransform(self, transform):
        """SetFixedInitialTransform(ImageRegistrationMethod self, Transform transform)"""
        return _SimpleITK.ImageRegistrationMethod_SetFixedInitialTransform(self, transform)


    def GetFixedInitialTransform(self):
        """GetFixedInitialTransform(ImageRegistrationMethod self) -> Transform"""
        return _SimpleITK.ImageRegistrationMethod_GetFixedInitialTransform(self)


    def SetVirtualDomain(self, virtualSize, virtualOrigin, virtualSpacing, virtualDirection):
        """SetVirtualDomain(ImageRegistrationMethod self, VectorUInt32 virtualSize, VectorDouble virtualOrigin, VectorDouble virtualSpacing, VectorDouble virtualDirection)"""
        return _SimpleITK.ImageRegistrationMethod_SetVirtualDomain(self, virtualSize, virtualOrigin, virtualSpacing, virtualDirection)


    def SetVirtualDomainFromImage(self, virtualImage):
        """SetVirtualDomainFromImage(ImageRegistrationMethod self, Image virtualImage)"""
        return _SimpleITK.ImageRegistrationMethod_SetVirtualDomainFromImage(self, virtualImage)


    def SetMetricAsANTSNeighborhoodCorrelation(self, radius):
        """
        SetMetricAsANTSNeighborhoodCorrelation(ImageRegistrationMethod self, unsigned int radius)



        Use normalized cross correlation using a small neighborhood for each
        voxel between two images, with speed optimizations for dense
        registration.



        See:
         itk::ANTSNeighborhoodCorrelationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsANTSNeighborhoodCorrelation(self, radius)


    def SetMetricAsCorrelation(self):
        """
        SetMetricAsCorrelation(ImageRegistrationMethod self)



        Use negative normalized cross correlation image metric.



        See:
         itk::CorrelationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsCorrelation(self)


    def SetMetricAsDemons(self, intensityDifferenceThreshold=0.001):
        """
        SetMetricAsDemons(ImageRegistrationMethod self, double intensityDifferenceThreshold=0.001)



        Use demons image metric.



        See:
         itk::DemonsImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsDemons(self, intensityDifferenceThreshold)


    def SetMetricAsJointHistogramMutualInformation(self, numberOfHistogramBins=20, varianceForJointPDFSmoothing=1.5):
        """
        SetMetricAsJointHistogramMutualInformation(ImageRegistrationMethod self, unsigned int numberOfHistogramBins=20, double varianceForJointPDFSmoothing=1.5)



        Use mutual information between two images.



        See:
         itk::JointHistogramMutualInformationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsJointHistogramMutualInformation(self, numberOfHistogramBins, varianceForJointPDFSmoothing)


    def SetMetricAsMeanSquares(self):
        """
        SetMetricAsMeanSquares(ImageRegistrationMethod self)



        Use negative means squares image metric.



        See:
         itk::MeanSquaresImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsMeanSquares(self)


    def SetMetricAsMattesMutualInformation(self, numberOfHistogramBins=50):
        """
        SetMetricAsMattesMutualInformation(ImageRegistrationMethod self, unsigned int numberOfHistogramBins=50)



        Use the mutual information between two images to be registered using
        the method of Mattes et al.



        See:
         itk::MattesMutualInformationImageToImageMetricv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricAsMattesMutualInformation(self, numberOfHistogramBins)

    Never = _SimpleITK.ImageRegistrationMethod_Never
    Once = _SimpleITK.ImageRegistrationMethod_Once
    EachIteration = _SimpleITK.ImageRegistrationMethod_EachIteration

    def SetOptimizerAsConjugateGradientLineSearch(self, *args, **kwargs):
        """
        SetOptimizerAsConjugateGradientLineSearch(ImageRegistrationMethod self, double learningRate, unsigned int numberOfIterations, double convergenceMinimumValue=1e-6, unsigned int convergenceWindowSize=10, double lineSearchLowerLimit=0, double lineSearchUpperLimit=5.0, double lineSearchEpsilon=0.01, unsigned int lineSearchMaximumIterations=20, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate, double maximumStepSizeInPhysicalUnits=0.0)



        Conjugate gradient descent optimizer with a golden section line search
        for nonlinear optimization.



        See:
         itk::ConjugateGradientLineSearchOptimizerv4Template



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsConjugateGradientLineSearch(self, *args, **kwargs)


    def SetOptimizerAsRegularStepGradientDescent(self, *args, **kwargs):
        """
        SetOptimizerAsRegularStepGradientDescent(ImageRegistrationMethod self, double learningRate, double minStep, unsigned int numberOfIterations, double relaxationFactor=0.5, double gradientMagnitudeTolerance=1e-4, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate, double maximumStepSizeInPhysicalUnits=0.0)



        Regular Step Gradient descent optimizer.



        See:
         itk::RegularStepGradientDescentOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsRegularStepGradientDescent(self, *args, **kwargs)


    def SetOptimizerAsGradientDescent(self, *args, **kwargs):
        """
        SetOptimizerAsGradientDescent(ImageRegistrationMethod self, double learningRate, unsigned int numberOfIterations, double convergenceMinimumValue=1e-6, unsigned int convergenceWindowSize=10, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate, double maximumStepSizeInPhysicalUnits=0.0)



        Gradient descent optimizer.



        See:
         itk::GradientDescentOptimizerv4Template



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsGradientDescent(self, *args, **kwargs)


    def SetOptimizerAsGradientDescentLineSearch(self, *args, **kwargs):
        """
        SetOptimizerAsGradientDescentLineSearch(ImageRegistrationMethod self, double learningRate, unsigned int numberOfIterations, double convergenceMinimumValue=1e-6, unsigned int convergenceWindowSize=10, double lineSearchLowerLimit=0, double lineSearchUpperLimit=5.0, double lineSearchEpsilon=0.01, unsigned int lineSearchMaximumIterations=20, itk::simple::ImageRegistrationMethod::EstimateLearningRateType estimateLearningRate, double maximumStepSizeInPhysicalUnits=0.0)



        Gradient descent optimizer with a golden section line search.



        See:
         itk::GradientDescentLineSearchOptimizerv4Template



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsGradientDescentLineSearch(self, *args, **kwargs)


    def SetOptimizerAsLBFGSB(self, *args, **kwargs):
        """
        SetOptimizerAsLBFGSB(ImageRegistrationMethod self, double gradientConvergenceTolerance=1e-5, unsigned int numberOfIterations=500, unsigned int maximumNumberOfCorrections=5, unsigned int maximumNumberOfFunctionEvaluations=2000, double costFunctionConvergenceFactor=1e+7, double lowerBound, double upperBound, bool trace=False)



        Limited memory Broyden Fletcher Goldfarb Shannon minimization with
        simple bounds.


        The default parameters utilize LBFGSB in unbounded mode.


        See:
         itk::LBFGSBOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsLBFGSB(self, *args, **kwargs)


    def SetOptimizerAsExhaustive(self, numberOfSteps, stepLength=1.0):
        """
        SetOptimizerAsExhaustive(ImageRegistrationMethod self, VectorUInt32 numberOfSteps, double stepLength=1.0)



        Set the optimizer to sample the metric at regular steps.


        At each iteration the GetOptimizerIteration, can be used to index into
        the sampling grid along with the GetCurrentMetricValue.

        The resulting transform and value at the end of execution is the best
        location.

        The OptimizerScales can be used to perform anisotropic sampling.


        This optimizer is not suitable for use in conjunction with the
        multiple scales.

        See:
         itk::ExhaustiveOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsExhaustive(self, numberOfSteps, stepLength)


    def SetOptimizerAsAmoeba(self, simplexDelta, numberOfIterations, parametersConvergenceTolerance=1e-8, functionConvergenceTolerance=1e-4, withRestarts=False):
        """
        SetOptimizerAsAmoeba(ImageRegistrationMethod self, double simplexDelta, unsigned int numberOfIterations, double parametersConvergenceTolerance=1e-8, double functionConvergenceTolerance=1e-4, bool withRestarts=False)



        Set optimizer to Nelder-Mead downhill simplex algorithm.



        See:
         itk::AmoebaOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsAmoeba(self, simplexDelta, numberOfIterations, parametersConvergenceTolerance, functionConvergenceTolerance, withRestarts)


    def SetOptimizerWeights(self, weights):
        """SetOptimizerWeights(ImageRegistrationMethod self, VectorDouble weights)"""
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerWeights(self, weights)


    def GetOptimizerWeights(self):
        """GetOptimizerWeights(ImageRegistrationMethod self) -> VectorDouble"""
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerWeights(self)


    def SetOptimizerAsPowell(self, numberOfIterations=100, maximumLineIterations=100, stepLength=1, stepTolerance=1e-6, valueTolerance=1e-6):
        """
        SetOptimizerAsPowell(ImageRegistrationMethod self, unsigned int numberOfIterations=100, unsigned int maximumLineIterations=100, double stepLength=1, double stepTolerance=1e-6, double valueTolerance=1e-6)



        Powell optimization using Brent line search.



        See:
         itk::PowellOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsPowell(self, numberOfIterations, maximumLineIterations, stepLength, stepTolerance, valueTolerance)


    def SetOptimizerAsOnePlusOneEvolutionary(self, *args, **kwargs):
        """
        SetOptimizerAsOnePlusOneEvolutionary(ImageRegistrationMethod self, unsigned int numberOfIterations=100, double epsilon=1.5e-4, double initialRadius=1.01, double growthFactor=-1.0, double shrinkFactor=-1.0, unsigned int seed)



        1+1 evolutionary optimizer strategy.


        The seed parameter is used to seed the pseudo-random number generator.
        If the seed parameter is 0, then the wall clock is used to seed,
        otherwise the fixed seed is used for reproducible behavior.


        See:
         itk::OnePlusOneEvolutionaryOptimizerv4



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerAsOnePlusOneEvolutionary(self, *args, **kwargs)


    def SetOptimizerScales(self, scales):
        """
        SetOptimizerScales(ImageRegistrationMethod self, VectorDouble scales)



        Manually set per parameter weighting for the transform parameters.


        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScales(self, scales)


    def SetOptimizerScalesFromJacobian(self, centralRegionRadius=5):
        """
        SetOptimizerScalesFromJacobian(ImageRegistrationMethod self, unsigned int centralRegionRadius=5)



        Estimate scales from Jacobian norms.


        This scales estimator works well with versor based transforms.


        See:
         itk::RegistrationParameterScalesFromJacobian



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScalesFromJacobian(self, centralRegionRadius)


    def SetOptimizerScalesFromIndexShift(self, centralRegionRadius=5, smallParameterVariation=0.01):
        """
        SetOptimizerScalesFromIndexShift(ImageRegistrationMethod self, unsigned int centralRegionRadius=5, double smallParameterVariation=0.01)



        Estimate scales from maximum voxel shift in index space cause by
        parameter change.



        See:
         itk::RegistrationParameterScalesFromIndexShift



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScalesFromIndexShift(self, centralRegionRadius, smallParameterVariation)


    def SetOptimizerScalesFromPhysicalShift(self, centralRegionRadius=5, smallParameterVariation=0.01):
        """
        SetOptimizerScalesFromPhysicalShift(ImageRegistrationMethod self, unsigned int centralRegionRadius=5, double smallParameterVariation=0.01)



        Estimating scales of transform parameters a step sizes, from the
        maximum voxel shift in physical space caused by a parameter change.



        See:
         itk::RegistrationParameterScalesFromPhysicalShift



        """
        return _SimpleITK.ImageRegistrationMethod_SetOptimizerScalesFromPhysicalShift(self, centralRegionRadius, smallParameterVariation)


    def SetMetricFixedMask(self, binaryMask):
        """
        SetMetricFixedMask(ImageRegistrationMethod self, Image binaryMask)



        Set an image mask in order to restrict the sampled points for the
        metric.


        The image is expected to be in the same physical space as the
        FixedImage, and if the pixel type is not UInt8 than the image will
        base cast.


        See:
         itk::ImageToImageMetricv4::SetFixedImageMask



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricFixedMask(self, binaryMask)


    def SetMetricMovingMask(self, binaryMask):
        """
        SetMetricMovingMask(ImageRegistrationMethod self, Image binaryMask)



        Set an image mask in order to restrict the sampled points for the
        metric in the moving image space.


        The image is expected to be in the same physical space as the
        MovingImage, and if the pixel type is not UInt8 than the image will
        base cast.


        See:
         itk::ImageToImageMetricv4::SetMovingImageMask



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricMovingMask(self, binaryMask)


    def SetMetricSamplingPercentage(self, *args, **kwargs):
        """SetMetricSamplingPercentage(ImageRegistrationMethod self, double percentage, unsigned int seed)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricSamplingPercentage(self, *args, **kwargs)


    def SetMetricSamplingPercentagePerLevel(self, *args, **kwargs):
        """SetMetricSamplingPercentagePerLevel(ImageRegistrationMethod self, VectorDouble percentage, unsigned int seed)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricSamplingPercentagePerLevel(self, *args, **kwargs)

    NONE = _SimpleITK.ImageRegistrationMethod_NONE
    REGULAR = _SimpleITK.ImageRegistrationMethod_REGULAR
    RANDOM = _SimpleITK.ImageRegistrationMethod_RANDOM

    def SetMetricSamplingStrategy(self, strategy):
        """
        SetMetricSamplingStrategy(ImageRegistrationMethod self, itk::simple::ImageRegistrationMethod::MetricSamplingStrategyType strategy)



        Set sampling strategy for sample generation.



        See:
         itk::ImageRegistrationMethodv4::SetMetricSamplingStrategy



        """
        return _SimpleITK.ImageRegistrationMethod_SetMetricSamplingStrategy(self, strategy)


    def SetMetricUseFixedImageGradientFilter(self, arg2):
        """SetMetricUseFixedImageGradientFilter(ImageRegistrationMethod self, bool arg2)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricUseFixedImageGradientFilter(self, arg2)


    def MetricUseFixedImageGradientFilterOn(self):
        """MetricUseFixedImageGradientFilterOn(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseFixedImageGradientFilterOn(self)


    def MetricUseFixedImageGradientFilterOff(self):
        """MetricUseFixedImageGradientFilterOff(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseFixedImageGradientFilterOff(self)


    def SetMetricUseMovingImageGradientFilter(self, arg2):
        """SetMetricUseMovingImageGradientFilter(ImageRegistrationMethod self, bool arg2)"""
        return _SimpleITK.ImageRegistrationMethod_SetMetricUseMovingImageGradientFilter(self, arg2)


    def MetricUseMovingImageGradientFilterOn(self):
        """MetricUseMovingImageGradientFilterOn(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseMovingImageGradientFilterOn(self)


    def MetricUseMovingImageGradientFilterOff(self):
        """MetricUseMovingImageGradientFilterOff(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_MetricUseMovingImageGradientFilterOff(self)


    def SetShrinkFactorsPerLevel(self, shrinkFactors):
        """
        SetShrinkFactorsPerLevel(ImageRegistrationMethod self, VectorUInt32 shrinkFactors)



        Set the shrink factors for each level where each level has the same
        shrink factor for each dimension.



        See:
         itk::ImageRegistrationMethodv4::SetShrinkFactorsPerLevel



        """
        return _SimpleITK.ImageRegistrationMethod_SetShrinkFactorsPerLevel(self, shrinkFactors)


    def SetSmoothingSigmasPerLevel(self, smoothingSigmas):
        """
        SetSmoothingSigmasPerLevel(ImageRegistrationMethod self, VectorDouble smoothingSigmas)



        Set the sigmas of Gaussian used for smoothing at each level.



        See:
         itk::ImageRegistrationMethodv4::SetSmoothingSigmasPerLevel



        """
        return _SimpleITK.ImageRegistrationMethod_SetSmoothingSigmasPerLevel(self, smoothingSigmas)


    def SetSmoothingSigmasAreSpecifiedInPhysicalUnits(self, arg):
        """SetSmoothingSigmasAreSpecifiedInPhysicalUnits(ImageRegistrationMethod self, bool arg)"""
        return _SimpleITK.ImageRegistrationMethod_SetSmoothingSigmasAreSpecifiedInPhysicalUnits(self, arg)


    def SmoothingSigmasAreSpecifiedInPhysicalUnitsOn(self):
        """SmoothingSigmasAreSpecifiedInPhysicalUnitsOn(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_SmoothingSigmasAreSpecifiedInPhysicalUnitsOn(self)


    def SmoothingSigmasAreSpecifiedInPhysicalUnitsOff(self):
        """SmoothingSigmasAreSpecifiedInPhysicalUnitsOff(ImageRegistrationMethod self)"""
        return _SimpleITK.ImageRegistrationMethod_SmoothingSigmasAreSpecifiedInPhysicalUnitsOff(self)


    def Execute(self, fixed, moving):
        """
        Execute(ImageRegistrationMethod self, Image fixed, Image moving) -> Transform



        Optimize the configured registration problem.


        """
        return _SimpleITK.ImageRegistrationMethod_Execute(self, fixed, moving)


    def MetricEvaluate(self, fixed, moving):
        """
        MetricEvaluate(ImageRegistrationMethod self, Image fixed, Image moving) -> double



        Get the value of the metric given the state of the method.


        Passing a fixed and moving image, this method constructs and
        configures a metric object to obtain the value. This will take into
        consideration the current transforms, metric, interpolator, and image
        masks. It does not take into consideration the sampling strategy,
        smoothing sigmas, or the shrink factors.


        """
        return _SimpleITK.ImageRegistrationMethod_MetricEvaluate(self, fixed, moving)


    def GetOptimizerIteration(self):
        """
        GetOptimizerIteration(ImageRegistrationMethod self) -> unsigned int



        Active measurements which can be obtained during call backs.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerIteration(self)


    def GetOptimizerPosition(self):
        """
        GetOptimizerPosition(ImageRegistrationMethod self) -> VectorDouble



        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerPosition(self)


    def GetOptimizerLearningRate(self):
        """
        GetOptimizerLearningRate(ImageRegistrationMethod self) -> double



        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerLearningRate(self)


    def GetOptimizerConvergenceValue(self):
        """
        GetOptimizerConvergenceValue(ImageRegistrationMethod self) -> double



        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerConvergenceValue(self)


    def GetMetricValue(self):
        """
        GetMetricValue(ImageRegistrationMethod self) -> double



        """
        return _SimpleITK.ImageRegistrationMethod_GetMetricValue(self)


    def GetCurrentLevel(self):
        """
        GetCurrentLevel(ImageRegistrationMethod self) -> unsigned int



        """
        return _SimpleITK.ImageRegistrationMethod_GetCurrentLevel(self)


    def GetOptimizerScales(self):
        """
        GetOptimizerScales(ImageRegistrationMethod self) -> VectorDouble



        Get the OptimizerScales.


        If the scales are explicitly set then this method returns those
        values. If an estimator is used then this is an active measurement
        returning the scales estimated by the estimator and is only available
        during execution.


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerScales(self)


    def GetOptimizerStopConditionDescription(self):
        """
        GetOptimizerStopConditionDescription(ImageRegistrationMethod self) -> std::string



        Measurement updated at the end of execution.


        """
        return _SimpleITK.ImageRegistrationMethod_GetOptimizerStopConditionDescription(self)

ImageRegistrationMethod_swigregister = _SimpleITK.ImageRegistrationMethod_swigregister
ImageRegistrationMethod_swigregister(ImageRegistrationMethod)

class AbsImageFilter(ImageFilter_1):
    """


    Computes the absolute value of each pixel.


    itk::Math::abs() is used to perform the computation.

    Wiki Examples:

    All Examples

    Compute the absolute value of an image
    See:
     itk::simple::Abs for the procedural interface

     itk::AbsImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAbsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AbsImageFilter self) -> AbsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AbsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AbsImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AbsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AbsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AbsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AbsImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(AbsImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.AbsImageFilter_Execute(self, image1)

AbsImageFilter_swigregister = _SimpleITK.AbsImageFilter_swigregister
AbsImageFilter_swigregister(AbsImageFilter)


def Abs(image1):
    """
    Abs(Image image1) -> Image



    Computes the absolute value of each pixel.


    This function directly calls the execute method of AbsImageFilter in order to support a procedural API


    See:
     itk::simple::AbsImageFilter for the object oriented interface



    """
    return _SimpleITK.Abs(image1)
class AbsoluteValueDifferenceImageFilter(ImageFilter_2):
    """


    Implements pixel-wise the computation of absolute value difference.


    This filter is parametrized over the types of the two input images and
    the type of the output image.

    Numeric conversions (castings) are done by the C++ defaults.

    The filter will walk over all the pixels in the two input images, and
    for each one of them it will do the following:


    Cast the input 1 pixel value to double .

    Cast the input 2 pixel value to double .

    Compute the difference of the two pixel values.

    Compute the absolute value of the difference.

    Cast the double value resulting from the absolute value to the pixel
    type of the output image.

    Store the casted value into the output image.
     The filter expects all images to have the same dimension (e.g. all
    2D, or all 3D, or all ND).

    Wiki Examples:

    All Examples

    Compute the absolute value of the difference of corresponding pixels
    in two images
    See:
     itk::simple::AbsoluteValueDifference for the procedural interface

     itk::AbsoluteValueDifferenceImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAbsoluteValueDifferenceImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbsoluteValueDifferenceImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbsoluteValueDifferenceImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AbsoluteValueDifferenceImageFilter self) -> AbsoluteValueDifferenceImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AbsoluteValueDifferenceImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AbsoluteValueDifferenceImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AbsoluteValueDifferenceImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AbsoluteValueDifferenceImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AbsoluteValueDifferenceImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AbsoluteValueDifferenceImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(AbsoluteValueDifferenceImageFilter self, Image image1, Image image2) -> Image
        Execute(AbsoluteValueDifferenceImageFilter self, Image image1, double constant) -> Image
        Execute(AbsoluteValueDifferenceImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.AbsoluteValueDifferenceImageFilter_Execute(self, *args)

AbsoluteValueDifferenceImageFilter_swigregister = _SimpleITK.AbsoluteValueDifferenceImageFilter_swigregister
AbsoluteValueDifferenceImageFilter_swigregister(AbsoluteValueDifferenceImageFilter)


def AbsoluteValueDifference(*args):
    """
    AbsoluteValueDifference(Image image1, Image image2) -> Image
    AbsoluteValueDifference(Image image1, double constant) -> Image
    AbsoluteValueDifference(double constant, Image image2) -> Image



    """
    return _SimpleITK.AbsoluteValueDifference(*args)
class AcosImageFilter(ImageFilter_1):
    """


    Computes the inverse cosine of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all the pixels in the input image, and for each
    pixel does do the following:


    cast the pixel value to double ,

    apply the std::acos() function to the double value

    cast the double value resulting from std::acos() to the pixel type of
    the output image

    store the casted value into the output image.
     The filter expects both images to have the same dimension (e.g. both
    2D, or both 3D, or both ND).
    See:
     itk::simple::Acos for the procedural interface

     itk::AcosImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAcosImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AcosImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AcosImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AcosImageFilter self) -> AcosImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AcosImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AcosImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AcosImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AcosImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AcosImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AcosImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(AcosImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.AcosImageFilter_Execute(self, image1)

AcosImageFilter_swigregister = _SimpleITK.AcosImageFilter_swigregister
AcosImageFilter_swigregister(AcosImageFilter)


def Acos(image1):
    """
    Acos(Image image1) -> Image



    Computes the inverse cosine of each pixel.


    This function directly calls the execute method of AcosImageFilter in order to support a procedural API


    See:
     itk::simple::AcosImageFilter for the object oriented interface



    """
    return _SimpleITK.Acos(image1)
class AdaptiveHistogramEqualizationImageFilter(ImageFilter_1):
    """


    Power Law Adaptive Histogram Equalization.


    Histogram equalization modifies the contrast in an image. The AdaptiveHistogramEqualizationImageFilter is a superset of many contrast enhancing filters. By modifying its
    parameters (alpha, beta, and window), the AdaptiveHistogramEqualizationImageFilter can produce an adaptively equalized histogram or a version of unsharp
    mask (local mean subtraction). Instead of applying a strict histogram
    equalization in a window about a pixel, this filter prescribes a
    mapping function (power law) controlled by the parameters alpha and
    beta.

    The parameter alpha controls how much the filter acts like the
    classical histogram equalization method (alpha=0) to how much the
    filter acts like an unsharp mask (alpha=1).

    The parameter beta controls how much the filter acts like an unsharp
    mask (beta=0) to much the filter acts like pass through (beta=1, with
    alpha=1).

    The parameter window controls the size of the region over which local
    statistics are calculated.

    By altering alpha, beta and window, a host of equalization and unsharp
    masking filters is available.

    The boundary condition ignores the part of the neighborhood outside
    the image, and over-weights the valid part of the neighborhood.

    For detail description, reference "Adaptive Image Contrast
    Enhancement using Generalizations of Histogram Equalization." J.Alex
    Stark. IEEE Transactions on Image Processing, May 2000.

    Wiki Examples:

    All Examples

    Adaptive histogram equalization
    See:
     itk::simple::AdaptiveHistogramEqualization for the procedural interface

     itk::AdaptiveHistogramEqualizationImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAdaptiveHistogramEqualizationImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AdaptiveHistogramEqualizationImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AdaptiveHistogramEqualizationImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AdaptiveHistogramEqualizationImageFilter self) -> AdaptiveHistogramEqualizationImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AdaptiveHistogramEqualizationImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AdaptiveHistogramEqualizationImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(AdaptiveHistogramEqualizationImageFilter self, VectorUInt32 Radius)
        SetRadius(AdaptiveHistogramEqualizationImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(AdaptiveHistogramEqualizationImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetRadius(self)


    def SetAlpha(self, Alpha):
        """
        SetAlpha(AdaptiveHistogramEqualizationImageFilter self, float Alpha)



        Set/Get the value of alpha. Alpha=0 produces the adaptive histogram
        equalization (provided beta=0). Alpha=1 produces an unsharp mask.
        Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetAlpha(self, Alpha)


    def GetAlpha(self):
        """
        GetAlpha(AdaptiveHistogramEqualizationImageFilter self) -> float



        Set/Get the value of alpha. Alpha=0 produces the adaptive histogram
        equalization (provided beta=0). Alpha=1 produces an unsharp mask.
        Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetAlpha(self)


    def SetBeta(self, Beta):
        """
        SetBeta(AdaptiveHistogramEqualizationImageFilter self, float Beta)



        Set/Get the value of beta. If beta=1 (and alpha=1), then the output
        image matches the input image. As beta approaches 0, the filter
        behaves as an unsharp mask. Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetBeta(self, Beta)


    def GetBeta(self):
        """
        GetBeta(AdaptiveHistogramEqualizationImageFilter self) -> float



        Set/Get the value of beta. If beta=1 (and alpha=1), then the output
        image matches the input image. As beta approaches 0, the filter
        behaves as an unsharp mask. Default is 0.3.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetBeta(self)


    def SetUseLookupTable(self, UseLookupTable):
        """
        SetUseLookupTable(AdaptiveHistogramEqualizationImageFilter self, bool UseLookupTable)



        Set/Get whether an optimized lookup table for the intensity mapping
        function is used. Default is off. Deprecated


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_SetUseLookupTable(self, UseLookupTable)


    def UseLookupTableOn(self):
        """
        UseLookupTableOn(AdaptiveHistogramEqualizationImageFilter self)



        Set the value of UseLookupTable to true or false respectfully.


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_UseLookupTableOn(self)


    def UseLookupTableOff(self):
        """
        UseLookupTableOff(AdaptiveHistogramEqualizationImageFilter self)



        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_UseLookupTableOff(self)


    def GetUseLookupTable(self):
        """
        GetUseLookupTable(AdaptiveHistogramEqualizationImageFilter self) -> bool



        Set/Get whether an optimized lookup table for the intensity mapping
        function is used. Default is off. Deprecated


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetUseLookupTable(self)


    def GetName(self):
        """
        GetName(AdaptiveHistogramEqualizationImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AdaptiveHistogramEqualizationImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(AdaptiveHistogramEqualizationImageFilter self, Image image1) -> Image
        Execute(AdaptiveHistogramEqualizationImageFilter self, Image image1, VectorUInt32 radius, float alpha, float beta, bool useLookupTable) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.AdaptiveHistogramEqualizationImageFilter_Execute(self, *args)

AdaptiveHistogramEqualizationImageFilter_swigregister = _SimpleITK.AdaptiveHistogramEqualizationImageFilter_swigregister
AdaptiveHistogramEqualizationImageFilter_swigregister(AdaptiveHistogramEqualizationImageFilter)


def AdaptiveHistogramEqualization(*args, **kwargs):
    """
    AdaptiveHistogramEqualization(Image image1, VectorUInt32 radius, float alpha=0.3, float beta=0.3, bool useLookupTable=False) -> Image



    Power Law Adaptive Histogram Equalization.


    This function directly calls the execute method of AdaptiveHistogramEqualizationImageFilter in order to support a procedural API


    See:
     itk::simple::AdaptiveHistogramEqualizationImageFilter for the object oriented interface



    """
    return _SimpleITK.AdaptiveHistogramEqualization(*args, **kwargs)
class AddImageFilter(ImageFilter_2):
    """


    Pixel-wise addition of two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The pixel type of the input 1 image must have a valid definition of
    the operator+ with a pixel type of the image 2. This condition is
    required because internally this filter will perform the operation


    Additionally the type resulting from the sum, will be cast to the
    pixel type of the output image.

    The total operation over one pixel will be

    For example, this filter could be used directly for adding images
    whose pixels are vectors of the same dimension, and to store the
    resulting vector in an output image of vector pixels.

    The images to be added are set using the methods:

    Additionally, this filter can be used to add a constant to every pixel
    of an image by using


    WARNING:
    No numeric overflow checking is performed in this filter.
    Wiki Examples:

    All Examples

    Add two images together

    Add a constant to every pixel in an image
    See:
     itk::simple::Add for the procedural interface

     itk::AddImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAddImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AddImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AddImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AddImageFilter self) -> AddImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AddImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AddImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AddImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AddImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AddImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AddImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(AddImageFilter self, Image image1, Image image2) -> Image
        Execute(AddImageFilter self, Image image1, double constant) -> Image
        Execute(AddImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.AddImageFilter_Execute(self, *args)

AddImageFilter_swigregister = _SimpleITK.AddImageFilter_swigregister
AddImageFilter_swigregister(AddImageFilter)


def Add(*args):
    """
    Add(Image image1, Image image2) -> Image
    Add(Image image1, double constant) -> Image
    Add(double constant, Image image2) -> Image



    """
    return _SimpleITK.Add(*args)
class AdditiveGaussianNoiseImageFilter(ImageFilter_1):
    """


    Alter an image with additive Gaussian white noise.


    Additive Gaussian white noise can be modeled as:


    $ I = I_0 + N $

    where $ I $ is the observed image, $ I_0 $ is the noise-free image and $ N $ is a normally distributed random variable of mean $ \\mu $ and variance $ \\sigma^2 $ :

    $ N \\sim \\mathcal{N}(\\mu, \\sigma^2) $
     The noise is independent of the pixel intensities.


    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://hdl.handle.net/10380/3158
    See:
     itk::simple::AdditiveGaussianNoise for the procedural interface

     itk::AdditiveGaussianNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAdditiveGaussianNoiseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AdditiveGaussianNoiseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AdditiveGaussianNoiseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AdditiveGaussianNoiseImageFilter self) -> AdditiveGaussianNoiseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AdditiveGaussianNoiseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AdditiveGaussianNoiseImageFilter
    __del__ = lambda self: None

    def SetStandardDeviation(self, StandardDeviation):
        """
        SetStandardDeviation(AdditiveGaussianNoiseImageFilter self, double StandardDeviation)



        Set/Get the standard deviation of the Gaussian distribution. Defaults
        to 1.0.


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_SetStandardDeviation(self, StandardDeviation)


    def GetStandardDeviation(self):
        """
        GetStandardDeviation(AdditiveGaussianNoiseImageFilter self) -> double



        Set/Get the standard deviation of the Gaussian distribution. Defaults
        to 1.0.


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetStandardDeviation(self)


    def SetMean(self, Mean):
        """
        SetMean(AdditiveGaussianNoiseImageFilter self, double Mean)



        Set/Get the mean of the Gaussian distribution. Defaults to 0.0.


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_SetMean(self, Mean)


    def GetMean(self):
        """
        GetMean(AdditiveGaussianNoiseImageFilter self) -> double



        Set/Get the mean of the Gaussian distribution. Defaults to 0.0.


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetMean(self)


    def SetSeed(self, Seed):
        """
        SetSeed(AdditiveGaussianNoiseImageFilter self, uint32_t Seed)



        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_SetSeed(self, Seed)


    def GetSeed(self):
        """
        GetSeed(AdditiveGaussianNoiseImageFilter self) -> uint32_t



        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetSeed(self)


    def GetName(self):
        """
        GetName(AdditiveGaussianNoiseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AdditiveGaussianNoiseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(AdditiveGaussianNoiseImageFilter self, Image image1) -> Image
        Execute(AdditiveGaussianNoiseImageFilter self, Image image1, double standardDeviation, double mean, uint32_t seed) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.AdditiveGaussianNoiseImageFilter_Execute(self, *args)

AdditiveGaussianNoiseImageFilter_swigregister = _SimpleITK.AdditiveGaussianNoiseImageFilter_swigregister
AdditiveGaussianNoiseImageFilter_swigregister(AdditiveGaussianNoiseImageFilter)


def AdditiveGaussianNoise(*args, **kwargs):
    """
    AdditiveGaussianNoise(Image image1, double standardDeviation=1.0, double mean=0.0, uint32_t seed) -> Image



    Alter an image with additive Gaussian white noise.


    This function directly calls the execute method of AdditiveGaussianNoiseImageFilter in order to support a procedural API


    See:
     itk::simple::AdditiveGaussianNoiseImageFilter for the object oriented interface



    """
    return _SimpleITK.AdditiveGaussianNoise(*args, **kwargs)
class AggregateLabelMapFilter(ImageFilter_1):
    """


    Collapses all labels into the first label.


    This filter takes a label map as input and visits the pixels of all
    labels and assigns them to the first label of the label map. At the
    end of the execution of this filter, the map will contain a single
    filter.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::AggregateLabelMapFilter for the procedural interface

     itk::AggregateLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAggregateLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AggregateLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AggregateLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AggregateLabelMapFilter self) -> AggregateLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AggregateLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AggregateLabelMapFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AggregateLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AggregateLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(AggregateLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AggregateLabelMapFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(AggregateLabelMapFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.AggregateLabelMapFilter_Execute(self, image1)

AggregateLabelMapFilter_swigregister = _SimpleITK.AggregateLabelMapFilter_swigregister
AggregateLabelMapFilter_swigregister(AggregateLabelMapFilter)


def AggregateLabelMap(image1):
    """
    AggregateLabelMap(Image image1) -> Image



    Collapses all labels into the first label.


    This function directly calls the execute method of AggregateLabelMapFilter in order to support a procedural API


    See:
     itk::simple::AggregateLabelMapFilter for the object oriented interface



    """
    return _SimpleITK.AggregateLabelMap(image1)
class AndImageFilter(ImageFilter_2):
    """


    Implements the AND bitwise operator pixel-wise between two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Since the bitwise AND operation is only defined in C++ for integer
    types, the images passed to this filter must comply with the
    requirement of using integer pixel type.

    The total operation over one pixel will be Where "&" is the bitwise AND operator in C++.

    Wiki Examples:

    All Examples

    Binary AND two images
    See:
     itk::simple::And for the procedural interface

     itk::AndImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAndImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AndImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AndImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AndImageFilter self) -> AndImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AndImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AndImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AndImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AndImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AndImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AndImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(AndImageFilter self, Image image1, Image image2) -> Image
        Execute(AndImageFilter self, Image image1, int constant) -> Image
        Execute(AndImageFilter self, int constant, Image image2) -> Image



        """
        return _SimpleITK.AndImageFilter_Execute(self, *args)

AndImageFilter_swigregister = _SimpleITK.AndImageFilter_swigregister
AndImageFilter_swigregister(AndImageFilter)


def And(*args):
    """
    And(Image image1, Image image2) -> Image
    And(Image image1, int constant) -> Image
    And(int constant, Image image2) -> Image



    """
    return _SimpleITK.And(*args)
class AntiAliasBinaryImageFilter(ImageFilter_1):
    """


    A method for estimation of a surface from a binary volume.



    This filter implements a surface-fitting method for estimation of a
    surface from a binary volume. This process can be used to reduce
    aliasing artifacts which result in visualization of binary partitioned
    surfaces.

    The binary volume (filter input) is used as a set of constraints in an
    iterative relaxation process of an estimated ND surface. The surface
    is described implicitly as the zero level set of a volume $ \\phi $ and allowed to deform under curvature flow. A set of contraints is
    imposed on this movement as follows:

    \\[ u_{i,j,k}^{n+1} = \\left\\{ \\begin{array}{ll}
    \\mbox{max} (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{\\f$B_{i,j,k} = 1\\f$} \\\\ \\mbox{min}
    (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{\\f$B_{i,j,k} = -1\\f$} \\end{array}\\right. \\]

    where $ u_{i,j,k}^{n} $ is the value of $ \\phi $ at discrete index $ (i,j,k) $ and iteration $ n $ , $ H $ is the gradient magnitude times mean curvature of $ \\phi $ , and $ B $ is the binary input volume, with 1 denoting an inside pixel and -1
    denoting an outside pixel.
    NOTES
    This implementation uses a sparse field level set solver instead of
    the narrow band implementation described in the reference below, which
    may introduce some differences in how fast and how accurately (in
    terms of RMS error) the solution converges.
    REFERENCES
    Whitaker, Ross. "Reducing Aliasing Artifacts In Iso-Surfaces of
    Binary Volumes" IEEE Volume Visualization and Graphics Symposium,
    October 2000, pp.23-32.
    PARAMETERS
    The MaximumRMSChange parameter is used to determine when the solution
    has converged. A lower value will result in a tighter-fitting
    solution, but will require more computations. Too low a value could
    put the solver into an infinite loop. Values should always be less
    than 1.0. A value of 0.07 is a good starting estimate.

    The MaximumIterations parameter can be used to halt the solution after
    a specified number of iterations.
    INPUT
    The input is an N-dimensional image of any type. It is assumed to be a
    binary image. The filter will use an isosurface value that is halfway
    between the min and max values in the image. A signed data type is not
    necessary for the input.
    OUTPUT
    The filter will output a level set image of real, signed values. The
    zero crossings of this (N-dimensional) image represent the position of
    the isosurface value of interest. Values outside the zero level set
    are negative and values inside the zero level set are positive values.
    IMPORTANT!
    The output image type you use to instantiate this filter should be a
    real valued scalar type. In other words: doubles or floats.
    USING THIS FILTER
    The filter is relatively straightforward to use. Tests and examples
    exist to illustrate. The important thing is to understand the input
    and output types so you can properly interperet your results.

    In the common case, the only parameter that will need to be set is the
    MaximumRMSChange parameter, which determines when the solver halts.
    Wiki Examples:

    All Examples

    Anti alias a binary image
    See:
     itk::simple::AntiAliasBinary for the procedural interface

     itk::AntiAliasBinaryImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAntiAliasBinaryImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AntiAliasBinaryImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AntiAliasBinaryImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AntiAliasBinaryImageFilter self) -> AntiAliasBinaryImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AntiAliasBinaryImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AntiAliasBinaryImageFilter
    __del__ = lambda self: None

    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(AntiAliasBinaryImageFilter self, double MaximumRMSError)



        """
        return _SimpleITK.AntiAliasBinaryImageFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(AntiAliasBinaryImageFilter self) -> double



        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetMaximumRMSError(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(AntiAliasBinaryImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.AntiAliasBinaryImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(AntiAliasBinaryImageFilter self) -> uint32_t



        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetNumberOfIterations(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(AntiAliasBinaryImageFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(AntiAliasBinaryImageFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetRMSChange(self)


    def GetName(self):
        """
        GetName(AntiAliasBinaryImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AntiAliasBinaryImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AntiAliasBinaryImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(AntiAliasBinaryImageFilter self, Image image1) -> Image
        Execute(AntiAliasBinaryImageFilter self, Image image1, double maximumRMSError, uint32_t numberOfIterations) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.AntiAliasBinaryImageFilter_Execute(self, *args)

AntiAliasBinaryImageFilter_swigregister = _SimpleITK.AntiAliasBinaryImageFilter_swigregister
AntiAliasBinaryImageFilter_swigregister(AntiAliasBinaryImageFilter)


def AntiAliasBinary(image1, maximumRMSError=0.07, numberOfIterations=1000):
    """
    AntiAliasBinary(Image image1, double maximumRMSError=0.07, uint32_t numberOfIterations=1000) -> Image



    A method for estimation of a surface from a binary volume.


    This function directly calls the execute method of AntiAliasBinaryImageFilter in order to support a procedural API


    See:
     itk::simple::AntiAliasBinaryImageFilter for the object oriented interface



    """
    return _SimpleITK.AntiAliasBinary(image1, maximumRMSError, numberOfIterations)
class ApproximateSignedDistanceMapImageFilter(ImageFilter_1):
    """


    Create a map of the approximate signed distance from the boundaries of
    a binary image.


    The ApproximateSignedDistanceMapImageFilter takes as input a binary image and produces a signed distance map.
    Each pixel value in the output contains the approximate distance from
    that pixel to the nearest "object" in the binary image. This filter
    differs from the DanielssonDistanceMapImageFilter in that it calculates the distance to the "object edge" for pixels
    within the object.

    Negative values in the output indicate that the pixel at that position
    is within an object in the input image. The absolute value of a
    negative pixel represents the approximate distance to the nearest
    object boundary pixel.

    WARNING: This filter requires that the output type be floating-point.
    Otherwise internal calculations will not be performed to the
    appropriate precision, resulting in completely incorrect (read: zero-
    valued) output.

    The distances computed by this filter are Chamfer distances, which are
    only an approximation to Euclidian distances, and are not as exact
    approximations as those calculated by the DanielssonDistanceMapImageFilter . On the other hand, this filter is faster.

    This filter requires that an "inside value" and "outside value" be
    set as parameters. The "inside value" is the intensity value of the
    binary image which corresponds to objects, and the "outside value"
    is the intensity of the background. (A typical binary image often
    repesents objects as black (0) and background as white (usually 255),
    or vice-versa.) Note that this filter is slightly faster if the inside
    value is less than the outside value. Otherwise an extra iteration
    through the image is required.

    This filter uses the FastChamferDistanceImageFilter and the IsoContourDistanceImageFilter inernally to perform the distance calculations.


    See:
     DanielssonDistanceMapImageFilter

     SignedDanielssonDistanceMapImageFilter

     SignedMaurerDistanceMapImageFilter

     FastChamferDistanceImageFilter

     IsoContourDistanceImageFilter

    Zach Pincus
    Wiki Examples:

    All Examples

    Compute a distance map from objects in a binary image
    See:
     itk::simple::ApproximateSignedDistanceMap for the procedural interface

     itk::ApproximateSignedDistanceMapImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkApproximateSignedDistanceMapImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApproximateSignedDistanceMapImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ApproximateSignedDistanceMapImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ApproximateSignedDistanceMapImageFilter self) -> ApproximateSignedDistanceMapImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ApproximateSignedDistanceMapImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ApproximateSignedDistanceMapImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(ApproximateSignedDistanceMapImageFilter self, double InsideValue)



        Set/Get intensity value representing the interior of objects in the
        mask


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(ApproximateSignedDistanceMapImageFilter self) -> double



        Set/Get intensity value representing the interior of objects in the
        mask


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(ApproximateSignedDistanceMapImageFilter self, double OutsideValue)



        Set/Get intensity value representing non-objects in the mask


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(ApproximateSignedDistanceMapImageFilter self) -> double



        Set/Get intensity value representing non-objects in the mask


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_GetOutsideValue(self)


    def GetName(self):
        """
        GetName(ApproximateSignedDistanceMapImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ApproximateSignedDistanceMapImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ApproximateSignedDistanceMapImageFilter self, Image image1) -> Image
        Execute(ApproximateSignedDistanceMapImageFilter self, Image image1, double insideValue, double outsideValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ApproximateSignedDistanceMapImageFilter_Execute(self, *args)

ApproximateSignedDistanceMapImageFilter_swigregister = _SimpleITK.ApproximateSignedDistanceMapImageFilter_swigregister
ApproximateSignedDistanceMapImageFilter_swigregister(ApproximateSignedDistanceMapImageFilter)


def ApproximateSignedDistanceMap(image1, insideValue=1, outsideValue=0):
    """
    ApproximateSignedDistanceMap(Image image1, double insideValue=1, double outsideValue=0) -> Image



    Create a map of the approximate signed distance from the boundaries of
    a binary image.


    This function directly calls the execute method of ApproximateSignedDistanceMapImageFilter in order to support a procedural API


    See:
     itk::simple::ApproximateSignedDistanceMapImageFilter for the object oriented interface



    """
    return _SimpleITK.ApproximateSignedDistanceMap(image1, insideValue, outsideValue)
class AsinImageFilter(ImageFilter_1):
    """


    Computes the sine of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all the pixels in the input image, and for each
    pixel does the following:


    cast the pixel value to double ,

    apply the std::asin() function to the double value,

    cast the double value resulting from std::asin() to the pixel type of
    the output image,

    store the casted value into the output image.
     The filter expects both images to have the same dimension (e.g. both
    2D, or both 3D, or both ND)
    See:
     itk::simple::Asin for the procedural interface

     itk::AsinImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkAsinImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AsinImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AsinImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AsinImageFilter self) -> AsinImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AsinImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AsinImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AsinImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AsinImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AsinImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AsinImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(AsinImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.AsinImageFilter_Execute(self, image1)

AsinImageFilter_swigregister = _SimpleITK.AsinImageFilter_swigregister
AsinImageFilter_swigregister(AsinImageFilter)


def Asin(image1):
    """
    Asin(Image image1) -> Image



    Computes the sine of each pixel.


    This function directly calls the execute method of AsinImageFilter in order to support a procedural API


    See:
     itk::simple::AsinImageFilter for the object oriented interface



    """
    return _SimpleITK.Asin(image1)
class Atan2ImageFilter(ImageFilter_2):
    """


    Computes two argument inverse tangent.


    The first argument to the atan function is provided by a pixel in the
    first input image (SetInput1() ) and the corresponding pixel in the
    second input image (SetInput2() ) is used as the second argument.

    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Both pixel input types are cast to double in order to be used as
    parameters of std::atan2() . The resulting double value is cast to the
    output pixel type.

    Wiki Examples:

    All Examples

    Compute the arctangent of each pixel.
    See:
     itk::simple::Atan2 for the procedural interface

     itk::Atan2ImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAtan2ImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Atan2ImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Atan2ImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::Atan2ImageFilter self) -> Atan2ImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_Atan2ImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_Atan2ImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(Atan2ImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.Atan2ImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(Atan2ImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.Atan2ImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(Atan2ImageFilter self, Image image1, Image image2) -> Image
        Execute(Atan2ImageFilter self, Image image1, double constant) -> Image
        Execute(Atan2ImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.Atan2ImageFilter_Execute(self, *args)

Atan2ImageFilter_swigregister = _SimpleITK.Atan2ImageFilter_swigregister
Atan2ImageFilter_swigregister(Atan2ImageFilter)


def Atan2(*args):
    """
    Atan2(Image image1, Image image2) -> Image
    Atan2(Image image1, double constant) -> Image
    Atan2(double constant, Image image2) -> Image



    """
    return _SimpleITK.Atan2(*args)
class AtanImageFilter(ImageFilter_1):
    """


    Computes the one-argument inverse tangent of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all the pixels in the input image, and for each
    pixel does the following:


    cast the pixel value to double ,

    apply the std::atan() function to the double value,

    cast the double value resulting from std::atan() to the pixel type of
    the output image,

    store the cast value into the output image.
    See:
     itk::simple::Atan for the procedural interface

     itk::AtanImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkAtanImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtanImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AtanImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::AtanImageFilter self) -> AtanImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_AtanImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_AtanImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(AtanImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.AtanImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(AtanImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.AtanImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(AtanImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.AtanImageFilter_Execute(self, image1)

AtanImageFilter_swigregister = _SimpleITK.AtanImageFilter_swigregister
AtanImageFilter_swigregister(AtanImageFilter)


def Atan(image1):
    """
    Atan(Image image1) -> Image



    Computes the one-argument inverse tangent of each pixel.


    This function directly calls the execute method of AtanImageFilter in order to support a procedural API


    See:
     itk::simple::AtanImageFilter for the object oriented interface



    """
    return _SimpleITK.Atan(image1)
class BilateralImageFilter(ImageFilter_1):
    """


    Blurs an image while preserving edges.


    This filter uses bilateral filtering to blur an image using both
    domain and range "neighborhoods". Pixels that are close to a pixel
    in the image domain and similar to a pixel in the image range are used
    to calculate the filtered value. Two gaussian kernels (one in the
    image domain and one in the image range) are used to smooth the image.
    The result is an image that is smoothed in homogeneous regions yet has
    edges preserved. The result is similar to anisotropic diffusion but
    the implementation in non-iterative. Another benefit to bilateral
    filtering is that any distance metric can be used for kernel smoothing
    the image range. Hence, color images can be smoothed as vector images,
    using the CIE distances between intensity values as the similarity
    metric (the Gaussian kernel for the image domain is evaluated using
    CIE distances). A separate version of this filter will be designed for
    color and vector images.

    Bilateral filtering is capable of reducing the noise in an image by an
    order of magnitude while maintaining edges.

    The bilateral operator used here was described by Tomasi and Manduchi
    (Bilateral Filtering for Gray and ColorImages. IEEE ICCV. 1998.)


    See:
     GaussianOperator

     RecursiveGaussianImageFilter

     DiscreteGaussianImageFilter

     AnisotropicDiffusionImageFilter

     Image

     Neighborhood

     NeighborhoodOperator
     TodoSupport color images

    Support vector images

    Wiki Examples:

    All Examples

    Bilateral filter an image
    See:
     itk::simple::Bilateral for the procedural interface

     itk::BilateralImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBilateralImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BilateralImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BilateralImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BilateralImageFilter self) -> BilateralImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BilateralImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BilateralImageFilter
    __del__ = lambda self: None

    def SetDomainSigma(self, DomainSigma):
        """
        SetDomainSigma(BilateralImageFilter self, double DomainSigma)



        Convenience get/set methods for setting all domain parameters to the
        same values.


        """
        return _SimpleITK.BilateralImageFilter_SetDomainSigma(self, DomainSigma)


    def GetDomainSigma(self):
        """
        GetDomainSigma(BilateralImageFilter self) -> double



        Standard get/set macros for filter parameters. DomainSigma is
        specified in the same units as the Image spacing. RangeSigma is specified in the units of intensity.


        """
        return _SimpleITK.BilateralImageFilter_GetDomainSigma(self)


    def SetRangeSigma(self, RangeSigma):
        """
        SetRangeSigma(BilateralImageFilter self, double RangeSigma)



        Standard get/set macros for filter parameters. DomainSigma is
        specified in the same units as the Image spacing. RangeSigma is specified in the units of intensity.


        """
        return _SimpleITK.BilateralImageFilter_SetRangeSigma(self, RangeSigma)


    def GetRangeSigma(self):
        """
        GetRangeSigma(BilateralImageFilter self) -> double



        Standard get/set macros for filter parameters. DomainSigma is
        specified in the same units as the Image spacing. RangeSigma is specified in the units of intensity.


        """
        return _SimpleITK.BilateralImageFilter_GetRangeSigma(self)


    def SetNumberOfRangeGaussianSamples(self, NumberOfRangeGaussianSamples):
        """
        SetNumberOfRangeGaussianSamples(BilateralImageFilter self, unsigned int NumberOfRangeGaussianSamples)



        Set/Get the number of samples in the approximation to the Gaussian
        used for the range smoothing. Samples are only generated in the range
        of [0, 4*m_RangeSigma]. Default is 100.


        """
        return _SimpleITK.BilateralImageFilter_SetNumberOfRangeGaussianSamples(self, NumberOfRangeGaussianSamples)


    def GetNumberOfRangeGaussianSamples(self):
        """
        GetNumberOfRangeGaussianSamples(BilateralImageFilter self) -> unsigned int



        Set/Get the number of samples in the approximation to the Gaussian
        used for the range smoothing. Samples are only generated in the range
        of [0, 4*m_RangeSigma]. Default is 100.


        """
        return _SimpleITK.BilateralImageFilter_GetNumberOfRangeGaussianSamples(self)


    def GetName(self):
        """
        GetName(BilateralImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BilateralImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BilateralImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BilateralImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BilateralImageFilter self, Image image1) -> Image
        Execute(BilateralImageFilter self, Image image1, double domainSigma, double rangeSigma, unsigned int numberOfRangeGaussianSamples) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BilateralImageFilter_Execute(self, *args)

BilateralImageFilter_swigregister = _SimpleITK.BilateralImageFilter_swigregister
BilateralImageFilter_swigregister(BilateralImageFilter)


def Bilateral(image1, domainSigma=4.0, rangeSigma=50.0, numberOfRangeGaussianSamples=100):
    """
    Bilateral(Image image1, double domainSigma=4.0, double rangeSigma=50.0, unsigned int numberOfRangeGaussianSamples=100) -> Image



    Blurs an image while preserving edges.


    This function directly calls the execute method of BilateralImageFilter in order to support a procedural API


    See:
     itk::simple::BilateralImageFilter for the object oriented interface



    """
    return _SimpleITK.Bilateral(image1, domainSigma, rangeSigma, numberOfRangeGaussianSamples)
class BinShrinkImageFilter(ImageFilter_1):
    """


    Reduce the size of an image by an integer factor in each dimension
    while performing averaging of an input neighborhood.


    The output image size in each dimension is given by:

    outputSize[j] = max( std::floor(inputSize[j]/shrinkFactor[j]), 1 );

    The algorithm implemented can be describe with the following equation
    for 2D: \\[ \\mathsf{I}_{out}(x_o,x_1) =
    \\frac{\\sum_{i=0}^{f_0}\\sum_{j=0}^{f_1}\\mathsf{I}_{in}(f_0
    x_o+i,f_1 x_1+j)}{f_0 f_1} \\]

    This filter is implemented so that the starting extent of the first
    pixel of the output matches that of the input.

    The change in image geometry from a 5x5 image binned by a factor of
    2x2. This code was contributed in the Insight Journal paper:
    "BinShrink: A multi-resolution filter with cache efficient
    averaging" by Lowekamp B., Chen D. https://hdl.handle.net/10380/3450
    See:
     itk::simple::BinShrink for the procedural interface

     itk::BinShrinkImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinShrinkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinShrinkImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinShrinkImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinShrinkImageFilter self) -> BinShrinkImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinShrinkImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinShrinkImageFilter
    __del__ = lambda self: None

    def SetShrinkFactor(self, s):
        """
        SetShrinkFactor(BinShrinkImageFilter self, unsigned int s) -> BinShrinkImageFilter



        Custom public declarations


        """
        return _SimpleITK.BinShrinkImageFilter_SetShrinkFactor(self, s)


    def SetShrinkFactors(self, ShrinkFactors):
        """
        SetShrinkFactors(BinShrinkImageFilter self, VectorUInt32 ShrinkFactors)



        Set the shrink factors. Values are clamped to a minimum value of 1.
        Default is 1 for all dimensions.


        """
        return _SimpleITK.BinShrinkImageFilter_SetShrinkFactors(self, ShrinkFactors)


    def GetShrinkFactors(self):
        """
        GetShrinkFactors(BinShrinkImageFilter self) -> VectorUInt32



        Get the shrink factors.


        """
        return _SimpleITK.BinShrinkImageFilter_GetShrinkFactors(self)


    def GetName(self):
        """
        GetName(BinShrinkImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinShrinkImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinShrinkImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinShrinkImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinShrinkImageFilter self, Image image1) -> Image
        Execute(BinShrinkImageFilter self, Image image1, VectorUInt32 shrinkFactors) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinShrinkImageFilter_Execute(self, *args)

BinShrinkImageFilter_swigregister = _SimpleITK.BinShrinkImageFilter_swigregister
BinShrinkImageFilter_swigregister(BinShrinkImageFilter)


def BinShrink(*args, **kwargs):
    """
    BinShrink(Image image1, VectorUInt32 shrinkFactors) -> Image



    Reduce the size of an image by an integer factor in each dimension
    while performing averaging of an input neighborhood.


    This function directly calls the execute method of BinShrinkImageFilter in order to support a procedural API


    See:
     itk::simple::BinShrinkImageFilter for the object oriented interface



    """
    return _SimpleITK.BinShrink(*args, **kwargs)
class BinaryClosingByReconstructionImageFilter(ImageFilter_1):
    """


    binary closing by reconstruction of an image.


    This filter removes small (i.e., smaller than the structuring element)
    holes in the image. It is defined as: Closing(f) =
    ReconstructionByErosion(Dilation(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     MorphologyImageFilter , ClosingByReconstructionImageFilter , BinaryOpeningByReconstructionImageFilter

     itk::simple::BinaryClosingByReconstruction for the procedural interface

     itk::BinaryClosingByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryClosingByReconstructionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryClosingByReconstructionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryClosingByReconstructionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryClosingByReconstructionImageFilter self) -> BinaryClosingByReconstructionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryClosingByReconstructionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryClosingByReconstructionImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BinaryClosingByReconstructionImageFilter_Annulus
    Ball = _SimpleITK.BinaryClosingByReconstructionImageFilter_Ball
    Box = _SimpleITK.BinaryClosingByReconstructionImageFilter_Box
    Cross = _SimpleITK.BinaryClosingByReconstructionImageFilter_Cross

    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryClosingByReconstructionImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryClosingByReconstructionImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetForegroundValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryClosingByReconstructionImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryClosingByReconstructionImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryClosingByReconstructionImageFilter self)



        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryClosingByReconstructionImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetFullyConnected(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BinaryClosingByReconstructionImageFilter self, uint32_t r)
        SetKernelRadius(BinaryClosingByReconstructionImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BinaryClosingByReconstructionImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BinaryClosingByReconstructionImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BinaryClosingByReconstructionImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BinaryClosingByReconstructionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryClosingByReconstructionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryClosingByReconstructionImageFilter self, Image image1) -> Image
        Execute(BinaryClosingByReconstructionImageFilter self, Image image1, double foregroundValue, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryClosingByReconstructionImageFilter_Execute(self, *args)

BinaryClosingByReconstructionImageFilter_swigregister = _SimpleITK.BinaryClosingByReconstructionImageFilter_swigregister
BinaryClosingByReconstructionImageFilter_swigregister(BinaryClosingByReconstructionImageFilter)


def BinaryClosingByReconstruction(*args):
    """
    BinaryClosingByReconstruction(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double foregroundValue=1.0, bool fullyConnected=False) -> Image
    BinaryClosingByReconstruction(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double foregroundValue=1.0, bool fullyConnected=False) -> Image



    itk::simple::BinaryClosingByReconstructionImageFilter Functional Interface

    This function directly calls the execute method of BinaryClosingByReconstructionImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BinaryClosingByReconstruction(*args)
class BinaryContourImageFilter(ImageFilter_1):
    """


    Labels the pixels on the border of the objects in a binary image.


    BinaryContourImageFilter takes a binary image as input, where the pixels in the objects are
    the pixels with a value equal to ForegroundValue. Only the pixels on
    the contours of the objects are kept. The pixels not on the border are
    changed to BackgroundValue.

    The connectivity can be changed to minimum or maximum connectivity
    with SetFullyConnected() . Full connectivity produces thicker contours.

    https://hdl.handle.net/1926/1352


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     LabelContourImageFilter BinaryErodeImageFilter SimpleContourExtractorImageFilter
    Wiki Examples:

    All Examples

    Extract the boundaries of connected regions in a binary image

    Extract the inner and outer boundaries of blobs in a binary image
    See:
     itk::simple::BinaryContour for the procedural interface

     itk::BinaryContourImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryContourImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryContourImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryContourImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryContourImageFilter self) -> BinaryContourImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryContourImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryContourImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryContourImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryContourImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryContourImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryContourImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryContourImageFilter self)



        """
        return _SimpleITK.BinaryContourImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryContourImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryContourImageFilter_GetFullyConnected(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryContourImageFilter self, double BackgroundValue)



        Set/Get the background value used to mark the pixels not on the border
        of the objects.


        """
        return _SimpleITK.BinaryContourImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryContourImageFilter self) -> double



        Set/Get the background value used to mark the pixels not on the border
        of the objects.


        """
        return _SimpleITK.BinaryContourImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryContourImageFilter self, double ForegroundValue)



        Set/Get the foreground value used to identify the objects in the input
        and output images.


        """
        return _SimpleITK.BinaryContourImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryContourImageFilter self) -> double



        Set/Get the foreground value used to identify the objects in the input
        and output images.


        """
        return _SimpleITK.BinaryContourImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(BinaryContourImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryContourImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryContourImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryContourImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryContourImageFilter self, Image image1) -> Image
        Execute(BinaryContourImageFilter self, Image image1, bool fullyConnected, double backgroundValue, double foregroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryContourImageFilter_Execute(self, *args)

BinaryContourImageFilter_swigregister = _SimpleITK.BinaryContourImageFilter_swigregister
BinaryContourImageFilter_swigregister(BinaryContourImageFilter)


def BinaryContour(image1, fullyConnected=False, backgroundValue=0.0, foregroundValue=1.0):
    """
    BinaryContour(Image image1, bool fullyConnected=False, double backgroundValue=0.0, double foregroundValue=1.0) -> Image



    Labels the pixels on the border of the objects in a binary image.


    This function directly calls the execute method of BinaryContourImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryContourImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryContour(image1, fullyConnected, backgroundValue, foregroundValue)
class BinaryDilateImageFilter(ImageFilter_1):
    """


    Fast binary dilation.


    BinaryDilateImageFilter is a binary dilation morphologic operation. This implementation is
    based on the papers:

    L.Vincent "Morphological transformations of binary images with
    arbitrary structuring elements", and

    N.Nikopoulos et al. "An efficient algorithm for 3d binary
    morphological transformations with 3d structuring elements for
    arbitrary size and shape". IEEE Transactions on Image Processing. Vol. 9. No. 3. 2000. pp. 283-286.

    Gray scale images can be processed as binary images by selecting a
    "DilateValue". Pixel values matching the dilate value are considered
    the "foreground" and all other pixels are "background". This is
    useful in processing segmented images where all pixels in segment #1
    have value 1 and pixels in segment #2 have value 2, etc. A particular
    "segment number" can be processed. DilateValue defaults to the
    maximum possible value of the PixelType.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel. A reasonable choice
    of structuring element is itk::BinaryBallStructuringElement .


    See:
     ImageToImageFilter BinaryErodeImageFilter BinaryMorphologyImageFilter
    Wiki Examples:

    All Examples

    Dilate a binary image
    See:
     itk::simple::BinaryDilate for the procedural interface

     itk::BinaryDilateImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryDilateImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryDilateImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryDilateImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryDilateImageFilter self) -> BinaryDilateImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryDilateImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryDilateImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BinaryDilateImageFilter_Annulus
    Ball = _SimpleITK.BinaryDilateImageFilter_Ball
    Box = _SimpleITK.BinaryDilateImageFilter_Box
    Cross = _SimpleITK.BinaryDilateImageFilter_Cross

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryDilateImageFilter self, double BackgroundValue)



        """
        return _SimpleITK.BinaryDilateImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryDilateImageFilter self) -> double



        """
        return _SimpleITK.BinaryDilateImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryDilateImageFilter self, double ForegroundValue)



        """
        return _SimpleITK.BinaryDilateImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryDilateImageFilter self) -> double



        """
        return _SimpleITK.BinaryDilateImageFilter_GetForegroundValue(self)


    def SetBoundaryToForeground(self, BoundaryToForeground):
        """
        SetBoundaryToForeground(BinaryDilateImageFilter self, bool BoundaryToForeground)



        """
        return _SimpleITK.BinaryDilateImageFilter_SetBoundaryToForeground(self, BoundaryToForeground)


    def BoundaryToForegroundOn(self):
        """
        BoundaryToForegroundOn(BinaryDilateImageFilter self)



        Set the value of BoundaryToForeground to true or false respectfully.


        """
        return _SimpleITK.BinaryDilateImageFilter_BoundaryToForegroundOn(self)


    def BoundaryToForegroundOff(self):
        """
        BoundaryToForegroundOff(BinaryDilateImageFilter self)



        """
        return _SimpleITK.BinaryDilateImageFilter_BoundaryToForegroundOff(self)


    def GetBoundaryToForeground(self):
        """
        GetBoundaryToForeground(BinaryDilateImageFilter self) -> bool



        """
        return _SimpleITK.BinaryDilateImageFilter_GetBoundaryToForeground(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BinaryDilateImageFilter self, uint32_t r)
        SetKernelRadius(BinaryDilateImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BinaryDilateImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BinaryDilateImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BinaryDilateImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BinaryDilateImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BinaryDilateImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BinaryDilateImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BinaryDilateImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BinaryDilateImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryDilateImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryDilateImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryDilateImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryDilateImageFilter self, Image image1) -> Image
        Execute(BinaryDilateImageFilter self, Image image1, double backgroundValue, double foregroundValue, bool boundaryToForeground) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryDilateImageFilter_Execute(self, *args)

BinaryDilateImageFilter_swigregister = _SimpleITK.BinaryDilateImageFilter_swigregister
BinaryDilateImageFilter_swigregister(BinaryDilateImageFilter)


def BinaryDilate(*args):
    """
    BinaryDilate(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double backgroundValue=0.0, double foregroundValue=1.0, bool boundaryToForeground=False) -> Image
    BinaryDilate(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double backgroundValue=0.0, double foregroundValue=1.0, bool boundaryToForeground=False) -> Image



    itk::simple::BinaryDilateImageFilter Functional Interface

    This function directly calls the execute method of BinaryDilateImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BinaryDilate(*args)
class BinaryErodeImageFilter(ImageFilter_1):
    """


    Fast binary erosion.


    BinaryErodeImageFilter is a binary erosion morphologic operation. This implementation is
    based on the papers:

    L.Vincent "Morphological transformations of binary images with
    arbitrary structuring elements", and

    N.Nikopoulos et al. "An efficient algorithm for 3d binary
    morphological transformations with 3d structuring elements for
    arbitrary size and shape". IEEE Transactions on Image Processing. Vol. 9. No. 3. 2000. pp. 283-286.

    Gray scale images can be processed as binary images by selecting a
    "ErodeValue". Pixel values matching the erode value are considered
    the "foreground" and all other pixels are "background". This is
    useful in processing segmented images where all pixels in segment #1
    have value 1 and pixels in segment #2 have value 2, etc. A particular
    "segment number" can be processed. ErodeValue defaults to the
    maximum possible value of the PixelType. The eroded pixels will
    receive the BackgroundValue (defaults to 0).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel. A reasonable choice
    of structuring element is itk::BinaryBallStructuringElement .


    See:
     ImageToImageFilter BinaryDilateImageFilter BinaryMorphologyImageFilter
    Wiki Examples:

    All Examples

    Erode a binary image
    See:
     itk::simple::BinaryErode for the procedural interface

     itk::BinaryErodeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryErodeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryErodeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryErodeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryErodeImageFilter self) -> BinaryErodeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryErodeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryErodeImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BinaryErodeImageFilter_Annulus
    Ball = _SimpleITK.BinaryErodeImageFilter_Ball
    Box = _SimpleITK.BinaryErodeImageFilter_Box
    Cross = _SimpleITK.BinaryErodeImageFilter_Cross

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryErodeImageFilter self, double BackgroundValue)



        """
        return _SimpleITK.BinaryErodeImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryErodeImageFilter self) -> double



        """
        return _SimpleITK.BinaryErodeImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryErodeImageFilter self, double ForegroundValue)



        """
        return _SimpleITK.BinaryErodeImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryErodeImageFilter self) -> double



        """
        return _SimpleITK.BinaryErodeImageFilter_GetForegroundValue(self)


    def SetBoundaryToForeground(self, BoundaryToForeground):
        """
        SetBoundaryToForeground(BinaryErodeImageFilter self, bool BoundaryToForeground)



        """
        return _SimpleITK.BinaryErodeImageFilter_SetBoundaryToForeground(self, BoundaryToForeground)


    def BoundaryToForegroundOn(self):
        """
        BoundaryToForegroundOn(BinaryErodeImageFilter self)



        Set the value of BoundaryToForeground to true or false respectfully.


        """
        return _SimpleITK.BinaryErodeImageFilter_BoundaryToForegroundOn(self)


    def BoundaryToForegroundOff(self):
        """
        BoundaryToForegroundOff(BinaryErodeImageFilter self)



        """
        return _SimpleITK.BinaryErodeImageFilter_BoundaryToForegroundOff(self)


    def GetBoundaryToForeground(self):
        """
        GetBoundaryToForeground(BinaryErodeImageFilter self) -> bool



        """
        return _SimpleITK.BinaryErodeImageFilter_GetBoundaryToForeground(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BinaryErodeImageFilter self, uint32_t r)
        SetKernelRadius(BinaryErodeImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BinaryErodeImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BinaryErodeImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BinaryErodeImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BinaryErodeImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BinaryErodeImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BinaryErodeImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BinaryErodeImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BinaryErodeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryErodeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryErodeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryErodeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryErodeImageFilter self, Image image1) -> Image
        Execute(BinaryErodeImageFilter self, Image image1, double backgroundValue, double foregroundValue, bool boundaryToForeground) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryErodeImageFilter_Execute(self, *args)

BinaryErodeImageFilter_swigregister = _SimpleITK.BinaryErodeImageFilter_swigregister
BinaryErodeImageFilter_swigregister(BinaryErodeImageFilter)


def BinaryErode(*args):
    """
    BinaryErode(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double backgroundValue=0.0, double foregroundValue=1.0, bool boundaryToForeground=True) -> Image
    BinaryErode(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double backgroundValue=0.0, double foregroundValue=1.0, bool boundaryToForeground=True) -> Image



    itk::simple::BinaryErodeImageFilter Functional Interface

    This function directly calls the execute method of BinaryErodeImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BinaryErode(*args)
class BinaryFillholeImageFilter(ImageFilter_1):
    """


    Remove holes not connected to the boundary of the image.


    BinaryFillholeImageFilter fills holes in a binary image.

    Geodesic morphology and the Fillhole algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     GrayscaleFillholeImageFilter

     itk::simple::BinaryFillhole for the procedural interface

     itk::BinaryFillholeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryFillholeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryFillholeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryFillholeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryFillholeImageFilter self) -> BinaryFillholeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryFillholeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryFillholeImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryFillholeImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryFillholeImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryFillholeImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryFillholeImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryFillholeImageFilter self)



        """
        return _SimpleITK.BinaryFillholeImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryFillholeImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryFillholeImageFilter_GetFullyConnected(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryFillholeImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryFillholeImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryFillholeImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryFillholeImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(BinaryFillholeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryFillholeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryFillholeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryFillholeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryFillholeImageFilter self, Image image1) -> Image
        Execute(BinaryFillholeImageFilter self, Image image1, bool fullyConnected, double foregroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryFillholeImageFilter_Execute(self, *args)

BinaryFillholeImageFilter_swigregister = _SimpleITK.BinaryFillholeImageFilter_swigregister
BinaryFillholeImageFilter_swigregister(BinaryFillholeImageFilter)


def BinaryFillhole(image1, fullyConnected=False, foregroundValue=1.0):
    """
    BinaryFillhole(Image image1, bool fullyConnected=False, double foregroundValue=1.0) -> Image



    Remove holes not connected to the boundary of the image.


    This function directly calls the execute method of BinaryFillholeImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryFillholeImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryFillhole(image1, fullyConnected, foregroundValue)
class BinaryGrindPeakImageFilter(ImageFilter_1):
    """


    Remove the objects not connected to the boundary of the image.


    BinaryGrindPeakImageFilter ginds peaks in a grayscale image.

    Geodesic morphology and the grind peak algorithm is described in
    Chapter 6 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     GrayscaleGrindPeakImageFilter

     itk::simple::BinaryGrindPeak for the procedural interface

     itk::BinaryGrindPeakImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryGrindPeakImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryGrindPeakImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryGrindPeakImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryGrindPeakImageFilter self) -> BinaryGrindPeakImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryGrindPeakImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryGrindPeakImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryGrindPeakImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryGrindPeakImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryGrindPeakImageFilter self)



        """
        return _SimpleITK.BinaryGrindPeakImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryGrindPeakImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetFullyConnected(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryGrindPeakImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryGrindPeakImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryGrindPeakImageFilter self, double BackgroundValue)



        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryGrindPeakImageFilter self) -> double



        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(BinaryGrindPeakImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryGrindPeakImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryGrindPeakImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryGrindPeakImageFilter self, Image image1) -> Image
        Execute(BinaryGrindPeakImageFilter self, Image image1, bool fullyConnected, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryGrindPeakImageFilter_Execute(self, *args)

BinaryGrindPeakImageFilter_swigregister = _SimpleITK.BinaryGrindPeakImageFilter_swigregister
BinaryGrindPeakImageFilter_swigregister(BinaryGrindPeakImageFilter)


def BinaryGrindPeak(image1, fullyConnected=False, foregroundValue=1.0, backgroundValue=0):
    """
    BinaryGrindPeak(Image image1, bool fullyConnected=False, double foregroundValue=1.0, double backgroundValue=0) -> Image



    Remove the objects not connected to the boundary of the image.


    This function directly calls the execute method of BinaryGrindPeakImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryGrindPeakImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryGrindPeak(image1, fullyConnected, foregroundValue, backgroundValue)
class BinaryImageToLabelMapFilter(ImageFilter_1):
    """


    Label the connected components in a binary image and produce a
    collection of label objects.


    BinaryImageToLabelMapFilter labels the objects in a binary image. Each distinct object is
    assigned a unique label. The final object labels start with 1 and are
    consecutive. Objects that are reached earlier by a raster order scan
    have a lower label.

    The GetOutput() function of this class returns an itk::LabelMap .

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ConnectedComponentImageFilter , LabelImageToLabelMapFilter , LabelMap , LabelObject
    Wiki Examples:

    All Examples

    Label binary regions in an image
    See:
     itk::simple::BinaryImageToLabelMapFilter for the procedural interface

     itk::BinaryImageToLabelMapFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryImageToLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryImageToLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryImageToLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryImageToLabelMapFilter self) -> BinaryImageToLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryImageToLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryImageToLabelMapFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryImageToLabelMapFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryImageToLabelMapFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryImageToLabelMapFilter self)



        """
        return _SimpleITK.BinaryImageToLabelMapFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryImageToLabelMapFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetFullyConnected(self)


    def SetInputForegroundValue(self, InputForegroundValue):
        """
        SetInputForegroundValue(BinaryImageToLabelMapFilter self, double InputForegroundValue)



        Set/Get the value to be consider "foreground" in the input image.
        Defaults to NumericTraits<InputPixelType>::max() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_SetInputForegroundValue(self, InputForegroundValue)


    def GetInputForegroundValue(self):
        """
        GetInputForegroundValue(BinaryImageToLabelMapFilter self) -> double



        Set/Get the value to be consider "foreground" in the input image.
        Defaults to NumericTraits<InputPixelType>::max() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetInputForegroundValue(self)


    def SetOutputBackgroundValue(self, OutputBackgroundValue):
        """
        SetOutputBackgroundValue(BinaryImageToLabelMapFilter self, double OutputBackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<OutputPixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_SetOutputBackgroundValue(self, OutputBackgroundValue)


    def GetOutputBackgroundValue(self):
        """
        GetOutputBackgroundValue(BinaryImageToLabelMapFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<OutputPixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetOutputBackgroundValue(self)


    def GetName(self):
        """
        GetName(BinaryImageToLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryImageToLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryImageToLabelMapFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryImageToLabelMapFilter self, Image image1) -> Image
        Execute(BinaryImageToLabelMapFilter self, Image image1, bool fullyConnected, double inputForegroundValue, double outputBackgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryImageToLabelMapFilter_Execute(self, *args)

BinaryImageToLabelMapFilter_swigregister = _SimpleITK.BinaryImageToLabelMapFilter_swigregister
BinaryImageToLabelMapFilter_swigregister(BinaryImageToLabelMapFilter)


def BinaryImageToLabelMap(image1, fullyConnected=False, inputForegroundValue=1.0, outputBackgroundValue=0.0):
    """
    BinaryImageToLabelMap(Image image1, bool fullyConnected=False, double inputForegroundValue=1.0, double outputBackgroundValue=0.0) -> Image



    Label the connected components in a binary image and produce a
    collection of label objects.


    This function directly calls the execute method of BinaryImageToLabelMapFilter in order to support a procedural API


    See:
     itk::simple::BinaryImageToLabelMapFilter for the object oriented interface



    """
    return _SimpleITK.BinaryImageToLabelMap(image1, fullyConnected, inputForegroundValue, outputBackgroundValue)
class BinaryMagnitudeImageFilter(ImageFilter_2):
    """


    Computes the square root of the sum of squares of corresponding input
    pixels.


    This filter is templated over the types of the two input images and
    the type of the output image.

    Numeric conversions (castings) are done by the C++ defaults.

    The filter walks over all of the pixels in the two input images, and
    for each pixel does the following:


    cast the input 1 pixel value to double

    cast the input 2 pixel value to double

    compute the sum of squares of the two pixel values

    compute the square root of the sum

    cast the double value resulting from std::sqrt() to the pixel type of
    the output image

    store the cast value into the output image.
     The filter expects all images to have the same dimension (e.g. all
    2D, or all 3D, or all ND)
    See:
     itk::simple::BinaryMagnitude for the procedural interface

     itk::BinaryMagnitudeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMagnitudeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryMagnitudeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryMagnitudeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryMagnitudeImageFilter self) -> BinaryMagnitudeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryMagnitudeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryMagnitudeImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(BinaryMagnitudeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryMagnitudeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryMagnitudeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryMagnitudeImageFilter___str__(self)


    def Execute(self, image1, image2):
        """
        Execute(BinaryMagnitudeImageFilter self, Image image1, Image image2) -> Image



        Execute the filter on the input images


        """
        return _SimpleITK.BinaryMagnitudeImageFilter_Execute(self, image1, image2)

BinaryMagnitudeImageFilter_swigregister = _SimpleITK.BinaryMagnitudeImageFilter_swigregister
BinaryMagnitudeImageFilter_swigregister(BinaryMagnitudeImageFilter)


def BinaryMagnitude(image1, image2):
    """
    BinaryMagnitude(Image image1, Image image2) -> Image



    Computes the square root of the sum of squares of corresponding input
    pixels.


    This function directly calls the execute method of BinaryMagnitudeImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryMagnitudeImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryMagnitude(image1, image2)
class BinaryMedianImageFilter(ImageFilter_1):
    """


    Applies a version of the median filter optimized for binary images.


    This filter was contributed by Bjorn Hanch Sollie after identifying
    that the generic Median filter performed unnecessary operations when
    the input image is binary.

    This filter computes an image where a given pixel is the median value
    of the pixels in a neighborhood about the corresponding input pixel.
    For the case of binary images the median can be obtained by simply
    counting the neighbors that are foreground.

    A median filter is one of the family of nonlinear filters. It is used
    to smooth an image without being biased by outliers or shot noise.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::BinaryMedian for the procedural interface

     itk::BinaryMedianImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMedianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryMedianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryMedianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryMedianImageFilter self) -> BinaryMedianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryMedianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryMedianImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(BinaryMedianImageFilter self, VectorUInt32 Radius)
        SetRadius(BinaryMedianImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.BinaryMedianImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(BinaryMedianImageFilter self) -> VectorUInt32



        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.BinaryMedianImageFilter_GetRadius(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryMedianImageFilter self, double ForegroundValue)



        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryMedianImageFilter self) -> double



        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryMedianImageFilter self, double BackgroundValue)



        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryMedianImageFilter self) -> double



        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.BinaryMedianImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(BinaryMedianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryMedianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryMedianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryMedianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryMedianImageFilter self, Image image1) -> Image
        Execute(BinaryMedianImageFilter self, Image image1, VectorUInt32 radius, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryMedianImageFilter_Execute(self, *args)

BinaryMedianImageFilter_swigregister = _SimpleITK.BinaryMedianImageFilter_swigregister
BinaryMedianImageFilter_swigregister(BinaryMedianImageFilter)


def BinaryMedian(*args, **kwargs):
    """
    BinaryMedian(Image image1, VectorUInt32 radius, double foregroundValue=1.0, double backgroundValue=0.0) -> Image



    Applies a version of the median filter optimized for binary images.


    This function directly calls the execute method of BinaryMedianImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryMedianImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryMedian(*args, **kwargs)
class BinaryMinMaxCurvatureFlowImageFilter(ImageFilter_1):
    """


    Denoise a binary image using min/max curvature flow.


    BinaryMinMaxCurvatureFlowImageFilter implements a curvature driven image denosing algorithm. This filter
    assumes that the image is essentially binary: consisting of two
    classes. Iso-brightness contours in the input image are viewed as a
    level set. The level set is then evolved using a curvature-based speed
    function:

    \\[ I_t = F_{\\mbox{minmax}} |\\nabla I| \\]

    where $ F_{\\mbox{minmax}} = \\min(\\kappa,0) $ if $ \\mbox{Avg}_{\\mbox{stencil}}(x) $ is less than or equal to $ T_{thresold} $ and $ \\max(\\kappa,0) $ , otherwise. $ \\kappa $ is the mean curvature of the iso-brightness contour at point $ x $ .

    In min/max curvature flow, movement is turned on or off depending on
    the scale of the noise one wants to remove. Switching depends on the
    average image value of a region of radius $ R $ around each point. The choice of $ R $ , the stencil radius, governs the scale of the noise to be removed.

    The threshold value $ T_{threshold} $ is a user specified value which discriminates between the two pixel
    classes.

    This filter make use of the multi-threaded finite difference solver
    hierarchy. Updates are computed using a BinaryMinMaxCurvatureFlowFunction object. A zero flux Neumann boundary condition is used when computing
    derivatives near the data boundary.


    WARNING:
    This filter assumes that the input and output types have the same
    dimensions. This filter also requires that the output image pixels are
    of a real type. This filter works for any dimensional images.
     Reference: "Level Set Methods and Fast Marching Methods", J.A.
    Sethian, Cambridge Press, Chapter 16, Second edition, 1999.


    See:
     BinaryMinMaxCurvatureFlowFunction

     CurvatureFlowImageFilter

     MinMaxCurvatureFlowImageFilter

     itk::simple::BinaryMinMaxCurvatureFlow for the procedural interface

     itk::BinaryMinMaxCurvatureFlowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMinMaxCurvatureFlowImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryMinMaxCurvatureFlowImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryMinMaxCurvatureFlowImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryMinMaxCurvatureFlowImageFilter self) -> BinaryMinMaxCurvatureFlowImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryMinMaxCurvatureFlowImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryMinMaxCurvatureFlowImageFilter
    __del__ = lambda self: None

    def SetTimeStep(self, TimeStep):
        """
        SetTimeStep(BinaryMinMaxCurvatureFlowImageFilter self, double TimeStep)



        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetTimeStep(self, TimeStep)


    def GetTimeStep(self):
        """
        GetTimeStep(BinaryMinMaxCurvatureFlowImageFilter self) -> double



        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetTimeStep(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(BinaryMinMaxCurvatureFlowImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(BinaryMinMaxCurvatureFlowImageFilter self) -> uint32_t



        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetNumberOfIterations(self)


    def SetStencilRadius(self, StencilRadius):
        """
        SetStencilRadius(BinaryMinMaxCurvatureFlowImageFilter self, int StencilRadius)



        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetStencilRadius(self, StencilRadius)


    def GetStencilRadius(self):
        """
        GetStencilRadius(BinaryMinMaxCurvatureFlowImageFilter self) -> int



        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetStencilRadius(self)


    def SetThreshold(self, Threshold):
        """
        SetThreshold(BinaryMinMaxCurvatureFlowImageFilter self, double Threshold)



        Set/Get the threshold value.


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_SetThreshold(self, Threshold)


    def GetThreshold(self):
        """
        GetThreshold(BinaryMinMaxCurvatureFlowImageFilter self) -> double



        Set/Get the threshold value.


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(BinaryMinMaxCurvatureFlowImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryMinMaxCurvatureFlowImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryMinMaxCurvatureFlowImageFilter self, Image image1) -> Image
        Execute(BinaryMinMaxCurvatureFlowImageFilter self, Image image1, double timeStep, uint32_t numberOfIterations, int stencilRadius, double threshold) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_Execute(self, *args)

BinaryMinMaxCurvatureFlowImageFilter_swigregister = _SimpleITK.BinaryMinMaxCurvatureFlowImageFilter_swigregister
BinaryMinMaxCurvatureFlowImageFilter_swigregister(BinaryMinMaxCurvatureFlowImageFilter)


def BinaryMinMaxCurvatureFlow(image1, timeStep=0.05, numberOfIterations=5, stencilRadius=2, threshold=0):
    """
    BinaryMinMaxCurvatureFlow(Image image1, double timeStep=0.05, uint32_t numberOfIterations=5, int stencilRadius=2, double threshold=0) -> Image



    Denoise a binary image using min/max curvature flow.


    This function directly calls the execute method of BinaryMinMaxCurvatureFlowImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryMinMaxCurvatureFlowImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryMinMaxCurvatureFlow(image1, timeStep, numberOfIterations, stencilRadius, threshold)
class BinaryMorphologicalClosingImageFilter(ImageFilter_1):
    """


    binary morphological closing of an image.


    This filter removes small (i.e., smaller than the structuring element)
    holes and tube like structures in the interior or at the boundaries of
    the image. The morphological closing of an image "f" is defined as:
    Closing(f) = Erosion(Dilation(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.

    This code was contributed in the Insight Journal paper: "Binary
    morphological closing and opening image filters" by Lehmann G. https://hdl.handle.net/1926/141 http://www.insight-journal.org/browse/publication/58


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleErodeImageFilter

     itk::simple::BinaryMorphologicalClosing for the procedural interface

     itk::BinaryMorphologicalClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMorphologicalClosingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryMorphologicalClosingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryMorphologicalClosingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryMorphologicalClosingImageFilter self) -> BinaryMorphologicalClosingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryMorphologicalClosingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryMorphologicalClosingImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BinaryMorphologicalClosingImageFilter_Annulus
    Ball = _SimpleITK.BinaryMorphologicalClosingImageFilter_Ball
    Box = _SimpleITK.BinaryMorphologicalClosingImageFilter_Box
    Cross = _SimpleITK.BinaryMorphologicalClosingImageFilter_Cross

    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryMorphologicalClosingImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryMorphologicalClosingImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of InputPixelType.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetForegroundValue(self)


    def SetSafeBorder(self, SafeBorder):
        """
        SetSafeBorder(BinaryMorphologicalClosingImageFilter self, bool SafeBorder)



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetSafeBorder(self, SafeBorder)


    def SafeBorderOn(self):
        """
        SafeBorderOn(BinaryMorphologicalClosingImageFilter self)



        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SafeBorderOn(self)


    def SafeBorderOff(self):
        """
        SafeBorderOff(BinaryMorphologicalClosingImageFilter self)



        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SafeBorderOff(self)


    def GetSafeBorder(self):
        """
        GetSafeBorder(BinaryMorphologicalClosingImageFilter self) -> bool



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetSafeBorder(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BinaryMorphologicalClosingImageFilter self, uint32_t r)
        SetKernelRadius(BinaryMorphologicalClosingImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BinaryMorphologicalClosingImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BinaryMorphologicalClosingImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BinaryMorphologicalClosingImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BinaryMorphologicalClosingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryMorphologicalClosingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryMorphologicalClosingImageFilter self, Image image1) -> Image
        Execute(BinaryMorphologicalClosingImageFilter self, Image image1, double foregroundValue, bool safeBorder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryMorphologicalClosingImageFilter_Execute(self, *args)

BinaryMorphologicalClosingImageFilter_swigregister = _SimpleITK.BinaryMorphologicalClosingImageFilter_swigregister
BinaryMorphologicalClosingImageFilter_swigregister(BinaryMorphologicalClosingImageFilter)


def BinaryMorphologicalClosing(*args):
    """
    BinaryMorphologicalClosing(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double foregroundValue=1.0, bool safeBorder=True) -> Image
    BinaryMorphologicalClosing(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double foregroundValue=1.0, bool safeBorder=True) -> Image



    itk::simple::BinaryMorphologicalClosingImageFilter Functional Interface

    This function directly calls the execute method of BinaryMorphologicalClosingImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BinaryMorphologicalClosing(*args)
class BinaryMorphologicalOpeningImageFilter(ImageFilter_1):
    """


    binary morphological opening of an image.


    This filter removes small (i.e., smaller than the structuring element)
    structures in the interior or at the boundaries of the image. The
    morphological opening of an image "f" is defined as: Opening(f) =
    Dilatation(Erosion(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.

    This code was contributed in the Insight Journal paper: "Binary
    morphological closing and opening image filters" by Lehmann G. https://hdl.handle.net/1926/141 http://www.insight-journal.org/browse/publication/58


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleErodeImageFilter

     itk::simple::BinaryMorphologicalOpening for the procedural interface

     itk::BinaryMorphologicalOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryMorphologicalOpeningImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryMorphologicalOpeningImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryMorphologicalOpeningImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryMorphologicalOpeningImageFilter self) -> BinaryMorphologicalOpeningImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryMorphologicalOpeningImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryMorphologicalOpeningImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BinaryMorphologicalOpeningImageFilter_Annulus
    Ball = _SimpleITK.BinaryMorphologicalOpeningImageFilter_Ball
    Box = _SimpleITK.BinaryMorphologicalOpeningImageFilter_Box
    Cross = _SimpleITK.BinaryMorphologicalOpeningImageFilter_Cross

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryMorphologicalOpeningImageFilter self, double BackgroundValue)



        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryMorphologicalOpeningImageFilter self) -> double



        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryMorphologicalOpeningImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryMorphologicalOpeningImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetForegroundValue(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BinaryMorphologicalOpeningImageFilter self, uint32_t r)
        SetKernelRadius(BinaryMorphologicalOpeningImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BinaryMorphologicalOpeningImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BinaryMorphologicalOpeningImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BinaryMorphologicalOpeningImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BinaryMorphologicalOpeningImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryMorphologicalOpeningImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryMorphologicalOpeningImageFilter self, Image image1) -> Image
        Execute(BinaryMorphologicalOpeningImageFilter self, Image image1, double backgroundValue, double foregroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryMorphologicalOpeningImageFilter_Execute(self, *args)

BinaryMorphologicalOpeningImageFilter_swigregister = _SimpleITK.BinaryMorphologicalOpeningImageFilter_swigregister
BinaryMorphologicalOpeningImageFilter_swigregister(BinaryMorphologicalOpeningImageFilter)


def BinaryMorphologicalOpening(*args):
    """
    BinaryMorphologicalOpening(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double backgroundValue=0.0, double foregroundValue=1.0) -> Image
    BinaryMorphologicalOpening(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double backgroundValue=0.0, double foregroundValue=1.0) -> Image



    itk::simple::BinaryMorphologicalOpeningImageFilter Functional Interface

    This function directly calls the execute method of BinaryMorphologicalOpeningImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BinaryMorphologicalOpening(*args)
class BinaryNotImageFilter(ImageFilter_1):
    """


    Implements the BinaryNot logical operator pixel-wise between two
    images.


    This class is parametrized over the types of the two input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.

    The total operation over one pixel will be

    output_pixel = static_cast<PixelType>( input1_pixel != input2_pixel )

    Where "!=" is the equality operator in C++.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176

    Wiki Examples:

    All Examples

    Invert an image using the Binary Not operation
    See:
     itk::simple::BinaryNot for the procedural interface

     itk::BinaryNotImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryNotImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryNotImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryNotImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryNotImageFilter self) -> BinaryNotImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryNotImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryNotImageFilter
    __del__ = lambda self: None

    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryNotImageFilter self, double ForegroundValue)



        Set/Get the value in the image considered as "foreground". Defaults
        to maximum value of PixelType.


        """
        return _SimpleITK.BinaryNotImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryNotImageFilter self) -> double



        Set/Get the value in the image considered as "foreground". Defaults
        to maximum value of PixelType.


        """
        return _SimpleITK.BinaryNotImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryNotImageFilter self, double BackgroundValue)



        Set the value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryNotImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryNotImageFilter self) -> double



        Get the value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryNotImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(BinaryNotImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryNotImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryNotImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryNotImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryNotImageFilter self, Image image1) -> Image
        Execute(BinaryNotImageFilter self, Image image1, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryNotImageFilter_Execute(self, *args)

BinaryNotImageFilter_swigregister = _SimpleITK.BinaryNotImageFilter_swigregister
BinaryNotImageFilter_swigregister(BinaryNotImageFilter)


def BinaryNot(image1, foregroundValue=1.0, backgroundValue=0.0):
    """
    BinaryNot(Image image1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image



    Implements the BinaryNot logical operator pixel-wise between two
    images.


    This function directly calls the execute method of BinaryNotImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryNotImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryNot(image1, foregroundValue, backgroundValue)
class BinaryOpeningByReconstructionImageFilter(ImageFilter_1):
    """


    binary morphological closing of an image.


    This filter removes small (i.e., smaller than the structuring element)
    objects in the image. It is defined as: Opening(f) =
    ReconstructionByDilatation(Erosion(f)).

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     MorphologyImageFilter , OpeningByReconstructionImageFilter , BinaryClosingByReconstructionImageFilter

     itk::simple::BinaryOpeningByReconstruction for the procedural interface

     itk::BinaryOpeningByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryOpeningByReconstructionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryOpeningByReconstructionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryOpeningByReconstructionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryOpeningByReconstructionImageFilter self) -> BinaryOpeningByReconstructionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryOpeningByReconstructionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryOpeningByReconstructionImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BinaryOpeningByReconstructionImageFilter_Annulus
    Ball = _SimpleITK.BinaryOpeningByReconstructionImageFilter_Ball
    Box = _SimpleITK.BinaryOpeningByReconstructionImageFilter_Box
    Cross = _SimpleITK.BinaryOpeningByReconstructionImageFilter_Cross

    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryOpeningByReconstructionImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryOpeningByReconstructionImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryOpeningByReconstructionImageFilter self, double BackgroundValue)



        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryOpeningByReconstructionImageFilter self) -> double



        Set the value in eroded part of the image. Defaults to zero


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetBackgroundValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryOpeningByReconstructionImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryOpeningByReconstructionImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryOpeningByReconstructionImageFilter self)



        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryOpeningByReconstructionImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetFullyConnected(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BinaryOpeningByReconstructionImageFilter self, uint32_t r)
        SetKernelRadius(BinaryOpeningByReconstructionImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BinaryOpeningByReconstructionImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BinaryOpeningByReconstructionImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BinaryOpeningByReconstructionImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BinaryOpeningByReconstructionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryOpeningByReconstructionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryOpeningByReconstructionImageFilter self, Image image1) -> Image
        Execute(BinaryOpeningByReconstructionImageFilter self, Image image1, double foregroundValue, double backgroundValue, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryOpeningByReconstructionImageFilter_Execute(self, *args)

BinaryOpeningByReconstructionImageFilter_swigregister = _SimpleITK.BinaryOpeningByReconstructionImageFilter_swigregister
BinaryOpeningByReconstructionImageFilter_swigregister(BinaryOpeningByReconstructionImageFilter)


def BinaryOpeningByReconstruction(*args):
    """
    BinaryOpeningByReconstruction(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double foregroundValue=1.0, double backgroundValue=0.0, bool fullyConnected=False) -> Image
    BinaryOpeningByReconstruction(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double foregroundValue=1.0, double backgroundValue=0.0, bool fullyConnected=False) -> Image



    itk::simple::BinaryOpeningByReconstructionImageFilter Functional Interface

    This function directly calls the execute method of BinaryOpeningByReconstructionImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BinaryOpeningByReconstruction(*args)
class BinaryProjectionImageFilter(ImageFilter_1):
    """


    Binary projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     itk::simple::BinaryProjection for the procedural interface

     itk::BinaryProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryProjectionImageFilter self) -> BinaryProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(BinaryProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.BinaryProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(BinaryProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.BinaryProjectionImageFilter_GetProjectionDimension(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryProjectionImageFilter self, double ForegroundValue)



        Set the value in the image to consider as "foreground". Defaults to
        maximum value of PixelType. Subclasses may alias this to DilateValue
        or ErodeValue.


        """
        return _SimpleITK.BinaryProjectionImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryProjectionImageFilter self) -> double



        Get the value in the image considered as "foreground". Defaults to
        maximum value of PixelType.


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryProjectionImageFilter self, double BackgroundValue)



        Set the value used as "background". Any pixel value which is not
        DilateValue is considered background. BackgroundValue is used for
        defining boundary conditions. Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryProjectionImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryProjectionImageFilter self) -> double



        Get the value used as "background". Any pixel value which is not
        DilateValue is considered background. BackgroundValue is used for
        defining boundary conditions. Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(BinaryProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryProjectionImageFilter self, Image image1) -> Image
        Execute(BinaryProjectionImageFilter self, Image image1, unsigned int projectionDimension, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryProjectionImageFilter_Execute(self, *args)

BinaryProjectionImageFilter_swigregister = _SimpleITK.BinaryProjectionImageFilter_swigregister
BinaryProjectionImageFilter_swigregister(BinaryProjectionImageFilter)


def BinaryProjection(image1, projectionDimension=0, foregroundValue=1.0, backgroundValue=0.0):
    """
    BinaryProjection(Image image1, unsigned int projectionDimension=0, double foregroundValue=1.0, double backgroundValue=0.0) -> Image



    Binary projection.


    This function directly calls the execute method of BinaryProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryProjection(image1, projectionDimension, foregroundValue, backgroundValue)
class BinaryReconstructionByDilationImageFilter(ImageFilter_2):
    """


    binary reconstruction by dilation of an image


    Reconstruction by dilation operates on a "marker" image and a
    "mask" image, and is defined as the dilation of the marker image
    with respect to the mask image iterated until stability.

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     MorphologyImageFilter , ReconstructionByDilationImageFilter , BinaryReconstructionByErosionImageFilter

     itk::simple::BinaryReconstructionByDilation for the procedural interface

     itk::BinaryReconstructionByDilationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryReconstructionByDilationImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryReconstructionByDilationImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryReconstructionByDilationImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryReconstructionByDilationImageFilter self) -> BinaryReconstructionByDilationImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryReconstructionByDilationImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryReconstructionByDilationImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryReconstructionByDilationImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryReconstructionByDilationImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryReconstructionByDilationImageFilter self, double ForegroundValue)



        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryReconstructionByDilationImageFilter self) -> double



        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetForegroundValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryReconstructionByDilationImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryReconstructionByDilationImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryReconstructionByDilationImageFilter self)



        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryReconstructionByDilationImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(BinaryReconstructionByDilationImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryReconstructionByDilationImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryReconstructionByDilationImageFilter self, Image image1, Image image2) -> Image
        Execute(BinaryReconstructionByDilationImageFilter self, Image image1, Image image2, double backgroundValue, double foregroundValue, bool fullyConnected) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.BinaryReconstructionByDilationImageFilter_Execute(self, *args)

BinaryReconstructionByDilationImageFilter_swigregister = _SimpleITK.BinaryReconstructionByDilationImageFilter_swigregister
BinaryReconstructionByDilationImageFilter_swigregister(BinaryReconstructionByDilationImageFilter)


def BinaryReconstructionByDilation(image1, image2, backgroundValue=0.0, foregroundValue=1.0, fullyConnected=False):
    """
    BinaryReconstructionByDilation(Image image1, Image image2, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False) -> Image



    binary reconstruction by dilation of an image


    This function directly calls the execute method of BinaryReconstructionByDilationImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryReconstructionByDilationImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryReconstructionByDilation(image1, image2, backgroundValue, foregroundValue, fullyConnected)
class BinaryReconstructionByErosionImageFilter(ImageFilter_2):
    """


    binary reconstruction by erosion of an image


    Reconstruction by erosion operates on a "marker" image and a
    "mask" image, and is defined as the erosion of the marker image with
    respect to the mask image iterated until stability.

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     MorphologyImageFilter , ReconstructionByErosionImageFilter , BinaryReconstructionByDilationImageFilter

     itk::simple::BinaryReconstructionByErosion for the procedural interface

     itk::BinaryReconstructionByErosionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryReconstructionByErosionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryReconstructionByErosionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryReconstructionByErosionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryReconstructionByErosionImageFilter self) -> BinaryReconstructionByErosionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryReconstructionByErosionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryReconstructionByErosionImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryReconstructionByErosionImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryReconstructionByErosionImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryReconstructionByErosionImageFilter self, double ForegroundValue)



        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryReconstructionByErosionImageFilter self) -> double



        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetForegroundValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(BinaryReconstructionByErosionImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(BinaryReconstructionByErosionImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(BinaryReconstructionByErosionImageFilter self)



        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(BinaryReconstructionByErosionImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(BinaryReconstructionByErosionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryReconstructionByErosionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryReconstructionByErosionImageFilter self, Image image1, Image image2) -> Image
        Execute(BinaryReconstructionByErosionImageFilter self, Image image1, Image image2, double backgroundValue, double foregroundValue, bool fullyConnected) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.BinaryReconstructionByErosionImageFilter_Execute(self, *args)

BinaryReconstructionByErosionImageFilter_swigregister = _SimpleITK.BinaryReconstructionByErosionImageFilter_swigregister
BinaryReconstructionByErosionImageFilter_swigregister(BinaryReconstructionByErosionImageFilter)


def BinaryReconstructionByErosion(image1, image2, backgroundValue=0.0, foregroundValue=1.0, fullyConnected=False):
    """
    BinaryReconstructionByErosion(Image image1, Image image2, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False) -> Image



    binary reconstruction by erosion of an image


    This function directly calls the execute method of BinaryReconstructionByErosionImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryReconstructionByErosionImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryReconstructionByErosion(image1, image2, backgroundValue, foregroundValue, fullyConnected)
class BinaryThinningImageFilter(ImageFilter_1):
    """


    This filter computes one-pixel-wide edges of the input image.


    This class is parametrized over the type of the input image and the
    type of the output image.

    The input is assumed to be a binary image. If the foreground pixels of
    the input image do not have a value of 1, they are rescaled to 1
    internally to simplify the computation.

    The filter will produce a skeleton of the object. The output
    background values are 0, and the foreground values are 1.

    This filter is a sequential thinning algorithm and known to be
    computational time dependable on the image size. The algorithm
    corresponds with the 2D implementation described in:

    Rafael C. Gonzales and Richard E. Woods. Digital Image Processing. Addison Wesley, 491-494, (1993).

    To do: Make this filter ND.


    See:
     MorphologyImageFilter
    Wiki Examples:

    All Examples

    Skeletonize/thin an image
    See:
     itk::simple::BinaryThinning for the procedural interface

     itk::BinaryThinningImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryThinningImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryThinningImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryThinningImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryThinningImageFilter self) -> BinaryThinningImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryThinningImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryThinningImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(BinaryThinningImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryThinningImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryThinningImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryThinningImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(BinaryThinningImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.BinaryThinningImageFilter_Execute(self, image1)

BinaryThinningImageFilter_swigregister = _SimpleITK.BinaryThinningImageFilter_swigregister
BinaryThinningImageFilter_swigregister(BinaryThinningImageFilter)


def BinaryThinning(image1):
    """
    BinaryThinning(Image image1) -> Image



    This filter computes one-pixel-wide edges of the input image.


    This function directly calls the execute method of BinaryThinningImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryThinningImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryThinning(image1)
class BinaryThresholdImageFilter(ImageFilter_1):
    """


    Binarize an input image by thresholding.


    This filter produces an output image whose pixels are either one of
    two values ( OutsideValue or InsideValue ), depending on whether the
    corresponding input image pixels lie between the two thresholds (
    LowerThreshold and UpperThreshold ). Values equal to either threshold
    is considered to be between the thresholds.

    More precisely \\[ Output(x_i) = \\begin{cases} InsideValue & \\text{if
    \\f$LowerThreshold \\leq x_i \\leq UpperThreshold\\f$}
    \\\\ OutsideValue & \\text{otherwise} \\end{cases} \\]

    This filter is templated over the input image type and the output
    image type.

    The filter expect both images to have the same number of dimensions.

    The default values for LowerThreshold and UpperThreshold are:
    LowerThreshold = NumericTraits<TInput>::NonpositiveMin() ; UpperThreshold = NumericTraits<TInput>::max() ; Therefore, generally only one of these needs to be set, depending
    on whether the user wants to threshold above or below the desired
    threshold.

    Wiki Examples:

    All Examples

    Threshold an image
    See:
     itk::simple::BinaryThreshold for the procedural interface

     itk::BinaryThresholdImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinaryThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryThresholdImageFilter self) -> BinaryThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryThresholdImageFilter
    __del__ = lambda self: None

    def SetLowerThreshold(self, LowerThreshold):
        """
        SetLowerThreshold(BinaryThresholdImageFilter self, double LowerThreshold)



        """
        return _SimpleITK.BinaryThresholdImageFilter_SetLowerThreshold(self, LowerThreshold)


    def GetLowerThreshold(self):
        """
        GetLowerThreshold(BinaryThresholdImageFilter self) -> double



        """
        return _SimpleITK.BinaryThresholdImageFilter_GetLowerThreshold(self)


    def SetUpperThreshold(self, UpperThreshold):
        """
        SetUpperThreshold(BinaryThresholdImageFilter self, double UpperThreshold)



        Set the thresholds. The default lower threshold is NumericTraits<InputPixelType>::NonpositiveMin() . The default upper threshold is NumericTraits<InputPixelType>::max . An execption is thrown if the lower threshold is greater than the
        upper threshold.


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetUpperThreshold(self, UpperThreshold)


    def GetUpperThreshold(self):
        """
        GetUpperThreshold(BinaryThresholdImageFilter self) -> double



        Get the threshold values.


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetUpperThreshold(self)


    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(BinaryThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(BinaryThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(BinaryThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::ZeroValue() .


        """
        return _SimpleITK.BinaryThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(BinaryThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetOutsideValue(self)


    def GetName(self):
        """
        GetName(BinaryThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryThresholdImageFilter self, Image image1) -> Image
        Execute(BinaryThresholdImageFilter self, Image image1, double lowerThreshold, double upperThreshold, uint8_t insideValue, uint8_t outsideValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryThresholdImageFilter_Execute(self, *args)

BinaryThresholdImageFilter_swigregister = _SimpleITK.BinaryThresholdImageFilter_swigregister
BinaryThresholdImageFilter_swigregister(BinaryThresholdImageFilter)


def BinaryThreshold(image1, lowerThreshold=0.0, upperThreshold=255.0, insideValue=1, outsideValue=0):
    """
    BinaryThreshold(Image image1, double lowerThreshold=0.0, double upperThreshold=255.0, uint8_t insideValue=1, uint8_t outsideValue=0) -> Image



    Binarize an input image by thresholding.


    This function directly calls the execute method of BinaryThresholdImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryThresholdImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryThreshold(image1, lowerThreshold, upperThreshold, insideValue, outsideValue)
class BinaryThresholdProjectionImageFilter(ImageFilter_1):
    """


    BinaryThreshold projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    the original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     itk::simple::BinaryThresholdProjection for the procedural interface

     itk::BinaryThresholdProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBinaryThresholdProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryThresholdProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryThresholdProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinaryThresholdProjectionImageFilter self) -> BinaryThresholdProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinaryThresholdProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinaryThresholdProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(BinaryThresholdProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(BinaryThresholdProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetProjectionDimension(self)


    def SetThresholdValue(self, ThresholdValue):
        """
        SetThresholdValue(BinaryThresholdProjectionImageFilter self, double ThresholdValue)



        Set/Get the input value consider as "threshold". Defaults to NumericTraits<InputPixelType>::max()


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_SetThresholdValue(self, ThresholdValue)


    def GetThresholdValue(self):
        """
        GetThresholdValue(BinaryThresholdProjectionImageFilter self) -> double



        Set/Get the input value consider as "threshold". Defaults to NumericTraits<InputPixelType>::max()


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetThresholdValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(BinaryThresholdProjectionImageFilter self, uint8_t ForegroundValue)



        Set/Get the output value used as "foreground". Defaults to maximum
        value of PixelType.


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(BinaryThresholdProjectionImageFilter self) -> uint8_t



        Set/Get the output value used as "foreground". Defaults to maximum
        value of PixelType.


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(BinaryThresholdProjectionImageFilter self, uint8_t BackgroundValue)



        Set/Get the output value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(BinaryThresholdProjectionImageFilter self) -> uint8_t



        Set/Get the output value used as "background". Defaults to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(BinaryThresholdProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinaryThresholdProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinaryThresholdProjectionImageFilter self, Image image1) -> Image
        Execute(BinaryThresholdProjectionImageFilter self, Image image1, unsigned int projectionDimension, double thresholdValue, uint8_t foregroundValue, uint8_t backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinaryThresholdProjectionImageFilter_Execute(self, *args)

BinaryThresholdProjectionImageFilter_swigregister = _SimpleITK.BinaryThresholdProjectionImageFilter_swigregister
BinaryThresholdProjectionImageFilter_swigregister(BinaryThresholdProjectionImageFilter)


def BinaryThresholdProjection(image1, projectionDimension=0, thresholdValue=0.0, foregroundValue=1, backgroundValue=0):
    """
    BinaryThresholdProjection(Image image1, unsigned int projectionDimension=0, double thresholdValue=0.0, uint8_t foregroundValue=1, uint8_t backgroundValue=0) -> Image



    BinaryThreshold projection.


    This function directly calls the execute method of BinaryThresholdProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::BinaryThresholdProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.BinaryThresholdProjection(image1, projectionDimension, thresholdValue, foregroundValue, backgroundValue)
class BinomialBlurImageFilter(ImageFilter_1):
    """


    Performs a separable blur on each dimension of an image.


    The binomial blur consists of a nearest neighbor average along each
    image dimension. The net result after n-iterations approaches
    convultion with a gaussian.

    Wiki Examples:

    All Examples

    Blur an image
    See:
     itk::simple::BinomialBlur for the procedural interface

     itk::BinomialBlurImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBinomialBlurImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinomialBlurImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinomialBlurImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BinomialBlurImageFilter self) -> BinomialBlurImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BinomialBlurImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BinomialBlurImageFilter
    __del__ = lambda self: None

    def SetRepetitions(self, Repetitions):
        """
        SetRepetitions(BinomialBlurImageFilter self, unsigned int Repetitions)



        Get and set the number of times to repeat the filter.


        """
        return _SimpleITK.BinomialBlurImageFilter_SetRepetitions(self, Repetitions)


    def GetRepetitions(self):
        """
        GetRepetitions(BinomialBlurImageFilter self) -> unsigned int



        Get and set the number of times to repeat the filter.


        """
        return _SimpleITK.BinomialBlurImageFilter_GetRepetitions(self)


    def GetName(self):
        """
        GetName(BinomialBlurImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BinomialBlurImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BinomialBlurImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BinomialBlurImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BinomialBlurImageFilter self, Image image1) -> Image
        Execute(BinomialBlurImageFilter self, Image image1, unsigned int repetitions) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BinomialBlurImageFilter_Execute(self, *args)

BinomialBlurImageFilter_swigregister = _SimpleITK.BinomialBlurImageFilter_swigregister
BinomialBlurImageFilter_swigregister(BinomialBlurImageFilter)


def BinomialBlur(image1, repetitions=1):
    """
    BinomialBlur(Image image1, unsigned int repetitions=1) -> Image



    Performs a separable blur on each dimension of an image.


    This function directly calls the execute method of BinomialBlurImageFilter in order to support a procedural API


    See:
     itk::simple::BinomialBlurImageFilter for the object oriented interface



    """
    return _SimpleITK.BinomialBlur(image1, repetitions)
class BitwiseNotImageFilter(ImageFilter_1):
    """


    Implements pixel-wise generic operation on one image.


    This class is parameterized over the type of the input image and the
    type of the output image. It is also parameterized by the operation to
    be applied, using a Functor style.

    UnaryFunctorImageFilter allows the output dimension of the filter to be larger than the input
    dimension. Thus subclasses of the UnaryFunctorImageFilter (like the CastImageFilter ) can be used to promote a 2D image to a 3D image, etc.


    See:
     BinaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a custom operation to each pixel in an image
    See:
     itk::simple::BitwiseNot for the procedural interface

     itk::UnaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkBitwiseNotImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BitwiseNotImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BitwiseNotImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BitwiseNotImageFilter self) -> BitwiseNotImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BitwiseNotImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BitwiseNotImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(BitwiseNotImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BitwiseNotImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BitwiseNotImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BitwiseNotImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(BitwiseNotImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.BitwiseNotImageFilter_Execute(self, image1)

BitwiseNotImageFilter_swigregister = _SimpleITK.BitwiseNotImageFilter_swigregister
BitwiseNotImageFilter_swigregister(BitwiseNotImageFilter)


def BitwiseNot(image1):
    """
    BitwiseNot(Image image1) -> Image



    Implements pixel-wise generic operation on one image.


    This function directly calls the execute method of BitwiseNotImageFilter in order to support a procedural API


    See:
     itk::simple::BitwiseNotImageFilter for the object oriented interface



    """
    return _SimpleITK.BitwiseNot(image1)
class BlackTopHatImageFilter(ImageFilter_1):
    """


    Black top hat extract local minima that are smaller than the
    structuring element.


    Black top hat extract local minima that are smaller than the
    structuring element. It subtract the background in the input image.
    The output of the filter transforms the black peaks in white peaks.

    Top-hats are described in Chapter 4.5 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     itk::simple::BlackTopHat for the procedural interface

     itk::BlackTopHatImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBlackTopHatImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BlackTopHatImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BlackTopHatImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BlackTopHatImageFilter self) -> BlackTopHatImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BlackTopHatImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BlackTopHatImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.BlackTopHatImageFilter_Annulus
    Ball = _SimpleITK.BlackTopHatImageFilter_Ball
    Box = _SimpleITK.BlackTopHatImageFilter_Box
    Cross = _SimpleITK.BlackTopHatImageFilter_Cross

    def SetSafeBorder(self, SafeBorder):
        """
        SetSafeBorder(BlackTopHatImageFilter self, bool SafeBorder)



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BlackTopHatImageFilter_SetSafeBorder(self, SafeBorder)


    def SafeBorderOn(self):
        """
        SafeBorderOn(BlackTopHatImageFilter self)



        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.BlackTopHatImageFilter_SafeBorderOn(self)


    def SafeBorderOff(self):
        """
        SafeBorderOff(BlackTopHatImageFilter self)



        """
        return _SimpleITK.BlackTopHatImageFilter_SafeBorderOff(self)


    def GetSafeBorder(self):
        """
        GetSafeBorder(BlackTopHatImageFilter self) -> bool



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.BlackTopHatImageFilter_GetSafeBorder(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(BlackTopHatImageFilter self, uint32_t r)
        SetKernelRadius(BlackTopHatImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.BlackTopHatImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(BlackTopHatImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BlackTopHatImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(BlackTopHatImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.BlackTopHatImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(BlackTopHatImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.BlackTopHatImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(BlackTopHatImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BlackTopHatImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BlackTopHatImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BlackTopHatImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BlackTopHatImageFilter self, Image image1) -> Image
        Execute(BlackTopHatImageFilter self, Image image1, bool safeBorder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BlackTopHatImageFilter_Execute(self, *args)

BlackTopHatImageFilter_swigregister = _SimpleITK.BlackTopHatImageFilter_swigregister
BlackTopHatImageFilter_swigregister(BlackTopHatImageFilter)


def BlackTopHat(*args):
    """
    BlackTopHat(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image
    BlackTopHat(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image



    itk::simple::BlackTopHatImageFilter Functional Interface

    This function directly calls the execute method of BlackTopHatImageFilter in order to support a fully functional API


    """
    return _SimpleITK.BlackTopHat(*args)
class BoundedReciprocalImageFilter(ImageFilter_1):
    """


    Computes 1/(1+x) for each pixel in the image.


    The filter expect both the input and output images to have the same
    number of dimensions, and both of a scalar image type.
    See:
     itk::simple::BoundedReciprocal for the procedural interface

     itk::BoundedReciprocalImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBoundedReciprocalImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoundedReciprocalImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoundedReciprocalImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BoundedReciprocalImageFilter self) -> BoundedReciprocalImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BoundedReciprocalImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BoundedReciprocalImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(BoundedReciprocalImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BoundedReciprocalImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BoundedReciprocalImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BoundedReciprocalImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(BoundedReciprocalImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.BoundedReciprocalImageFilter_Execute(self, image1)

BoundedReciprocalImageFilter_swigregister = _SimpleITK.BoundedReciprocalImageFilter_swigregister
BoundedReciprocalImageFilter_swigregister(BoundedReciprocalImageFilter)


def BoundedReciprocal(image1):
    """
    BoundedReciprocal(Image image1) -> Image



    Computes 1/(1+x) for each pixel in the image.


    This function directly calls the execute method of BoundedReciprocalImageFilter in order to support a procedural API


    See:
     itk::simple::BoundedReciprocalImageFilter for the object oriented interface



    """
    return _SimpleITK.BoundedReciprocal(image1)
class BoxMeanImageFilter(ImageFilter_1):
    """


    Implements a fast rectangular mean filter using the accumulator
    approach.


    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://hdl.handle.net/1926/555 http://www.insight-journal.org/browse/publication/160


    Richard Beare

    See:
     itk::simple::BoxMean for the procedural interface

     itk::BoxMeanImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBoxMeanImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoxMeanImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoxMeanImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BoxMeanImageFilter self) -> BoxMeanImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BoxMeanImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BoxMeanImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(BoxMeanImageFilter self, VectorUInt32 Radius)
        SetRadius(BoxMeanImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.BoxMeanImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(BoxMeanImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BoxMeanImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(BoxMeanImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BoxMeanImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BoxMeanImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BoxMeanImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BoxMeanImageFilter self, Image image1) -> Image
        Execute(BoxMeanImageFilter self, Image image1, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BoxMeanImageFilter_Execute(self, *args)

BoxMeanImageFilter_swigregister = _SimpleITK.BoxMeanImageFilter_swigregister
BoxMeanImageFilter_swigregister(BoxMeanImageFilter)


def BoxMean(*args, **kwargs):
    """
    BoxMean(Image image1, VectorUInt32 radius) -> Image



    Implements a fast rectangular mean filter using the accumulator
    approach.


    This function directly calls the execute method of BoxMeanImageFilter in order to support a procedural API


    See:
     itk::simple::BoxMeanImageFilter for the object oriented interface



    """
    return _SimpleITK.BoxMean(*args, **kwargs)
class BoxSigmaImageFilter(ImageFilter_1):
    """


    Implements a fast rectangular sigma filter using the accumulator
    approach.


    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://hdl.handle.net/1926/555 http://www.insight-journal.org/browse/publication/160


    Gaetan Lehmann

    See:
     itk::simple::BoxSigma for the procedural interface

     itk::BoxSigmaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkBoxSigmaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoxSigmaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoxSigmaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::BoxSigmaImageFilter self) -> BoxSigmaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_BoxSigmaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_BoxSigmaImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(BoxSigmaImageFilter self, VectorUInt32 Radius)
        SetRadius(BoxSigmaImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.BoxSigmaImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(BoxSigmaImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.BoxSigmaImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(BoxSigmaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.BoxSigmaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(BoxSigmaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.BoxSigmaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(BoxSigmaImageFilter self, Image image1) -> Image
        Execute(BoxSigmaImageFilter self, Image image1, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.BoxSigmaImageFilter_Execute(self, *args)

BoxSigmaImageFilter_swigregister = _SimpleITK.BoxSigmaImageFilter_swigregister
BoxSigmaImageFilter_swigregister(BoxSigmaImageFilter)


def BoxSigma(*args, **kwargs):
    """
    BoxSigma(Image image1, VectorUInt32 radius) -> Image



    Implements a fast rectangular sigma filter using the accumulator
    approach.


    This function directly calls the execute method of BoxSigmaImageFilter in order to support a procedural API


    See:
     itk::simple::BoxSigmaImageFilter for the object oriented interface



    """
    return _SimpleITK.BoxSigma(*args, **kwargs)
class CannyEdgeDetectionImageFilter(ImageFilter_1):
    """


    This filter is an implementation of a Canny edge detector for scalar-
    valued images.


    Based on John Canny's paper "A Computational Approach to Edge
    Detection"(IEEE Transactions on Pattern Analysis and Machine
    Intelligence, Vol. PAMI-8, No.6, November 1986), there are four major
    steps used in the edge-detection scheme: (1) Smooth the input image
    with Gaussian filter. (2) Calculate the second directional derivatives
    of the smoothed image. (3) Non-Maximum Suppression: the zero-crossings
    of 2nd derivative are found, and the sign of third derivative is used
    to find the correct extrema. (4) The hysteresis thresholding is
    applied to the gradient magnitude (multiplied with zero-crossings) of
    the smoothed image to find and link edges.

    Inputs and Outputs
    The input to this filter should be a scalar, real-valued Itk image of
    arbitrary dimension. The output should also be a scalar, real-value
    Itk image of the same dimensionality.
    Parameters
    There are four parameters for this filter that control the sub-filters
    used by the algorithm.

    Variance and Maximum error are used in the Gaussian smoothing of the
    input image. See itkDiscreteGaussianImageFilter for information on
    these parameters.

    Threshold is the lowest allowed value in the output image. Its data
    type is the same as the data type of the output image. Any values
    below the Threshold level will be replaced with the OutsideValue
    parameter value, whose default is zero.
     TodoEdge-linking will be added when an itk connected component
    labeling algorithm is available.


    See:
     DiscreteGaussianImageFilter

     ZeroCrossingImageFilter

     ThresholdImageFilter

     itk::simple::CannyEdgeDetection for the procedural interface

     itk::CannyEdgeDetectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCannyEdgeDetectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CannyEdgeDetectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CannyEdgeDetectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CannyEdgeDetectionImageFilter self) -> CannyEdgeDetectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CannyEdgeDetectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CannyEdgeDetectionImageFilter
    __del__ = lambda self: None

    def SetLowerThreshold(self, LowerThreshold):
        """
        SetLowerThreshold(CannyEdgeDetectionImageFilter self, double LowerThreshold)



        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetLowerThreshold(self, LowerThreshold)


    def GetLowerThreshold(self):
        """
        GetLowerThreshold(CannyEdgeDetectionImageFilter self) -> double



        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetLowerThreshold(self)


    def SetUpperThreshold(self, UpperThreshold):
        """
        SetUpperThreshold(CannyEdgeDetectionImageFilter self, double UpperThreshold)



        Set the Threshold value for detected edges. TODO: Document in the
        ITKv4 migration guide that the SetThreshold member function was
        removed from the CannyEdgeDetectionImageFilter , and that both UpperThreshold and LowerThreshold need to be set. To
        get the same results as with the SetThreshold method change
        "myfilter->SetThrehsold" to "myfilter->SetUpperThreshold", and add
        "myfilter->SetLowerThreshold(GetUpperThreshold()/2.0)".


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetUpperThreshold(self, UpperThreshold)


    def GetUpperThreshold(self):
        """
        GetUpperThreshold(CannyEdgeDetectionImageFilter self) -> double



        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetUpperThreshold(self)


    def SetVariance(self, *args):
        """
        SetVariance(CannyEdgeDetectionImageFilter self, VectorDouble Variance)
        SetVariance(CannyEdgeDetectionImageFilter self, double value)



        Set the values of the Variance vector all to value


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetVariance(self, *args)


    def GetVariance(self):
        """
        GetVariance(CannyEdgeDetectionImageFilter self) -> VectorDouble



        Standard get/set macros for filter parameters.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetVariance(self)


    def SetMaximumError(self, *args):
        """
        SetMaximumError(CannyEdgeDetectionImageFilter self, VectorDouble MaximumError)
        SetMaximumError(CannyEdgeDetectionImageFilter self, double value)



        Set the values of the MaximumError vector all to value


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_SetMaximumError(self, *args)


    def GetMaximumError(self):
        """
        GetMaximumError(CannyEdgeDetectionImageFilter self) -> VectorDouble



        Standard get/set macros for filter parameters.


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetMaximumError(self)


    def GetName(self):
        """
        GetName(CannyEdgeDetectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CannyEdgeDetectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CannyEdgeDetectionImageFilter self, Image image1) -> Image
        Execute(CannyEdgeDetectionImageFilter self, Image image1, double lowerThreshold, double upperThreshold, VectorDouble variance, VectorDouble maximumError) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CannyEdgeDetectionImageFilter_Execute(self, *args)

CannyEdgeDetectionImageFilter_swigregister = _SimpleITK.CannyEdgeDetectionImageFilter_swigregister
CannyEdgeDetectionImageFilter_swigregister(CannyEdgeDetectionImageFilter)


def CannyEdgeDetection(*args, **kwargs):
    """
    CannyEdgeDetection(Image image1, double lowerThreshold=0.0, double upperThreshold=0.0, VectorDouble variance, VectorDouble maximumError) -> Image



    This filter is an implementation of a Canny edge detector for scalar-
    valued images.


    This function directly calls the execute method of CannyEdgeDetectionImageFilter in order to support a procedural API


    See:
     itk::simple::CannyEdgeDetectionImageFilter for the object oriented interface



    """
    return _SimpleITK.CannyEdgeDetection(*args, **kwargs)
class ChangeLabelImageFilter(ImageFilter_1):
    """


    Change Sets of Labels.


    This filter produces an output image whose pixels are either copied
    from the input if they are not being changed or are rewritten based on
    the change parameters

    This filter is templated over the input image type and the output
    image type.

    The filter expect both images to have the same number of dimensions.


    Tim Kelliher. GE Research, Niskayuna, NY.

    This work was supported by a grant from DARPA, executed by the U.S.
    Army Medical Research and Materiel Command/TATRC Assistance Agreement,
    Contract::W81XWH-05-2-0059.

    See:
     itk::simple::ChangeLabel for the procedural interface

     itk::ChangeLabelImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkChangeLabelImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChangeLabelImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChangeLabelImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ChangeLabelImageFilter self) -> ChangeLabelImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ChangeLabelImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ChangeLabelImageFilter
    __del__ = lambda self: None

    def SetChangeMap(self, ChangeMap):
        """
        SetChangeMap(ChangeLabelImageFilter self, DoubleDoubleMap ChangeMap)



        Set the entire change map


        """
        return _SimpleITK.ChangeLabelImageFilter_SetChangeMap(self, ChangeMap)


    def GetChangeMap(self):
        """
        GetChangeMap(ChangeLabelImageFilter self) -> DoubleDoubleMap



        """
        return _SimpleITK.ChangeLabelImageFilter_GetChangeMap(self)


    def GetName(self):
        """
        GetName(ChangeLabelImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ChangeLabelImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ChangeLabelImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ChangeLabelImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ChangeLabelImageFilter self, Image image1) -> Image
        Execute(ChangeLabelImageFilter self, Image image1, DoubleDoubleMap changeMap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ChangeLabelImageFilter_Execute(self, *args)

ChangeLabelImageFilter_swigregister = _SimpleITK.ChangeLabelImageFilter_swigregister
ChangeLabelImageFilter_swigregister(ChangeLabelImageFilter)


def ChangeLabel(*args, **kwargs):
    """
    ChangeLabel(Image image1, DoubleDoubleMap changeMap) -> Image



    Change Sets of Labels.


    This function directly calls the execute method of ChangeLabelImageFilter in order to support a procedural API


    See:
     itk::simple::ChangeLabelImageFilter for the object oriented interface



    """
    return _SimpleITK.ChangeLabel(*args, **kwargs)
class ChangeLabelLabelMapFilter(ImageFilter_1):
    """


    Replace the label Ids of selected LabelObjects with new label Ids.


    This filter takes as input a label map and a list of pairs of Label
    Ids, to produce as output a new label map where the label Ids have
    been replaced according to the pairs in the list.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::ChangeLabelLabelMapFilter for the procedural interface

     itk::ChangeLabelLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkChangeLabelLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChangeLabelLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChangeLabelLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ChangeLabelLabelMapFilter self) -> ChangeLabelLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ChangeLabelLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ChangeLabelLabelMapFilter
    __del__ = lambda self: None

    def SetChangeMap(self, ChangeMap):
        """
        SetChangeMap(ChangeLabelLabelMapFilter self, DoubleDoubleMap ChangeMap)



        """
        return _SimpleITK.ChangeLabelLabelMapFilter_SetChangeMap(self, ChangeMap)


    def GetChangeMap(self):
        """
        GetChangeMap(ChangeLabelLabelMapFilter self) -> DoubleDoubleMap



        """
        return _SimpleITK.ChangeLabelLabelMapFilter_GetChangeMap(self)


    def GetName(self):
        """
        GetName(ChangeLabelLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ChangeLabelLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(ChangeLabelLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ChangeLabelLabelMapFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ChangeLabelLabelMapFilter self, Image image1) -> Image
        Execute(ChangeLabelLabelMapFilter self, Image image1, DoubleDoubleMap changeMap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ChangeLabelLabelMapFilter_Execute(self, *args)

ChangeLabelLabelMapFilter_swigregister = _SimpleITK.ChangeLabelLabelMapFilter_swigregister
ChangeLabelLabelMapFilter_swigregister(ChangeLabelLabelMapFilter)


def ChangeLabelLabelMap(*args, **kwargs):
    """
    ChangeLabelLabelMap(Image image1, DoubleDoubleMap changeMap) -> Image



    Replace the label Ids of selected LabelObjects with new label Ids.


    This function directly calls the execute method of ChangeLabelLabelMapFilter in order to support a procedural API


    See:
     itk::simple::ChangeLabelLabelMapFilter for the object oriented interface



    """
    return _SimpleITK.ChangeLabelLabelMap(*args, **kwargs)
class CheckerBoardImageFilter(ImageFilter_2):
    """


    Combines two images in a checkerboard pattern.


    CheckerBoardImageFilter takes two input images that must have the same dimension, size,
    origin and spacing and produces an output image of the same size by
    combinining the pixels from the two input images in a checkerboard
    pattern. This filter is commonly used for visually comparing two
    images, in particular for evaluating the results of an image
    registration process.

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.

    Wiki Examples:

    All Examples

    Combine two images by alternating blocks of a checkerboard pattern
    See:
     itk::simple::CheckerBoard for the procedural interface

     itk::CheckerBoardImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkCheckerBoardImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CheckerBoardImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CheckerBoardImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CheckerBoardImageFilter self) -> CheckerBoardImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CheckerBoardImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CheckerBoardImageFilter
    __del__ = lambda self: None

    def SetCheckerPattern(self, *args):
        """
        SetCheckerPattern(CheckerBoardImageFilter self, VectorUInt32 CheckerPattern)
        SetCheckerPattern(CheckerBoardImageFilter self, uint32_t value)



        Set the values of the CheckerPattern vector all to value


        """
        return _SimpleITK.CheckerBoardImageFilter_SetCheckerPattern(self, *args)


    def GetCheckerPattern(self):
        """
        GetCheckerPattern(CheckerBoardImageFilter self) -> VectorUInt32



        Set/Get the checker pattern array, i.e. the number of checker boxes
        per image dimension.


        """
        return _SimpleITK.CheckerBoardImageFilter_GetCheckerPattern(self)


    def GetName(self):
        """
        GetName(CheckerBoardImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CheckerBoardImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CheckerBoardImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CheckerBoardImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CheckerBoardImageFilter self, Image image1, Image image2) -> Image
        Execute(CheckerBoardImageFilter self, Image image1, Image image2, VectorUInt32 checkerPattern) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.CheckerBoardImageFilter_Execute(self, *args)

CheckerBoardImageFilter_swigregister = _SimpleITK.CheckerBoardImageFilter_swigregister
CheckerBoardImageFilter_swigregister(CheckerBoardImageFilter)


def CheckerBoard(*args, **kwargs):
    """
    CheckerBoard(Image image1, Image image2, VectorUInt32 checkerPattern) -> Image



    Combines two images in a checkerboard pattern.


    This function directly calls the execute method of CheckerBoardImageFilter in order to support a procedural API


    See:
     itk::simple::CheckerBoardImageFilter for the object oriented interface



    """
    return _SimpleITK.CheckerBoard(*args, **kwargs)
class ClampImageFilter(ImageFilter_1):
    """


    Casts input pixels to output pixel type and clamps the output pixel
    values to a specified range.


    Default range corresponds to the range supported by the pixel type of
    the output image.

    This filter is templated over the input image type and the output
    image type.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     UnaryFunctorImageFilter

     CastImageFilter
    Wiki Examples:

    All Examples

    Cast an image from one type to another but clamp to the output value
    range
    See:
     itk::simple::Clamp for the procedural interface

     itk::ClampImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkClampImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClampImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClampImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ClampImageFilter self) -> ClampImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ClampImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ClampImageFilter
    __del__ = lambda self: None

    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(ClampImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)



        """
        return _SimpleITK.ClampImageFilter_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(ClampImageFilter self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.ClampImageFilter_GetOutputPixelType(self)


    def SetLowerBound(self, LowerBound):
        """
        SetLowerBound(ClampImageFilter self, double LowerBound)



        """
        return _SimpleITK.ClampImageFilter_SetLowerBound(self, LowerBound)


    def GetLowerBound(self):
        """
        GetLowerBound(ClampImageFilter self) -> double



        """
        return _SimpleITK.ClampImageFilter_GetLowerBound(self)


    def SetUpperBound(self, UpperBound):
        """
        SetUpperBound(ClampImageFilter self, double UpperBound)



        """
        return _SimpleITK.ClampImageFilter_SetUpperBound(self, UpperBound)


    def GetUpperBound(self):
        """
        GetUpperBound(ClampImageFilter self) -> double



        """
        return _SimpleITK.ClampImageFilter_GetUpperBound(self)


    def GetName(self):
        """
        GetName(ClampImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ClampImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ClampImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ClampImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ClampImageFilter self, Image image1) -> Image
        Execute(ClampImageFilter self, Image image1, itk::simple::PixelIDValueEnum outputPixelType, double lowerBound, double upperBound) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ClampImageFilter_Execute(self, *args)

ClampImageFilter_swigregister = _SimpleITK.ClampImageFilter_swigregister
ClampImageFilter_swigregister(ClampImageFilter)


def Clamp(*args, **kwargs):
    """
    Clamp(Image image1, itk::simple::PixelIDValueEnum outputPixelType, double lowerBound, double upperBound) -> Image



    Casts input pixels to output pixel type and clamps the output pixel
    values to a specified range.


    This function directly calls the execute method of ClampImageFilter in order to support a procedural API


    See:
     itk::simple::ClampImageFilter for the object oriented interface



    """
    return _SimpleITK.Clamp(*args, **kwargs)
class ClosingByReconstructionImageFilter(ImageFilter_1):
    """


    Closing by reconstruction of an image.


    This filter is similar to the morphological closing, but contrary to
    the mophological closing, the closing by reconstruction preserves the
    shape of the components. The closing by reconstruction of an image
    "f" is defined as:

    ClosingByReconstruction(f) = ErosionByReconstruction(f, Dilation(f)).

    Closing by reconstruction not only preserves structures preserved by
    the dilation, but also levels raises the contrast of the darkest
    regions. If PreserveIntensities is on, a subsequent reconstruction by
    dilation using a marker image that is the original image for all
    unaffected pixels.

    Closing by reconstruction is described in Chapter 6.3.9 of Pierre
    Soille's book "Morphological Image Analysis: Principles and
    Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     GrayscaleMorphologicalClosingImageFilter

     itk::simple::ClosingByReconstruction for the procedural interface

     itk::ClosingByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkClosingByReconstructionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClosingByReconstructionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClosingByReconstructionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ClosingByReconstructionImageFilter self) -> ClosingByReconstructionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ClosingByReconstructionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ClosingByReconstructionImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.ClosingByReconstructionImageFilter_Annulus
    Ball = _SimpleITK.ClosingByReconstructionImageFilter_Ball
    Box = _SimpleITK.ClosingByReconstructionImageFilter_Box
    Cross = _SimpleITK.ClosingByReconstructionImageFilter_Cross

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ClosingByReconstructionImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ClosingByReconstructionImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ClosingByReconstructionImageFilter self)



        """
        return _SimpleITK.ClosingByReconstructionImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ClosingByReconstructionImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetFullyConnected(self)


    def SetPreserveIntensities(self, PreserveIntensities):
        """
        SetPreserveIntensities(ClosingByReconstructionImageFilter self, bool PreserveIntensities)



        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstrcution. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetPreserveIntensities(self, PreserveIntensities)


    def PreserveIntensitiesOn(self):
        """
        PreserveIntensitiesOn(ClosingByReconstructionImageFilter self)



        Set the value of PreserveIntensities to true or false respectfully.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_PreserveIntensitiesOn(self)


    def PreserveIntensitiesOff(self):
        """
        PreserveIntensitiesOff(ClosingByReconstructionImageFilter self)



        """
        return _SimpleITK.ClosingByReconstructionImageFilter_PreserveIntensitiesOff(self)


    def GetPreserveIntensities(self):
        """
        GetPreserveIntensities(ClosingByReconstructionImageFilter self) -> bool



        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstrcution. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetPreserveIntensities(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(ClosingByReconstructionImageFilter self, uint32_t r)
        SetKernelRadius(ClosingByReconstructionImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(ClosingByReconstructionImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(ClosingByReconstructionImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.ClosingByReconstructionImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(ClosingByReconstructionImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(ClosingByReconstructionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ClosingByReconstructionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ClosingByReconstructionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ClosingByReconstructionImageFilter self, Image image1) -> Image
        Execute(ClosingByReconstructionImageFilter self, Image image1, bool fullyConnected, bool preserveIntensities) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ClosingByReconstructionImageFilter_Execute(self, *args)

ClosingByReconstructionImageFilter_swigregister = _SimpleITK.ClosingByReconstructionImageFilter_swigregister
ClosingByReconstructionImageFilter_swigregister(ClosingByReconstructionImageFilter)


def ClosingByReconstruction(*args):
    """
    ClosingByReconstruction(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, bool fullyConnected=False, bool preserveIntensities=False) -> Image
    ClosingByReconstruction(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, bool fullyConnected=False, bool preserveIntensities=False) -> Image



    itk::simple::ClosingByReconstructionImageFilter Functional Interface

    This function directly calls the execute method of ClosingByReconstructionImageFilter in order to support a fully functional API


    """
    return _SimpleITK.ClosingByReconstruction(*args)
class CollidingFrontsImageFilter(ImageFilter_1):
    """


    Selects a region of space where two independent fronts run towards
    each other.


    The filter can be used to quickly segment anatomical structures (e.g.
    for level set initialization).

    The filter uses two instances of FastMarchingUpwindGradientImageFilter to compute the gradients of arrival times of two wavefronts
    propagating from two sets of seeds. The input of the filter is used as
    the speed of the two wavefronts. The output is the dot product between
    the two gradient vector fields.

    The filter works on the following basic idea. In the regions where the
    dot product between the two gradient fields is negative, the two
    fronts propagate in opposite directions. In the regions where the dot
    product is positive, the two fronts propagate in the same direction.
    This can be used to extract the region of space between two sets of
    points.

    If StopOnTargets is On, then each front will stop as soon as all seeds
    of the other front have been reached. This can markedly speed up the
    execution of the filter, since wave propagation does not take place on
    the complete image.

    Optionally, a connectivity criterion can be applied to the resulting
    dot product image. In this case, the only negative region in the
    output image is the one connected to the seeds.


    Luca Antiga Ph.D. Biomedical Technologies Laboratory, Bioengineering
    Department, Mario Negri Institute, Italy.

    See:
     itk::simple::CollidingFronts for the procedural interface

     itk::CollidingFrontsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCollidingFrontsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CollidingFrontsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CollidingFrontsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CollidingFrontsImageFilter self) -> CollidingFrontsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CollidingFrontsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CollidingFrontsImageFilter
    __del__ = lambda self: None

    def SetSeedPoints1(self, SeedPoints1):
        """
        SetSeedPoints1(CollidingFrontsImageFilter self, VectorUIntList SeedPoints1)



        Set the container of Seed Points representing the first initial front.
        Seed points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetSeedPoints1(self, SeedPoints1)


    def GetSeedPoints1(self):
        """
        GetSeedPoints1(CollidingFrontsImageFilter self) -> VectorUIntList



        Get the container of Seed Points representing the first initial front.


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetSeedPoints1(self)


    def AddSeedPoint1(self, point):
        """
        AddSeedPoint1(CollidingFrontsImageFilter self, VectorUInt32 point)



        Add SeedPoints1 point.


        """
        return _SimpleITK.CollidingFrontsImageFilter_AddSeedPoint1(self, point)


    def ClearSeedPoints1(self):
        """
        ClearSeedPoints1(CollidingFrontsImageFilter self)



        Remove all SeedPoints1 points.


        """
        return _SimpleITK.CollidingFrontsImageFilter_ClearSeedPoints1(self)


    def SetSeedPoints2(self, SeedPoints2):
        """
        SetSeedPoints2(CollidingFrontsImageFilter self, VectorUIntList SeedPoints2)



        Set the container of Seed Points representing the second initial
        front. Seed points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.CollidingFrontsImageFilter_SetSeedPoints2(self, SeedPoints2)


    def GetSeedPoints2(self):
        """
        GetSeedPoints2(CollidingFrontsImageFilter self) -> VectorUIntList



        Get the container of Seed Points representing the second initial
        front.


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetSeedPoints2(self)


    def AddSeedPoint2(self, point):
        """
        AddSeedPoint2(CollidingFrontsImageFilter self, VectorUInt32 point)



        Add SeedPoints2 point.


        """
        return _SimpleITK.CollidingFrontsImageFilter_AddSeedPoint2(self, point)


    def ClearSeedPoints2(self):
        """
        ClearSeedPoints2(CollidingFrontsImageFilter self)



        Remove all SeedPoints2 points.


        """
        return _SimpleITK.CollidingFrontsImageFilter_ClearSeedPoints2(self)


    def SetApplyConnectivity(self, ApplyConnectivity):
        """
        SetApplyConnectivity(CollidingFrontsImageFilter self, bool ApplyConnectivity)



        """
        return _SimpleITK.CollidingFrontsImageFilter_SetApplyConnectivity(self, ApplyConnectivity)


    def ApplyConnectivityOn(self):
        """
        ApplyConnectivityOn(CollidingFrontsImageFilter self)



        Set the value of ApplyConnectivity to true or false respectfully.


        """
        return _SimpleITK.CollidingFrontsImageFilter_ApplyConnectivityOn(self)


    def ApplyConnectivityOff(self):
        """
        ApplyConnectivityOff(CollidingFrontsImageFilter self)



        """
        return _SimpleITK.CollidingFrontsImageFilter_ApplyConnectivityOff(self)


    def GetApplyConnectivity(self):
        """
        GetApplyConnectivity(CollidingFrontsImageFilter self) -> bool



        """
        return _SimpleITK.CollidingFrontsImageFilter_GetApplyConnectivity(self)


    def SetNegativeEpsilon(self, NegativeEpsilon):
        """
        SetNegativeEpsilon(CollidingFrontsImageFilter self, double NegativeEpsilon)



        """
        return _SimpleITK.CollidingFrontsImageFilter_SetNegativeEpsilon(self, NegativeEpsilon)


    def GetNegativeEpsilon(self):
        """
        GetNegativeEpsilon(CollidingFrontsImageFilter self) -> double



        """
        return _SimpleITK.CollidingFrontsImageFilter_GetNegativeEpsilon(self)


    def SetStopOnTargets(self, StopOnTargets):
        """
        SetStopOnTargets(CollidingFrontsImageFilter self, bool StopOnTargets)



        """
        return _SimpleITK.CollidingFrontsImageFilter_SetStopOnTargets(self, StopOnTargets)


    def StopOnTargetsOn(self):
        """
        StopOnTargetsOn(CollidingFrontsImageFilter self)



        Set the value of StopOnTargets to true or false respectfully.


        """
        return _SimpleITK.CollidingFrontsImageFilter_StopOnTargetsOn(self)


    def StopOnTargetsOff(self):
        """
        StopOnTargetsOff(CollidingFrontsImageFilter self)



        """
        return _SimpleITK.CollidingFrontsImageFilter_StopOnTargetsOff(self)


    def GetStopOnTargets(self):
        """
        GetStopOnTargets(CollidingFrontsImageFilter self) -> bool



        """
        return _SimpleITK.CollidingFrontsImageFilter_GetStopOnTargets(self)


    def GetName(self):
        """
        GetName(CollidingFrontsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CollidingFrontsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CollidingFrontsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CollidingFrontsImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CollidingFrontsImageFilter self, Image image1) -> Image
        Execute(CollidingFrontsImageFilter self, Image image1, VectorUIntList seedPoints1, VectorUIntList seedPoints2, bool applyConnectivity, double negativeEpsilon, bool stopOnTargets) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CollidingFrontsImageFilter_Execute(self, *args)

CollidingFrontsImageFilter_swigregister = _SimpleITK.CollidingFrontsImageFilter_swigregister
CollidingFrontsImageFilter_swigregister(CollidingFrontsImageFilter)


def CollidingFronts(*args, **kwargs):
    """
    CollidingFronts(Image image1, VectorUIntList seedPoints1, VectorUIntList seedPoints2, bool applyConnectivity=True, double negativeEpsilon=-1e-6, bool stopOnTargets=False) -> Image



    Selects a region of space where two independent fronts run towards
    each other.


    This function directly calls the execute method of CollidingFrontsImageFilter in order to support a procedural API


    See:
     itk::simple::CollidingFrontsImageFilter for the object oriented interface



    """
    return _SimpleITK.CollidingFronts(*args, **kwargs)
class ComplexToImaginaryImageFilter(ImageFilter_1):
    """


    Computes pixel-wise the imaginary part of a complex image.



    See:
     itk::simple::ComplexToImaginary for the procedural interface

     itk::ComplexToImaginaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToImaginaryImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexToImaginaryImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexToImaginaryImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ComplexToImaginaryImageFilter self) -> ComplexToImaginaryImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ComplexToImaginaryImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ComplexToImaginaryImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ComplexToImaginaryImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ComplexToImaginaryImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ComplexToImaginaryImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ComplexToImaginaryImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ComplexToImaginaryImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToImaginaryImageFilter_Execute(self, image1)

ComplexToImaginaryImageFilter_swigregister = _SimpleITK.ComplexToImaginaryImageFilter_swigregister
ComplexToImaginaryImageFilter_swigregister(ComplexToImaginaryImageFilter)


def ComplexToImaginary(image1):
    """
    ComplexToImaginary(Image image1) -> Image



    Computes pixel-wise the imaginary part of a complex image.


    This function directly calls the execute method of ComplexToImaginaryImageFilter in order to support a procedural API


    See:
     itk::simple::ComplexToImaginaryImageFilter for the object oriented interface



    """
    return _SimpleITK.ComplexToImaginary(image1)
class ComplexToModulusImageFilter(ImageFilter_1):
    """


    Computes pixel-wise the Modulus of a complex image.



    See:
     itk::simple::ComplexToModulus for the procedural interface

     itk::ComplexToModulusImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToModulusImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexToModulusImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexToModulusImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ComplexToModulusImageFilter self) -> ComplexToModulusImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ComplexToModulusImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ComplexToModulusImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ComplexToModulusImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ComplexToModulusImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ComplexToModulusImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ComplexToModulusImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ComplexToModulusImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToModulusImageFilter_Execute(self, image1)

ComplexToModulusImageFilter_swigregister = _SimpleITK.ComplexToModulusImageFilter_swigregister
ComplexToModulusImageFilter_swigregister(ComplexToModulusImageFilter)


def ComplexToModulus(image1):
    """
    ComplexToModulus(Image image1) -> Image



    Computes pixel-wise the Modulus of a complex image.


    This function directly calls the execute method of ComplexToModulusImageFilter in order to support a procedural API


    See:
     itk::simple::ComplexToModulusImageFilter for the object oriented interface



    """
    return _SimpleITK.ComplexToModulus(image1)
class ComplexToPhaseImageFilter(ImageFilter_1):
    """


    Computes pixel-wise the modulus of a complex image.



    See:
     itk::simple::ComplexToPhase for the procedural interface

     itk::ComplexToPhaseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToPhaseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexToPhaseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexToPhaseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ComplexToPhaseImageFilter self) -> ComplexToPhaseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ComplexToPhaseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ComplexToPhaseImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ComplexToPhaseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ComplexToPhaseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ComplexToPhaseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ComplexToPhaseImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ComplexToPhaseImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToPhaseImageFilter_Execute(self, image1)

ComplexToPhaseImageFilter_swigregister = _SimpleITK.ComplexToPhaseImageFilter_swigregister
ComplexToPhaseImageFilter_swigregister(ComplexToPhaseImageFilter)


def ComplexToPhase(image1):
    """
    ComplexToPhase(Image image1) -> Image



    Computes pixel-wise the modulus of a complex image.


    This function directly calls the execute method of ComplexToPhaseImageFilter in order to support a procedural API


    See:
     itk::simple::ComplexToPhaseImageFilter for the object oriented interface



    """
    return _SimpleITK.ComplexToPhase(image1)
class ComplexToRealImageFilter(ImageFilter_1):
    """


    Computes pixel-wise the real(x) part of a complex image.



    See:
     itk::simple::ComplexToReal for the procedural interface

     itk::ComplexToRealImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkComplexToRealImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexToRealImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexToRealImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ComplexToRealImageFilter self) -> ComplexToRealImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ComplexToRealImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ComplexToRealImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ComplexToRealImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ComplexToRealImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ComplexToRealImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ComplexToRealImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ComplexToRealImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ComplexToRealImageFilter_Execute(self, image1)

ComplexToRealImageFilter_swigregister = _SimpleITK.ComplexToRealImageFilter_swigregister
ComplexToRealImageFilter_swigregister(ComplexToRealImageFilter)


def ComplexToReal(image1):
    """
    ComplexToReal(Image image1) -> Image



    Computes pixel-wise the real(x) part of a complex image.


    This function directly calls the execute method of ComplexToRealImageFilter in order to support a procedural API


    See:
     itk::simple::ComplexToRealImageFilter for the object oriented interface



    """
    return _SimpleITK.ComplexToReal(image1)
class ComposeImageFilter(ImageFilter_3):
    """


    ComposeImageFilter combine several scalar images into a multicomponent image.


    ComposeImageFilter combine several scalar images into an itk::Image of vector pixel ( itk::Vector , itk::RGBPixel , ...), of std::complex pixel, or in an itk::VectorImage .

    Inputs and Usage
     All input images are expected to have the same template parameters
    and have the same size and origin.

    See:
     VectorImage

     VectorIndexSelectionCastImageFilter
    Wiki Examples:

    All Examples

    Create a vector image from a collection of scalar images

    Compose a vector image (with 3 components) from three scalar images

    Convert a real image and an imaginary image to a complex image

    See:
     itk::simple::Compose for the procedural interface


    C++ includes: sitkComposeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComposeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComposeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ComposeImageFilter self) -> ComposeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ComposeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ComposeImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ComposeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ComposeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ComposeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ComposeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ComposeImageFilter self, VectorOfImage images) -> Image
        Execute(ComposeImageFilter self, Image image1) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(ComposeImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image



        """
        return _SimpleITK.ComposeImageFilter_Execute(self, *args)

ComposeImageFilter_swigregister = _SimpleITK.ComposeImageFilter_swigregister
ComposeImageFilter_swigregister(ComposeImageFilter)


def Compose(*args):
    """
    Compose(VectorOfImage images) -> Image
    Compose(Image image1) -> Image
    Compose(Image image1, Image image2) -> Image
    Compose(Image image1, Image image2, Image image3) -> Image
    Compose(Image image1, Image image2, Image image3, Image image4) -> Image
    Compose(Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
    """
    return _SimpleITK.Compose(*args)
class ConfidenceConnectedImageFilter(ImageFilter_1):
    """


    Segment pixels with similar statistics using connectivity.


    This filter extracts a connected set of pixels whose pixel intensities
    are consistent with the pixel statistics of a seed point. The mean and
    variance across a neighborhood (8-connected, 26-connected, etc.) are
    calculated for a seed point. Then pixels connected to this seed point
    whose values are within the confidence interval for the seed point are
    grouped. The width of the confidence interval is controlled by the
    "Multiplier" variable (the confidence interval is the mean plus or
    minus the "Multiplier" times the standard deviation). If the
    intensity variations across a segment were gaussian, a "Multiplier"
    setting of 2.5 would define a confidence interval wide enough to
    capture 99% of samples in the segment.

    After this initial segmentation is calculated, the mean and variance
    are re-calculated. All the pixels in the previous segmentation are
    used to calculate the mean the standard deviation (as opposed to using
    the pixels in the neighborhood of the seed point). The segmentation is
    then recalculated using these refined estimates for the mean and
    variance of the pixel values. This process is repeated for the
    specified number of iterations. Setting the "NumberOfIterations" to
    zero stops the algorithm after the initial segmentation from the seed
    point.

    NOTE: the lower and upper threshold are restricted to lie within the
    valid numeric limits of the input data pixel type. Also, the limits
    may be adjusted to contain the seed point's intensity.

    Wiki Examples:

    All Examples

    Segment pixels with similar statistics using connectivity
    See:
     itk::simple::ConfidenceConnected for the procedural interface

     itk::ConfidenceConnectedImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkConfidenceConnectedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConfidenceConnectedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConfidenceConnectedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ConfidenceConnectedImageFilter self) -> ConfidenceConnectedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ConfidenceConnectedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ConfidenceConnectedImageFilter
    __del__ = lambda self: None

    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(ConfidenceConnectedImageFilter self, unsigned int NumberOfIterations)



        Set/Get the number of iterations


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(ConfidenceConnectedImageFilter self) -> unsigned int



        Set/Get the number of iterations


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetNumberOfIterations(self)


    def SetMultiplier(self, Multiplier):
        """
        SetMultiplier(ConfidenceConnectedImageFilter self, double Multiplier)



        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetMultiplier(self, Multiplier)


    def GetMultiplier(self):
        """
        GetMultiplier(ConfidenceConnectedImageFilter self) -> double



        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetMultiplier(self)


    def SetInitialNeighborhoodRadius(self, InitialNeighborhoodRadius):
        """
        SetInitialNeighborhoodRadius(ConfidenceConnectedImageFilter self, unsigned int InitialNeighborhoodRadius)



        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetInitialNeighborhoodRadius(self, InitialNeighborhoodRadius)


    def GetInitialNeighborhoodRadius(self):
        """
        GetInitialNeighborhoodRadius(ConfidenceConnectedImageFilter self) -> unsigned int



        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetInitialNeighborhoodRadius(self)


    def SetReplaceValue(self, ReplaceValue):
        """
        SetReplaceValue(ConfidenceConnectedImageFilter self, uint8_t ReplaceValue)



        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetReplaceValue(self, ReplaceValue)


    def GetReplaceValue(self):
        """
        GetReplaceValue(ConfidenceConnectedImageFilter self) -> uint8_t



        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetReplaceValue(self)


    def GetMean(self):
        """
        GetMean(ConfidenceConnectedImageFilter self) -> double



        Method to get access to the mean of the pixels accepted in the output
        region. This method should only be invoked after the filter has been
        executed using the Update() method.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetMean(self)


    def GetVariance(self):
        """
        GetVariance(ConfidenceConnectedImageFilter self) -> double



        Method to get access to the variance of the pixels accepted in the
        output region. This method should only be invoked after the filter has
        been executed using the Update() method.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetVariance(self)


    def SetSeedList(self, t):
        """
        SetSeedList(ConfidenceConnectedImageFilter self, VectorUIntList t)



        Set SeedList


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetSeedList(self, t)


    def GetSeedList(self):
        """
        GetSeedList(ConfidenceConnectedImageFilter self) -> VectorUIntList



        Get SeedList


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetSeedList(self)


    def ClearSeeds(self):
        """
        ClearSeeds(ConfidenceConnectedImageFilter self)



        ClearSeeds - Clear out all seeds in the list


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_ClearSeeds(self)


    def SetSeed(self, idx):
        """
        SetSeed(ConfidenceConnectedImageFilter self, VectorUInt32 idx)



        SetSeed - Set list to a single seed


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_SetSeed(self, idx)


    def AddSeed(self, idx):
        """
        AddSeed(ConfidenceConnectedImageFilter self, VectorUInt32 idx)



        AddSeed - Add a seed to the end of the list


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_AddSeed(self, idx)


    def GetName(self):
        """
        GetName(ConfidenceConnectedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ConfidenceConnectedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ConfidenceConnectedImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ConfidenceConnectedImageFilter self, Image image1) -> Image
        Execute(ConfidenceConnectedImageFilter self, Image image1, VectorUIntList seedList, unsigned int numberOfIterations, double multiplier, unsigned int initialNeighborhoodRadius, uint8_t replaceValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ConfidenceConnectedImageFilter_Execute(self, *args)

ConfidenceConnectedImageFilter_swigregister = _SimpleITK.ConfidenceConnectedImageFilter_swigregister
ConfidenceConnectedImageFilter_swigregister(ConfidenceConnectedImageFilter)


def ConfidenceConnected(image1, seedList, numberOfIterations=4, multiplier=4.5, initialNeighborhoodRadius=1, replaceValue=1):
    """
    ConfidenceConnected(Image image1, VectorUIntList seedList, unsigned int numberOfIterations=4, double multiplier=4.5, unsigned int initialNeighborhoodRadius=1, uint8_t replaceValue=1) -> Image



    itk::simple::ConfidenceConnectedImageFilter Functional Interface

    This function directly calls the execute method of ConfidenceConnectedImageFilter in order to support a fully functional API


    """
    return _SimpleITK.ConfidenceConnected(image1, seedList, numberOfIterations, multiplier, initialNeighborhoodRadius, replaceValue)
class ConnectedComponentImageFilter(ImageFilter_1):
    """


    Label the objects in a binary image.


    ConnectedComponentImageFilter labels the objects in a binary image (non-zero pixels are considered
    to be objects, zero-valued pixels are considered to be background).
    Each distinct object is assigned a unique label. The filter
    experiments with some improvements to the existing implementation, and
    is based on run length encoding along raster lines. The final object
    labels start with 1 and are consecutive. Objects that are reached
    earlier by a raster order scan have a lower label. This is different
    to the behaviour of the original connected component image filter
    which did not produce consecutive labels or impose any particular
    ordering.

    After the filter is executed, ObjectCount holds the number of
    connected components.


    See:
     ImageToImageFilter
    Wiki Examples:

    All Examples

    Label connected components in a binary image
    See:
     itk::simple::ConnectedComponent for the procedural interface

     itk::ConnectedComponentImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkConnectedComponentImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectedComponentImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectedComponentImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ConnectedComponentImageFilter self) -> ConnectedComponentImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ConnectedComponentImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ConnectedComponentImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ConnectedComponentImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ConnectedComponentImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ConnectedComponentImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ConnectedComponentImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ConnectedComponentImageFilter self)



        """
        return _SimpleITK.ConnectedComponentImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ConnectedComponentImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.ConnectedComponentImageFilter_GetFullyConnected(self)


    def GetObjectCount(self):
        """
        GetObjectCount(ConnectedComponentImageFilter self) -> uint32_t



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ConnectedComponentImageFilter_GetObjectCount(self)


    def GetName(self):
        """
        GetName(ConnectedComponentImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ConnectedComponentImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ConnectedComponentImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ConnectedComponentImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ConnectedComponentImageFilter self, Image image1) -> Image
        Execute(ConnectedComponentImageFilter self, Image image1, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ConnectedComponentImageFilter_Execute(self, *args)

ConnectedComponentImageFilter_swigregister = _SimpleITK.ConnectedComponentImageFilter_swigregister
ConnectedComponentImageFilter_swigregister(ConnectedComponentImageFilter)


def ConnectedComponent(image1, fullyConnected=False):
    """
    ConnectedComponent(Image image1, bool fullyConnected=False) -> Image



    Label the objects in a binary image.


    This function directly calls the execute method of ConnectedComponentImageFilter in order to support a procedural API


    See:
     itk::simple::ConnectedComponentImageFilter for the object oriented interface



    """
    return _SimpleITK.ConnectedComponent(image1, fullyConnected)
class ConnectedThresholdImageFilter(ImageFilter_1):
    """


    Label pixels that are connected to a seed and lie within a range of
    values.


    ConnectedThresholdImageFilter labels pixels with ReplaceValue that are connected to an initial Seed
    AND lie within a Lower and Upper threshold range.
    See:
     itk::simple::ConnectedThreshold for the procedural interface

     itk::ConnectedThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkConnectedThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectedThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectedThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ConnectedThresholdImageFilter self) -> ConnectedThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ConnectedThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ConnectedThresholdImageFilter
    __del__ = lambda self: None

    def SetLower(self, Lower):
        """
        SetLower(ConnectedThresholdImageFilter self, double Lower)



        Set Upper and Lower Threshold inputs as values


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetLower(self, Lower)


    def GetLower(self):
        """
        GetLower(ConnectedThresholdImageFilter self) -> double



        Get Upper and Lower Threshold inputs as values.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetLower(self)


    def SetUpper(self, Upper):
        """
        SetUpper(ConnectedThresholdImageFilter self, double Upper)



        Set Upper and Lower Threshold inputs as values


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetUpper(self, Upper)


    def GetUpper(self):
        """
        GetUpper(ConnectedThresholdImageFilter self) -> double



        Get Upper and Lower Threshold inputs as values.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetUpper(self)


    def SetReplaceValue(self, ReplaceValue):
        """
        SetReplaceValue(ConnectedThresholdImageFilter self, uint8_t ReplaceValue)



        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetReplaceValue(self, ReplaceValue)


    def GetReplaceValue(self):
        """
        GetReplaceValue(ConnectedThresholdImageFilter self) -> uint8_t



        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetReplaceValue(self)

    FaceConnectivity = _SimpleITK.ConnectedThresholdImageFilter_FaceConnectivity
    FullConnectivity = _SimpleITK.ConnectedThresholdImageFilter_FullConnectivity

    def SetConnectivity(self, Connectivity):
        """
        SetConnectivity(ConnectedThresholdImageFilter self, itk::simple::ConnectedThresholdImageFilter::ConnectivityType Connectivity)



        Type of connectivity to use (fully connected OR 4(2D), 6(3D), 2*N(ND)
        connectivity).


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetConnectivity(self, Connectivity)


    def GetConnectivity(self):
        """
        GetConnectivity(ConnectedThresholdImageFilter self) -> itk::simple::ConnectedThresholdImageFilter::ConnectivityType



        Type of connectivity to use (fully connected OR 4(2D), 6(3D), 2*N(ND)
        connectivity).


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetConnectivity(self)


    def SetSeedList(self, t):
        """
        SetSeedList(ConnectedThresholdImageFilter self, VectorUIntList t)



        Set SeedList


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetSeedList(self, t)


    def GetSeedList(self):
        """
        GetSeedList(ConnectedThresholdImageFilter self) -> VectorUIntList



        Get SeedList


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetSeedList(self)


    def ClearSeeds(self):
        """
        ClearSeeds(ConnectedThresholdImageFilter self)



        ClearSeeds - Clear out all seeds in the list


        """
        return _SimpleITK.ConnectedThresholdImageFilter_ClearSeeds(self)


    def SetSeed(self, idx):
        """
        SetSeed(ConnectedThresholdImageFilter self, VectorUInt32 idx)



        SetSeed - Set list to a single seed


        """
        return _SimpleITK.ConnectedThresholdImageFilter_SetSeed(self, idx)


    def AddSeed(self, idx):
        """
        AddSeed(ConnectedThresholdImageFilter self, VectorUInt32 idx)



        AddSeed - Add a seed to the end of the list


        """
        return _SimpleITK.ConnectedThresholdImageFilter_AddSeed(self, idx)


    def GetName(self):
        """
        GetName(ConnectedThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ConnectedThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ConnectedThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ConnectedThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ConnectedThresholdImageFilter self, Image image1) -> Image
        Execute(ConnectedThresholdImageFilter self, Image image1, VectorUIntList seedList, double lower, double upper, uint8_t replaceValue, itk::simple::ConnectedThresholdImageFilter::ConnectivityType connectivity) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ConnectedThresholdImageFilter_Execute(self, *args)

ConnectedThresholdImageFilter_swigregister = _SimpleITK.ConnectedThresholdImageFilter_swigregister
ConnectedThresholdImageFilter_swigregister(ConnectedThresholdImageFilter)


def ConnectedThreshold(*args, **kwargs):
    """
    ConnectedThreshold(Image image1, VectorUIntList seedList, double lower=0, double upper=1, uint8_t replaceValue=1, itk::simple::ConnectedThresholdImageFilter::ConnectivityType connectivity) -> Image



    itk::simple::ConnectedThresholdImageFilter Functional Interface

    This function directly calls the execute method of ConnectedThresholdImageFilter in order to support a fully functional API


    """
    return _SimpleITK.ConnectedThreshold(*args, **kwargs)
class ConstantPadImageFilter(ImageFilter_1):
    """


    Increase the image size by padding with a constant value.


    ConstantPadImageFilter changes the output image region. If the output image region is larger
    than the input image region, the extra pixels are filled in by a
    constant value. The output image region must be specified.

    Visual explanation of padding regions. This filter is implemented as a
    multithreaded filter. It provides a ThreadedGenerateData() method for
    its implementation.


    See:
     WrapPadImageFilter , MirrorPadImageFilter
    Wiki Examples:

    All Examples

    Pad an image with a constant value
    See:
     itk::simple::ConstantPad for the procedural interface

     itk::ConstantPadImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkConstantPadImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstantPadImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstantPadImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ConstantPadImageFilter self) -> ConstantPadImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ConstantPadImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ConstantPadImageFilter
    __del__ = lambda self: None

    def SetPadLowerBound(self, PadLowerBound):
        """
        SetPadLowerBound(ConstantPadImageFilter self, VectorUInt32 PadLowerBound)



        """
        return _SimpleITK.ConstantPadImageFilter_SetPadLowerBound(self, PadLowerBound)


    def GetPadLowerBound(self):
        """
        GetPadLowerBound(ConstantPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ConstantPadImageFilter_GetPadLowerBound(self)


    def SetPadUpperBound(self, PadUpperBound):
        """
        SetPadUpperBound(ConstantPadImageFilter self, VectorUInt32 PadUpperBound)



        """
        return _SimpleITK.ConstantPadImageFilter_SetPadUpperBound(self, PadUpperBound)


    def GetPadUpperBound(self):
        """
        GetPadUpperBound(ConstantPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ConstantPadImageFilter_GetPadUpperBound(self)


    def SetConstant(self, Constant):
        """
        SetConstant(ConstantPadImageFilter self, double Constant)



        Set/Get the pad value. Default is Zero.


        """
        return _SimpleITK.ConstantPadImageFilter_SetConstant(self, Constant)


    def GetConstant(self):
        """
        GetConstant(ConstantPadImageFilter self) -> double



        Set/Get the pad value. Default is Zero.


        """
        return _SimpleITK.ConstantPadImageFilter_GetConstant(self)


    def GetName(self):
        """
        GetName(ConstantPadImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ConstantPadImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ConstantPadImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ConstantPadImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ConstantPadImageFilter self, Image image1) -> Image
        Execute(ConstantPadImageFilter self, Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound, double constant) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ConstantPadImageFilter_Execute(self, *args)

ConstantPadImageFilter_swigregister = _SimpleITK.ConstantPadImageFilter_swigregister
ConstantPadImageFilter_swigregister(ConstantPadImageFilter)


def ConstantPad(*args, **kwargs):
    """
    ConstantPad(Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound, double constant=0.0) -> Image



    Increase the image size by padding with a constant value.


    This function directly calls the execute method of ConstantPadImageFilter in order to support a procedural API


    See:
     itk::simple::ConstantPadImageFilter for the object oriented interface



    """
    return _SimpleITK.ConstantPad(*args, **kwargs)
class ConvolutionImageFilter(ImageFilter_2):
    """


    Convolve a given image with an arbitrary image kernel.


    This filter operates by centering the flipped kernel at each pixel in
    the image and computing the inner product between pixel values in the
    image and pixel values in the kernel. The center of the kernel is
    defined as $ \\lfloor (2*i+s-1)/2 \\rfloor $ where $i$ is the index and $s$ is the size of the largest possible region of the kernel image. For
    kernels with odd sizes in all dimensions, this corresponds to the
    center pixel. If a dimension of the kernel image has an even size,
    then the center index of the kernel in that dimension will be the
    largest integral index that is less than the continuous index of the
    image center.

    The kernel can optionally be normalized to sum to 1 using NormalizeOn() . Normalization is off by default.


    WARNING:
    This filter ignores the spacing, origin, and orientation of the kernel
    image and treats them as identical to those in the input image.
     This code was contributed in the Insight Journal paper:

    "Image Kernel Convolution" by Tustison N., Gee J. https://hdl.handle.net/1926/1323 http://www.insight-journal.org/browse/publication/208


    Nicholas J. Tustison
     James C. Gee

    Wiki Examples:

    All Examples

    Convolve an image with a kernel
    See:
     itk::simple::Convolution for the procedural interface

     itk::ConvolutionImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkConvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ConvolutionImageFilter self) -> ConvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ConvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ConvolutionImageFilter
    __del__ = lambda self: None

    def SetNormalize(self, Normalize):
        """
        SetNormalize(ConvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.ConvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(ConvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.ConvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(ConvolutionImageFilter self)



        """
        return _SimpleITK.ConvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(ConvolutionImageFilter self) -> bool



        """
        return _SimpleITK.ConvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.ConvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.ConvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.ConvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(ConvolutionImageFilter self, itk::simple::ConvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.ConvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(ConvolutionImageFilter self) -> itk::simple::ConvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.ConvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.ConvolutionImageFilter_SAME
    VALID = _SimpleITK.ConvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(ConvolutionImageFilter self, itk::simple::ConvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.ConvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(ConvolutionImageFilter self) -> itk::simple::ConvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.ConvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(ConvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ConvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ConvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ConvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ConvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(ConvolutionImageFilter self, Image image1, Image image2, bool normalize, itk::simple::ConvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::ConvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ConvolutionImageFilter_Execute(self, *args)

ConvolutionImageFilter_swigregister = _SimpleITK.ConvolutionImageFilter_swigregister
ConvolutionImageFilter_swigregister(ConvolutionImageFilter)


def Convolution(*args, **kwargs):
    """
    Convolution(Image image1, Image image2, bool normalize=False, itk::simple::ConvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::ConvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    Convolve a given image with an arbitrary image kernel.


    This function directly calls the execute method of ConvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::ConvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.Convolution(*args, **kwargs)
class CosImageFilter(ImageFilter_1):
    """


    Computes the cosine of each pixel.


    This filter is templated over the pixel type of the input image and
    the pixel type of the output image.

    The filter walks over all of the pixels in the input image, and for
    each pixel does the following:


    cast the pixel value to double ,

    apply the std::cos() function to the double value,

    cast the double value resulting from std::cos() to the pixel type of
    the output image,

    store the cast value into the output image.
     The filter expects both images to have the same dimension (e.g. both
    2D, or both 3D, or both ND)
    See:
     itk::simple::Cos for the procedural interface

     itk::CosImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCosImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CosImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CosImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CosImageFilter self) -> CosImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CosImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CosImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(CosImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CosImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CosImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CosImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(CosImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.CosImageFilter_Execute(self, image1)

CosImageFilter_swigregister = _SimpleITK.CosImageFilter_swigregister
CosImageFilter_swigregister(CosImageFilter)


def Cos(image1):
    """
    Cos(Image image1) -> Image



    Computes the cosine of each pixel.


    This function directly calls the execute method of CosImageFilter in order to support a procedural API


    See:
     itk::simple::CosImageFilter for the object oriented interface



    """
    return _SimpleITK.Cos(image1)
class CropImageFilter(ImageFilter_1):
    """


    Decrease the image size by cropping the image by an itk::Size at both the upper and lower bounds of the largest possible region.


    CropImageFilter changes the image boundary of an image by removing pixels outside the
    target region. The target region is not specified in advance, but
    calculated in BeforeThreadedGenerateData() .

    This filter uses ExtractImageFilter to perform the cropping.

    Wiki Examples:

    All Examples

    Crop an image by specifying the region to throw away
    See:
     itk::simple::Crop for the procedural interface

     itk::CropImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkCropImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CropImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CropImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CropImageFilter self) -> CropImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CropImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CropImageFilter
    __del__ = lambda self: None

    def SetLowerBoundaryCropSize(self, LowerBoundaryCropSize):
        """
        SetLowerBoundaryCropSize(CropImageFilter self, VectorUInt32 LowerBoundaryCropSize)



        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_SetLowerBoundaryCropSize(self, LowerBoundaryCropSize)


    def GetLowerBoundaryCropSize(self):
        """
        GetLowerBoundaryCropSize(CropImageFilter self) -> VectorUInt32



        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_GetLowerBoundaryCropSize(self)


    def SetUpperBoundaryCropSize(self, UpperBoundaryCropSize):
        """
        SetUpperBoundaryCropSize(CropImageFilter self, VectorUInt32 UpperBoundaryCropSize)



        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_SetUpperBoundaryCropSize(self, UpperBoundaryCropSize)


    def GetUpperBoundaryCropSize(self):
        """
        GetUpperBoundaryCropSize(CropImageFilter self) -> VectorUInt32



        Set/Get the cropping sizes for the upper and lower boundaries.


        """
        return _SimpleITK.CropImageFilter_GetUpperBoundaryCropSize(self)


    def GetName(self):
        """
        GetName(CropImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CropImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CropImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CropImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CropImageFilter self, Image image1) -> Image
        Execute(CropImageFilter self, Image image1, VectorUInt32 lowerBoundaryCropSize, VectorUInt32 upperBoundaryCropSize) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CropImageFilter_Execute(self, *args)

CropImageFilter_swigregister = _SimpleITK.CropImageFilter_swigregister
CropImageFilter_swigregister(CropImageFilter)


def Crop(*args, **kwargs):
    """
    Crop(Image image1, VectorUInt32 lowerBoundaryCropSize, VectorUInt32 upperBoundaryCropSize) -> Image



    Decrease the image size by cropping the image by an itk::Size at both the upper and lower bounds of the largest possible region.


    This function directly calls the execute method of CropImageFilter in order to support a procedural API


    See:
     itk::simple::CropImageFilter for the object oriented interface



    """
    return _SimpleITK.Crop(*args, **kwargs)
class CurvatureAnisotropicDiffusionImageFilter(ImageFilter_1):
    """


    This filter performs anisotropic diffusion on a scalar itk::Image using the modified curvature diffusion equation (MCDE) implemented in
    itkCurvatureNDAnisotropicDiffusionFunction. For detailed information
    on anisotropic diffusion and the MCDE see
    itkAnisotropicDiffusionFunction and
    itkCurvatureNDAnisotropicDiffusionFunction.

    Inputs and Outputs
    The input and output to this filter must be a scalar itk::Image with numerical pixel types (float or double). A user defined type
    which correctly defines arithmetic operations with floating point
    accuracy should also give correct results.
    Parameters
    Please first read all the documentation found in AnisotropicDiffusionImageFilter and AnisotropicDiffusionFunction . Also see CurvatureNDAnisotropicDiffusionFunction .
     The default time step for this filter is set to the maximum
    theoretically stable value: 0.5 / 2^N, where N is the dimensionality
    of the image. For a 2D image, this means valid time steps are below
    0.1250. For a 3D image, valid time steps are below 0.0625.


    See:
     AnisotropicDiffusionImageFilter

     AnisotropicDiffusionFunction

     CurvatureNDAnisotropicDiffusionFunction

     itk::simple::CurvatureAnisotropicDiffusion for the procedural interface

     itk::CurvatureAnisotropicDiffusionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCurvatureAnisotropicDiffusionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CurvatureAnisotropicDiffusionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CurvatureAnisotropicDiffusionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CurvatureAnisotropicDiffusionImageFilter self) -> CurvatureAnisotropicDiffusionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CurvatureAnisotropicDiffusionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CurvatureAnisotropicDiffusionImageFilter
    __del__ = lambda self: None

    def SetTimeStep(self, TimeStep):
        """
        SetTimeStep(CurvatureAnisotropicDiffusionImageFilter self, double TimeStep)



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetTimeStep(self, TimeStep)


    def GetTimeStep(self):
        """
        GetTimeStep(CurvatureAnisotropicDiffusionImageFilter self) -> double



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetTimeStep(self)


    def SetConductanceParameter(self, ConductanceParameter):
        """
        SetConductanceParameter(CurvatureAnisotropicDiffusionImageFilter self, double ConductanceParameter)



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetConductanceParameter(self, ConductanceParameter)


    def GetConductanceParameter(self):
        """
        GetConductanceParameter(CurvatureAnisotropicDiffusionImageFilter self) -> double



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetConductanceParameter(self)


    def SetConductanceScalingUpdateInterval(self, ConductanceScalingUpdateInterval):
        """
        SetConductanceScalingUpdateInterval(CurvatureAnisotropicDiffusionImageFilter self, unsigned int ConductanceScalingUpdateInterval)



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetConductanceScalingUpdateInterval(self, ConductanceScalingUpdateInterval)


    def GetConductanceScalingUpdateInterval(self):
        """
        GetConductanceScalingUpdateInterval(CurvatureAnisotropicDiffusionImageFilter self) -> unsigned int



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetConductanceScalingUpdateInterval(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(CurvatureAnisotropicDiffusionImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(CurvatureAnisotropicDiffusionImageFilter self) -> uint32_t



        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetNumberOfIterations(self)


    def GetName(self):
        """
        GetName(CurvatureAnisotropicDiffusionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CurvatureAnisotropicDiffusionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CurvatureAnisotropicDiffusionImageFilter self, Image image1) -> Image
        Execute(CurvatureAnisotropicDiffusionImageFilter self, Image image1, double timeStep, double conductanceParameter, unsigned int conductanceScalingUpdateInterval, uint32_t numberOfIterations) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_Execute(self, *args)


    def EstimateOptimalTimeStep(self, inImage):
        """
        EstimateOptimalTimeStep(CurvatureAnisotropicDiffusionImageFilter self, Image inImage) -> double



        This method autmatically sets the optimal timestep for an image given
        its spacing.


        """
        return _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_EstimateOptimalTimeStep(self, inImage)

CurvatureAnisotropicDiffusionImageFilter_swigregister = _SimpleITK.CurvatureAnisotropicDiffusionImageFilter_swigregister
CurvatureAnisotropicDiffusionImageFilter_swigregister(CurvatureAnisotropicDiffusionImageFilter)


def CurvatureAnisotropicDiffusion(image1, timeStep=0.0625, conductanceParameter=3, conductanceScalingUpdateInterval=1, numberOfIterations=5):
    """
    CurvatureAnisotropicDiffusion(Image image1, double timeStep=0.0625, double conductanceParameter=3, unsigned int conductanceScalingUpdateInterval=1, uint32_t numberOfIterations=5) -> Image



    itk::simple::CurvatureAnisotropicDiffusionImageFilter Procedural Interface


    This function directly calls the execute method of CurvatureAnisotropicDiffusionImageFilter in order to support a procedural API


    See:
     itk::simple::CurvatureAnisotropicDiffusionImageFilter for the object oriented interface



    """
    return _SimpleITK.CurvatureAnisotropicDiffusion(image1, timeStep, conductanceParameter, conductanceScalingUpdateInterval, numberOfIterations)
class CurvatureFlowImageFilter(ImageFilter_1):
    """


    Denoise an image using curvature driven flow.


    CurvatureFlowImageFilter implements a curvature driven image denoising algorithm. Iso-
    brightness contours in the grayscale input image are viewed as a level
    set. The level set is then evolved using a curvature-based speed
    function:

    \\[ I_t = \\kappa |\\nabla I| \\] where $ \\kappa $ is the curvature.

    The advantage of this approach is that sharp boundaries are preserved
    with smoothing occurring only within a region. However, it should be
    noted that continuous application of this scheme will result in the
    eventual removal of all information as each contour shrinks to zero
    and disappear.

    Note that unlike level set segmentation algorithms, the image to be
    denoised is already the level set and can be set directly as the input
    using the SetInput() method.

    This filter has two parameters: the number of update iterations to be
    performed and the timestep between each update.

    The timestep should be "small enough" to ensure numerical stability.
    Stability is guarantee when the timestep meets the CFL (Courant-
    Friedrichs-Levy) condition. Broadly speaking, this condition ensures
    that each contour does not move more than one grid position at each
    timestep. In the literature, the timestep is typically user specified
    and have to manually tuned to the application.

    This filter make use of the multi-threaded finite difference solver
    hierarchy. Updates are computed using a CurvatureFlowFunction object. A zero flux Neumann boundary condition when computing
    derivatives near the data boundary.

    This filter may be streamed. To support streaming this filter produces
    a padded output which takes into account edge effects. The size of the
    padding is m_NumberOfIterations on each edge. Users of this filter
    should only make use of the center valid central region.


    WARNING:
    This filter assumes that the input and output types have the same
    dimensions. This filter also requires that the output image pixels are
    of a floating point type. This filter works for any dimensional
    images.
     Reference: "Level Set Methods and Fast Marching Methods", J.A.
    Sethian, Cambridge Press, Chapter 16, Second edition, 1999.


    See:
     DenseFiniteDifferenceImageFilter

     CurvatureFlowFunction

     MinMaxCurvatureFlowImageFilter

     BinaryMinMaxCurvatureFlowImageFilter

     itk::simple::CurvatureFlow for the procedural interface

     itk::CurvatureFlowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCurvatureFlowImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CurvatureFlowImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CurvatureFlowImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CurvatureFlowImageFilter self) -> CurvatureFlowImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CurvatureFlowImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CurvatureFlowImageFilter
    __del__ = lambda self: None

    def SetTimeStep(self, TimeStep):
        """
        SetTimeStep(CurvatureFlowImageFilter self, double TimeStep)



        Set the timestep parameter.


        """
        return _SimpleITK.CurvatureFlowImageFilter_SetTimeStep(self, TimeStep)


    def GetTimeStep(self):
        """
        GetTimeStep(CurvatureFlowImageFilter self) -> double



        Get the timestep parameter.


        """
        return _SimpleITK.CurvatureFlowImageFilter_GetTimeStep(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(CurvatureFlowImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.CurvatureFlowImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(CurvatureFlowImageFilter self) -> uint32_t



        """
        return _SimpleITK.CurvatureFlowImageFilter_GetNumberOfIterations(self)


    def GetName(self):
        """
        GetName(CurvatureFlowImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CurvatureFlowImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CurvatureFlowImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CurvatureFlowImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CurvatureFlowImageFilter self, Image image1) -> Image
        Execute(CurvatureFlowImageFilter self, Image image1, double timeStep, uint32_t numberOfIterations) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CurvatureFlowImageFilter_Execute(self, *args)

CurvatureFlowImageFilter_swigregister = _SimpleITK.CurvatureFlowImageFilter_swigregister
CurvatureFlowImageFilter_swigregister(CurvatureFlowImageFilter)


def CurvatureFlow(image1, timeStep=0.05, numberOfIterations=5):
    """
    CurvatureFlow(Image image1, double timeStep=0.05, uint32_t numberOfIterations=5) -> Image



    Denoise an image using curvature driven flow.


    This function directly calls the execute method of CurvatureFlowImageFilter in order to support a procedural API


    See:
     itk::simple::CurvatureFlowImageFilter for the object oriented interface



    """
    return _SimpleITK.CurvatureFlow(image1, timeStep, numberOfIterations)
class CyclicShiftImageFilter(ImageFilter_1):
    """


    Perform a cyclic spatial shift of image intensities on the image grid.


    This filter supports arbitrary cyclic shifts of pixel values on the
    image grid. If the Shift is set to [xOff, yOff], the value of the
    pixel at [0, 0] in the input image will be the value of the pixel in
    the output image at index [xOff modulo xSize, yOff modulo ySize] where
    xSize and ySize are the sizes of the image in the x and y dimensions,
    respectively. If a pixel value is moved across a boundary, the pixel
    value is wrapped around that boundary. For example, if the image is
    40-by-40 and the Shift is [13, 47], then the value of the pixel at [0,
    0] in the input image will be the value of the pixel in the output
    image at index [13, 7].

    Negative Shifts are supported. This filter also works with images
    whose largest possible region starts at a non-zero index.
    See:
     itk::simple::CyclicShift for the procedural interface

     itk::CyclicShiftImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkCyclicShiftImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CyclicShiftImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CyclicShiftImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::CyclicShiftImageFilter self) -> CyclicShiftImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_CyclicShiftImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_CyclicShiftImageFilter
    __del__ = lambda self: None

    def SetShift(self, *args):
        """
        SetShift(CyclicShiftImageFilter self, VectorInt32 Shift)
        SetShift(CyclicShiftImageFilter self, int value)



        Set the values of the Shift vector all to value


        """
        return _SimpleITK.CyclicShiftImageFilter_SetShift(self, *args)


    def GetShift(self):
        """
        GetShift(CyclicShiftImageFilter self) -> VectorInt32



        Set/get the shift. Shifts may be positive or negative.


        """
        return _SimpleITK.CyclicShiftImageFilter_GetShift(self)


    def GetName(self):
        """
        GetName(CyclicShiftImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.CyclicShiftImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(CyclicShiftImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.CyclicShiftImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(CyclicShiftImageFilter self, Image image1) -> Image
        Execute(CyclicShiftImageFilter self, Image image1, VectorInt32 shift) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.CyclicShiftImageFilter_Execute(self, *args)

CyclicShiftImageFilter_swigregister = _SimpleITK.CyclicShiftImageFilter_swigregister
CyclicShiftImageFilter_swigregister(CyclicShiftImageFilter)


def CyclicShift(*args, **kwargs):
    """
    CyclicShift(Image image1, VectorInt32 shift) -> Image



    Perform a cyclic spatial shift of image intensities on the image grid.


    This function directly calls the execute method of CyclicShiftImageFilter in order to support a procedural API


    See:
     itk::simple::CyclicShiftImageFilter for the object oriented interface



    """
    return _SimpleITK.CyclicShift(*args, **kwargs)
class DanielssonDistanceMapImageFilter(ImageFilter_1):
    """


    This filter computes the distance map of the input image as an
    approximation with pixel accuracy to the Euclidean distance.


    TInputImage

    Input Image Type

    TOutputImage

    Output Image Type

    TVoronoiImage

    Voronoi Image Type. Note the default value is TInputImage.

    The input is assumed to contain numeric codes defining objects. The
    filter will produce as output the following images:


    A Voronoi partition using the same numeric codes as the input.

    A distance map with the approximation to the euclidean distance. from
    a particular pixel to the nearest object to this pixel in the input
    image.

    A vector map containing the component of the vector relating the
    current pixel with the closest point of the closest object to this
    pixel. Given that the components of the distance are computed in
    "pixels", the vector is represented by an itk::Offset . That is, physical coordinates are not used.
     This filter is N-dimensional and known to be efficient in
    computational time. The algorithm is the N-dimensional version of the
    4SED algorithm given for two dimensions in:

    Danielsson, Per-Erik. Euclidean Distance Mapping. Computer Graphics
    and Image Processing 14, 227-248 (1980).
    See:
     itk::simple::DanielssonDistanceMap for the procedural interface

     itk::DanielssonDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDanielssonDistanceMapImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DanielssonDistanceMapImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DanielssonDistanceMapImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DanielssonDistanceMapImageFilter self) -> DanielssonDistanceMapImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DanielssonDistanceMapImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DanielssonDistanceMapImageFilter
    __del__ = lambda self: None

    def SetInputIsBinary(self, InputIsBinary):
        """
        SetInputIsBinary(DanielssonDistanceMapImageFilter self, bool InputIsBinary)



        Set if the input is binary. If this variable is set, each nonzero
        pixel in the input image will be given a unique numeric code to be
        used by the Voronoi partition. If the image is binary but you are not
        interested in the Voronoi regions of the different nonzero pixels,
        then you need not set this.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SetInputIsBinary(self, InputIsBinary)


    def InputIsBinaryOn(self):
        """
        InputIsBinaryOn(DanielssonDistanceMapImageFilter self)



        Set the value of InputIsBinary to true or false respectfully.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_InputIsBinaryOn(self)


    def InputIsBinaryOff(self):
        """
        InputIsBinaryOff(DanielssonDistanceMapImageFilter self)



        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_InputIsBinaryOff(self)


    def GetInputIsBinary(self):
        """
        GetInputIsBinary(DanielssonDistanceMapImageFilter self) -> bool



        Get if the input is binary. See SetInputIsBinary() .


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetInputIsBinary(self)


    def SetSquaredDistance(self, SquaredDistance):
        """
        SetSquaredDistance(DanielssonDistanceMapImageFilter self, bool SquaredDistance)



        Set if the distance should be squared.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SetSquaredDistance(self, SquaredDistance)


    def SquaredDistanceOn(self):
        """
        SquaredDistanceOn(DanielssonDistanceMapImageFilter self)



        Set the value of SquaredDistance to true or false respectfully.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SquaredDistanceOn(self)


    def SquaredDistanceOff(self):
        """
        SquaredDistanceOff(DanielssonDistanceMapImageFilter self)



        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SquaredDistanceOff(self)


    def GetSquaredDistance(self):
        """
        GetSquaredDistance(DanielssonDistanceMapImageFilter self) -> bool



        Get the distance squared.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetSquaredDistance(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DanielssonDistanceMapImageFilter self, bool UseImageSpacing)



        Set if image spacing should be used in computing distances.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DanielssonDistanceMapImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DanielssonDistanceMapImageFilter self)



        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DanielssonDistanceMapImageFilter self) -> bool



        Get whether spacing is used.


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(DanielssonDistanceMapImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DanielssonDistanceMapImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DanielssonDistanceMapImageFilter self, Image image1) -> Image
        Execute(DanielssonDistanceMapImageFilter self, Image image1, bool inputIsBinary, bool squaredDistance, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DanielssonDistanceMapImageFilter_Execute(self, *args)

DanielssonDistanceMapImageFilter_swigregister = _SimpleITK.DanielssonDistanceMapImageFilter_swigregister
DanielssonDistanceMapImageFilter_swigregister(DanielssonDistanceMapImageFilter)


def DanielssonDistanceMap(image1, inputIsBinary=False, squaredDistance=False, useImageSpacing=False):
    """
    DanielssonDistanceMap(Image image1, bool inputIsBinary=False, bool squaredDistance=False, bool useImageSpacing=False) -> Image



    This filter computes the distance map of the input image as an
    approximation with pixel accuracy to the Euclidean distance.


    This function directly calls the execute method of DanielssonDistanceMapImageFilter in order to support a procedural API


    See:
     itk::simple::DanielssonDistanceMapImageFilter for the object oriented interface



    """
    return _SimpleITK.DanielssonDistanceMap(image1, inputIsBinary, squaredDistance, useImageSpacing)
class DemonsRegistrationFilter(ImageFilter_0):
    """


    Deformably register two images using the demons algorithm.


    DemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the displacement field which will map a moving image onto
    a fixed image.

    A displacement field is represented as a image whose pixel type is
    some vector type with at least N elements, where N is the dimension of
    the fixed image. The vector type must support element access via
    operator []. It is assumed that the vector elements behave like
    floating point scalars.

    This class is templated over the fixed image type, moving image type
    and the displacement field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial displacement field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The algorithm has one parameters: the number of iteration to be
    performed.

    The output displacement field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    displacement field type all have the same number of dimensions.

    See:
     DemonsRegistrationFunction

     itk::DemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDemonsRegistrationFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DemonsRegistrationFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DemonsRegistrationFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DemonsRegistrationFilter self) -> DemonsRegistrationFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DemonsRegistrationFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DemonsRegistrationFilter
    __del__ = lambda self: None

    def SetStandardDeviations(self, *args):
        """
        SetStandardDeviations(DemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(DemonsRegistrationFilter self, double value)



        Set the values of the StandardDeviations vector all to value


        """
        return _SimpleITK.DemonsRegistrationFilter_SetStandardDeviations(self, *args)


    def GetStandardDeviations(self):
        """
        GetStandardDeviations(DemonsRegistrationFilter self) -> VectorDouble



        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetStandardDeviations(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(DemonsRegistrationFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.DemonsRegistrationFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(DemonsRegistrationFilter self) -> uint32_t



        """
        return _SimpleITK.DemonsRegistrationFilter_GetNumberOfIterations(self)


    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(DemonsRegistrationFilter self, double MaximumRMSError)



        """
        return _SimpleITK.DemonsRegistrationFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(DemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.DemonsRegistrationFilter_GetMaximumRMSError(self)


    def SetUseMovingImageGradient(self, UseMovingImageGradient):
        """
        SetUseMovingImageGradient(DemonsRegistrationFilter self, bool UseMovingImageGradient)



        Switch between using the fixed image and moving image gradient for
        computing the displacement field updates.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetUseMovingImageGradient(self, UseMovingImageGradient)


    def UseMovingImageGradientOn(self):
        """
        UseMovingImageGradientOn(DemonsRegistrationFilter self)



        Set the value of UseMovingImageGradient to true or false respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_UseMovingImageGradientOn(self)


    def UseMovingImageGradientOff(self):
        """
        UseMovingImageGradientOff(DemonsRegistrationFilter self)



        """
        return _SimpleITK.DemonsRegistrationFilter_UseMovingImageGradientOff(self)


    def GetUseMovingImageGradient(self):
        """
        GetUseMovingImageGradient(DemonsRegistrationFilter self) -> bool



        Switch between using the fixed image and moving image gradient for
        computing the displacement field updates.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetUseMovingImageGradient(self)


    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        """
        SetSmoothDisplacementField(DemonsRegistrationFilter self, bool SmoothDisplacementField)



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_SetSmoothDisplacementField(self, SmoothDisplacementField)


    def SmoothDisplacementFieldOn(self):
        """
        SmoothDisplacementFieldOn(DemonsRegistrationFilter self)



        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothDisplacementFieldOn(self)


    def SmoothDisplacementFieldOff(self):
        """
        SmoothDisplacementFieldOff(DemonsRegistrationFilter self)



        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothDisplacementFieldOff(self)


    def GetSmoothDisplacementField(self):
        """
        GetSmoothDisplacementField(DemonsRegistrationFilter self) -> bool



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_GetSmoothDisplacementField(self)


    def SetSmoothUpdateField(self, SmoothUpdateField):
        """
        SetSmoothUpdateField(DemonsRegistrationFilter self, bool SmoothUpdateField)



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_SetSmoothUpdateField(self, SmoothUpdateField)


    def SmoothUpdateFieldOn(self):
        """
        SmoothUpdateFieldOn(DemonsRegistrationFilter self)



        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothUpdateFieldOn(self)


    def SmoothUpdateFieldOff(self):
        """
        SmoothUpdateFieldOff(DemonsRegistrationFilter self)



        """
        return _SimpleITK.DemonsRegistrationFilter_SmoothUpdateFieldOff(self)


    def GetSmoothUpdateField(self):
        """
        GetSmoothUpdateField(DemonsRegistrationFilter self) -> bool



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DemonsRegistrationFilter_GetSmoothUpdateField(self)


    def SetUpdateFieldStandardDeviations(self, *args):
        """
        SetUpdateFieldStandardDeviations(DemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(DemonsRegistrationFilter self, double value)



        Set the values of the UpdateFieldStandardDeviations vector all to
        value


        """
        return _SimpleITK.DemonsRegistrationFilter_SetUpdateFieldStandardDeviations(self, *args)


    def GetUpdateFieldStandardDeviations(self):
        """
        GetUpdateFieldStandardDeviations(DemonsRegistrationFilter self) -> VectorDouble



        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetUpdateFieldStandardDeviations(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(DemonsRegistrationFilter self, unsigned int MaximumKernelWidth)



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(DemonsRegistrationFilter self) -> unsigned int



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(DemonsRegistrationFilter self, double MaximumError)



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(DemonsRegistrationFilter self) -> double



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMaximumError(self)


    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        """
        SetIntensityDifferenceThreshold(DemonsRegistrationFilter self, double IntensityDifferenceThreshold)



        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.DemonsRegistrationFilter_SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold)


    def GetIntensityDifferenceThreshold(self):
        """
        GetIntensityDifferenceThreshold(DemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.DemonsRegistrationFilter_GetIntensityDifferenceThreshold(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DemonsRegistrationFilter self, bool UseImageSpacing)



        """
        return _SimpleITK.DemonsRegistrationFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DemonsRegistrationFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DemonsRegistrationFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DemonsRegistrationFilter self)



        """
        return _SimpleITK.DemonsRegistrationFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DemonsRegistrationFilter self) -> bool



        """
        return _SimpleITK.DemonsRegistrationFilter_GetUseImageSpacing(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(DemonsRegistrationFilter self) -> uint32_t



        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(DemonsRegistrationFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetRMSChange(self)


    def GetMetric(self):
        """
        GetMetric(DemonsRegistrationFilter self) -> double



        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the the overlapping region between the two images. This
        is value is only available for the previous iteration and NOT the
        current iteration.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DemonsRegistrationFilter_GetMetric(self)


    def GetName(self):
        """
        GetName(DemonsRegistrationFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DemonsRegistrationFilter_GetName(self)


    def __str__(self):
        """
        __str__(DemonsRegistrationFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DemonsRegistrationFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(DemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image
        Execute(DemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, bool useMovingImageGradient, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image
        Execute(DemonsRegistrationFilter self, Image fixedImage, Image movingImage, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, bool useMovingImageGradient, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image



        """
        return _SimpleITK.DemonsRegistrationFilter_Execute(self, *args)

DemonsRegistrationFilter_swigregister = _SimpleITK.DemonsRegistrationFilter_swigregister
DemonsRegistrationFilter_swigregister(DemonsRegistrationFilter)

class DerivativeImageFilter(ImageFilter_1):
    """


    Computes the directional derivative of an image. The directional
    derivative at each pixel location is computed by convolution with a
    derivative operator of user-specified order.


    SetOrder specifies the order of the derivative.

    SetDirection specifies the direction of the derivative with respect to
    the coordinate axes of the image.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Compute the derivative of an image in a particular direction
    See:
     itk::simple::Derivative for the procedural interface

     itk::DerivativeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkDerivativeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DerivativeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DerivativeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DerivativeImageFilter self) -> DerivativeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DerivativeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DerivativeImageFilter
    __del__ = lambda self: None

    def SetDirection(self, Direction):
        """
        SetDirection(DerivativeImageFilter self, unsigned int Direction)



        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_SetDirection(self, Direction)


    def GetDirection(self):
        """
        GetDirection(DerivativeImageFilter self) -> unsigned int



        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_GetDirection(self)


    def SetOrder(self, Order):
        """
        SetOrder(DerivativeImageFilter self, unsigned int Order)



        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_SetOrder(self, Order)


    def GetOrder(self):
        """
        GetOrder(DerivativeImageFilter self) -> unsigned int



        The output pixel type must be signed. Standard get/set macros for
        filter parameters.


        """
        return _SimpleITK.DerivativeImageFilter_GetOrder(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DerivativeImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.DerivativeImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DerivativeImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DerivativeImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DerivativeImageFilter self)



        """
        return _SimpleITK.DerivativeImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DerivativeImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.DerivativeImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(DerivativeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DerivativeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DerivativeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DerivativeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DerivativeImageFilter self, Image image1) -> Image
        Execute(DerivativeImageFilter self, Image image1, unsigned int direction, unsigned int order, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DerivativeImageFilter_Execute(self, *args)

DerivativeImageFilter_swigregister = _SimpleITK.DerivativeImageFilter_swigregister
DerivativeImageFilter_swigregister(DerivativeImageFilter)


def Derivative(image1, direction=0, order=1, useImageSpacing=True):
    """
    Derivative(Image image1, unsigned int direction=0, unsigned int order=1, bool useImageSpacing=True) -> Image



    Computes the directional derivative of an image. The directional
    derivative at each pixel location is computed by convolution with a
    derivative operator of user-specified order.


    This function directly calls the execute method of DerivativeImageFilter in order to support a procedural API


    See:
     itk::simple::DerivativeImageFilter for the object oriented interface



    """
    return _SimpleITK.Derivative(image1, direction, order, useImageSpacing)
class DiffeomorphicDemonsRegistrationFilter(ImageFilter_0):
    """


    Deformably register two images using a diffeomorphic demons algorithm.


    This class was contributed by Tom Vercauteren, INRIA & Mauna Kea
    Technologies, based on a variation of the DemonsRegistrationFilter . The basic modification is to use diffeomorphism exponentials.

    See T. Vercauteren, X. Pennec, A. Perchant and N. Ayache, "Non-
    parametric Diffeomorphic Image Registration with the Demons
    Algorithm", Proc. of MICCAI 2007.

    DiffeomorphicDemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the deformation field which will map a moving image onto
    a fixed image.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    Tom Vercauteren, INRIA & Mauna Kea Technologies

    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/510


    See:
     DemonsRegistrationFilter

     DemonsRegistrationFunction

     itk::DiffeomorphicDemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDiffeomorphicDemonsRegistrationFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiffeomorphicDemonsRegistrationFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiffeomorphicDemonsRegistrationFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DiffeomorphicDemonsRegistrationFilter self) -> DiffeomorphicDemonsRegistrationFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DiffeomorphicDemonsRegistrationFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DiffeomorphicDemonsRegistrationFilter
    __del__ = lambda self: None

    def SetStandardDeviations(self, *args):
        """
        SetStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, double value)



        Set the values of the StandardDeviations vector all to value


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetStandardDeviations(self, *args)


    def GetStandardDeviations(self):
        """
        GetStandardDeviations(DiffeomorphicDemonsRegistrationFilter self) -> VectorDouble



        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetStandardDeviations(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(DiffeomorphicDemonsRegistrationFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(DiffeomorphicDemonsRegistrationFilter self) -> uint32_t



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetNumberOfIterations(self)


    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(DiffeomorphicDemonsRegistrationFilter self, double MaximumRMSError)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(DiffeomorphicDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumRMSError(self)

    Symmetric = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_Symmetric
    Fixed = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_Fixed
    WarpedMoving = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_WarpedMoving
    MappedMoving = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_MappedMoving

    def SetUseGradientType(self, UseGradientType):
        """
        SetUseGradientType(DiffeomorphicDemonsRegistrationFilter self, itk::simple::DiffeomorphicDemonsRegistrationFilter::UseGradientTypeType UseGradientType)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUseGradientType(self, UseGradientType)


    def GetUseGradientType(self):
        """
        GetUseGradientType(DiffeomorphicDemonsRegistrationFilter self) -> itk::simple::DiffeomorphicDemonsRegistrationFilter::UseGradientTypeType



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUseGradientType(self)


    def SetUseFirstOrderExp(self, UseFirstOrderExp):
        """
        SetUseFirstOrderExp(DiffeomorphicDemonsRegistrationFilter self, bool UseFirstOrderExp)



        Use a first-order approximation of the exponential. This amounts to
        using an update rule of the type s <- s o (Id + u) instead of s <- s o
        exp(u)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUseFirstOrderExp(self, UseFirstOrderExp)


    def UseFirstOrderExpOn(self):
        """
        UseFirstOrderExpOn(DiffeomorphicDemonsRegistrationFilter self)



        Set the value of UseFirstOrderExp to true or false respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseFirstOrderExpOn(self)


    def UseFirstOrderExpOff(self):
        """
        UseFirstOrderExpOff(DiffeomorphicDemonsRegistrationFilter self)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseFirstOrderExpOff(self)


    def GetUseFirstOrderExp(self):
        """
        GetUseFirstOrderExp(DiffeomorphicDemonsRegistrationFilter self) -> bool



        Use a first-order approximation of the exponential. This amounts to
        using an update rule of the type s <- s o (Id + u) instead of s <- s o
        exp(u)


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUseFirstOrderExp(self)


    def SetMaximumUpdateStepLength(self, MaximumUpdateStepLength):
        """
        SetMaximumUpdateStepLength(DiffeomorphicDemonsRegistrationFilter self, double MaximumUpdateStepLength)



        Set/Get the maximum length in terms of pixels of the vectors in the
        update buffer.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumUpdateStepLength(self, MaximumUpdateStepLength)


    def GetMaximumUpdateStepLength(self):
        """
        GetMaximumUpdateStepLength(DiffeomorphicDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumUpdateStepLength(self)


    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        """
        SetSmoothDisplacementField(DiffeomorphicDemonsRegistrationFilter self, bool SmoothDisplacementField)



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetSmoothDisplacementField(self, SmoothDisplacementField)


    def SmoothDisplacementFieldOn(self):
        """
        SmoothDisplacementFieldOn(DiffeomorphicDemonsRegistrationFilter self)



        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothDisplacementFieldOn(self)


    def SmoothDisplacementFieldOff(self):
        """
        SmoothDisplacementFieldOff(DiffeomorphicDemonsRegistrationFilter self)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothDisplacementFieldOff(self)


    def GetSmoothDisplacementField(self):
        """
        GetSmoothDisplacementField(DiffeomorphicDemonsRegistrationFilter self) -> bool



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetSmoothDisplacementField(self)


    def SetSmoothUpdateField(self, SmoothUpdateField):
        """
        SetSmoothUpdateField(DiffeomorphicDemonsRegistrationFilter self, bool SmoothUpdateField)



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetSmoothUpdateField(self, SmoothUpdateField)


    def SmoothUpdateFieldOn(self):
        """
        SmoothUpdateFieldOn(DiffeomorphicDemonsRegistrationFilter self)



        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothUpdateFieldOn(self)


    def SmoothUpdateFieldOff(self):
        """
        SmoothUpdateFieldOff(DiffeomorphicDemonsRegistrationFilter self)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SmoothUpdateFieldOff(self)


    def GetSmoothUpdateField(self):
        """
        GetSmoothUpdateField(DiffeomorphicDemonsRegistrationFilter self) -> bool



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetSmoothUpdateField(self)


    def SetUpdateFieldStandardDeviations(self, *args):
        """
        SetUpdateFieldStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(DiffeomorphicDemonsRegistrationFilter self, double value)



        Set the values of the UpdateFieldStandardDeviations vector all to
        value


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUpdateFieldStandardDeviations(self, *args)


    def GetUpdateFieldStandardDeviations(self):
        """
        GetUpdateFieldStandardDeviations(DiffeomorphicDemonsRegistrationFilter self) -> VectorDouble



        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUpdateFieldStandardDeviations(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(DiffeomorphicDemonsRegistrationFilter self, unsigned int MaximumKernelWidth)



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(DiffeomorphicDemonsRegistrationFilter self) -> unsigned int



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(DiffeomorphicDemonsRegistrationFilter self, double MaximumError)



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(DiffeomorphicDemonsRegistrationFilter self) -> double



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMaximumError(self)


    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        """
        SetIntensityDifferenceThreshold(DiffeomorphicDemonsRegistrationFilter self, double IntensityDifferenceThreshold)



        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold)


    def GetIntensityDifferenceThreshold(self):
        """
        GetIntensityDifferenceThreshold(DiffeomorphicDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetIntensityDifferenceThreshold(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DiffeomorphicDemonsRegistrationFilter self, bool UseImageSpacing)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DiffeomorphicDemonsRegistrationFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DiffeomorphicDemonsRegistrationFilter self)



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DiffeomorphicDemonsRegistrationFilter self) -> bool



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetUseImageSpacing(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(DiffeomorphicDemonsRegistrationFilter self) -> uint32_t



        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(DiffeomorphicDemonsRegistrationFilter self) -> double



        Set/Get the root mean squared change of the previous iteration. May
        not be used by all solvers.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetRMSChange(self)


    def GetMetric(self):
        """
        GetMetric(DiffeomorphicDemonsRegistrationFilter self) -> double



        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the the overlapping region between the two images. This
        value is calculated for the current iteration

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetMetric(self)


    def GetName(self):
        """
        GetName(DiffeomorphicDemonsRegistrationFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_GetName(self)


    def __str__(self):
        """
        __str__(DiffeomorphicDemonsRegistrationFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DiffeomorphicDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(DiffeomorphicDemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image
        Execute(DiffeomorphicDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, itk::simple::DiffeomorphicDemonsRegistrationFilter::UseGradientTypeType useGradientType, bool useFirstOrderExp, double maximumUpdateStepLength, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image
        Execute(DiffeomorphicDemonsRegistrationFilter self, Image fixedImage, Image movingImage, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, itk::simple::DiffeomorphicDemonsRegistrationFilter::UseGradientTypeType useGradientType, bool useFirstOrderExp, double maximumUpdateStepLength, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image



        """
        return _SimpleITK.DiffeomorphicDemonsRegistrationFilter_Execute(self, *args)

DiffeomorphicDemonsRegistrationFilter_swigregister = _SimpleITK.DiffeomorphicDemonsRegistrationFilter_swigregister
DiffeomorphicDemonsRegistrationFilter_swigregister(DiffeomorphicDemonsRegistrationFilter)

class DilateObjectMorphologyImageFilter(ImageFilter_1):
    """


    dilation of an object in an image


    Dilate an image using binary morphology. Pixel values matching the
    object value are considered the "foreground" and all other pixels
    are "background". This is useful in processing mask images
    containing only one object.

    If a pixel's value is equal to the object value and the pixel is
    adjacent to a non-object valued pixel, then the kernel is centered on
    the object-value pixel and neighboring pixels covered by the kernel
    are assigned the object value. The structuring element is assumed to
    be composed of binary values (zero or one).


    See:
     ObjectMorphologyImageFilter , ErodeObjectMorphologyImageFilter

     BinaryDilateImageFilter

     itk::simple::DilateObjectMorphology for the procedural interface

     itk::DilateObjectMorphologyImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDilateObjectMorphologyImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DilateObjectMorphologyImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DilateObjectMorphologyImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DilateObjectMorphologyImageFilter self) -> DilateObjectMorphologyImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DilateObjectMorphologyImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DilateObjectMorphologyImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.DilateObjectMorphologyImageFilter_Annulus
    Ball = _SimpleITK.DilateObjectMorphologyImageFilter_Ball
    Box = _SimpleITK.DilateObjectMorphologyImageFilter_Box
    Cross = _SimpleITK.DilateObjectMorphologyImageFilter_Cross

    def SetObjectValue(self, ObjectValue):
        """
        SetObjectValue(DilateObjectMorphologyImageFilter self, double ObjectValue)



        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_SetObjectValue(self, ObjectValue)


    def GetObjectValue(self):
        """
        GetObjectValue(DilateObjectMorphologyImageFilter self) -> double



        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetObjectValue(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(DilateObjectMorphologyImageFilter self, uint32_t r)
        SetKernelRadius(DilateObjectMorphologyImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(DilateObjectMorphologyImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(DilateObjectMorphologyImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(DilateObjectMorphologyImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(DilateObjectMorphologyImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DilateObjectMorphologyImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DilateObjectMorphologyImageFilter self, Image image1) -> Image
        Execute(DilateObjectMorphologyImageFilter self, Image image1, double objectValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DilateObjectMorphologyImageFilter_Execute(self, *args)

DilateObjectMorphologyImageFilter_swigregister = _SimpleITK.DilateObjectMorphologyImageFilter_swigregister
DilateObjectMorphologyImageFilter_swigregister(DilateObjectMorphologyImageFilter)


def DilateObjectMorphology(*args):
    """
    DilateObjectMorphology(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double objectValue=1) -> Image
    DilateObjectMorphology(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double objectValue=1) -> Image



    itk::simple::DilateObjectMorphologyImageFilter Functional Interface

    This function directly calls the execute method of DilateObjectMorphologyImageFilter in order to support a fully functional API


    """
    return _SimpleITK.DilateObjectMorphology(*args)
class DiscreteGaussianDerivativeImageFilter(ImageFilter_1):
    """


    Calculates image derivatives using discrete derivative gaussian
    kernels. This filter calculates Gaussian derivative by separable
    convolution of an image and a discrete Gaussian derivative operator
    (kernel).


    The Gaussian operators used here were described by Tony Lindeberg
    (Discrete Scale-Space Theory and the Scale-Space Primal Sketch.
    Dissertation. Royal Institute of Technology, Stockholm, Sweden. May
    1991.)

    The variance or standard deviation (sigma) will be evaluated as pixel
    units if SetUseImageSpacing is off (false) or as physical units if
    SetUseImageSpacing is on (true, default). The variance can be set
    independently in each dimension.

    When the Gaussian kernel is small, this filter tends to run faster
    than itk::RecursiveGaussianImageFilter .


    Ivan Macia, VICOMTech, Spain, http://www.vicomtech.es
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/1290


    See:
     GaussianDerivativeOperator

     Image

     Neighborhood

     NeighborhoodOperator

     itk::simple::DiscreteGaussianDerivative for the procedural interface

     itk::DiscreteGaussianDerivativeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDiscreteGaussianDerivativeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteGaussianDerivativeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteGaussianDerivativeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DiscreteGaussianDerivativeImageFilter self) -> DiscreteGaussianDerivativeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DiscreteGaussianDerivativeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DiscreteGaussianDerivativeImageFilter
    __del__ = lambda self: None

    def SetVariance(self, *args):
        """
        SetVariance(DiscreteGaussianDerivativeImageFilter self, VectorDouble Variance)
        SetVariance(DiscreteGaussianDerivativeImageFilter self, double value)



        Set the values of the Variance vector all to value


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetVariance(self, *args)


    def GetVariance(self):
        """
        GetVariance(DiscreteGaussianDerivativeImageFilter self) -> VectorDouble



        The variance for the discrete Gaussian kernel. Sets the variance
        independently for each dimension, but see also SetVariance(const double v) . The default is 0.0 in each dimension. If UseImageSpacing is true,
        the units are the physical units of your image. If UseImageSpacing is
        false then the units are pixels.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetVariance(self)


    def SetOrder(self, *args):
        """
        SetOrder(DiscreteGaussianDerivativeImageFilter self, VectorUInt32 Order)
        SetOrder(DiscreteGaussianDerivativeImageFilter self, unsigned int value)



        Set the values of the Order vector all to value


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetOrder(self, *args)


    def GetOrder(self):
        """
        GetOrder(DiscreteGaussianDerivativeImageFilter self) -> VectorUInt32



        Order of derivatives in each dimension. Sets the derivative order
        independently for each dimension, but see also SetOrder(const unsigned int v) . The default is 1 in each dimension.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetOrder(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(DiscreteGaussianDerivativeImageFilter self, unsigned int MaximumKernelWidth)



        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(DiscreteGaussianDerivativeImageFilter self) -> unsigned int



        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(DiscreteGaussianDerivativeImageFilter self, double MaximumError)



        Convenience Set methods for setting all dimensional parameters to the
        same values.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(DiscreteGaussianDerivativeImageFilter self) -> double



        The algorithm will size the discrete kernel so that the error
        resulting from truncation of the kernel is no greater than
        MaximumError. The default is 0.01 in each dimension.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetMaximumError(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DiscreteGaussianDerivativeImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Default is ImageSpacingOn.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DiscreteGaussianDerivativeImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DiscreteGaussianDerivativeImageFilter self)



        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DiscreteGaussianDerivativeImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations. Default is ImageSpacingOn.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetUseImageSpacing(self)


    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        """
        SetNormalizeAcrossScale(DiscreteGaussianDerivativeImageFilter self, bool NormalizeAcrossScale)



        Set/Get the flag for calculating scale-space normalized derivatives.
        Normalized derivatives are obtained multiplying by the scale parameter
        t.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_SetNormalizeAcrossScale(self, NormalizeAcrossScale)


    def NormalizeAcrossScaleOn(self):
        """
        NormalizeAcrossScaleOn(DiscreteGaussianDerivativeImageFilter self)



        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_NormalizeAcrossScaleOn(self)


    def NormalizeAcrossScaleOff(self):
        """
        NormalizeAcrossScaleOff(DiscreteGaussianDerivativeImageFilter self)



        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_NormalizeAcrossScaleOff(self)


    def GetNormalizeAcrossScale(self):
        """
        GetNormalizeAcrossScale(DiscreteGaussianDerivativeImageFilter self) -> bool



        Set/Get the flag for calculating scale-space normalized derivatives.
        Normalized derivatives are obtained multiplying by the scale parameter
        t.


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetNormalizeAcrossScale(self)


    def GetName(self):
        """
        GetName(DiscreteGaussianDerivativeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DiscreteGaussianDerivativeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DiscreteGaussianDerivativeImageFilter self, Image image1) -> Image
        Execute(DiscreteGaussianDerivativeImageFilter self, Image image1, VectorDouble variance, VectorUInt32 order, unsigned int maximumKernelWidth, double maximumError, bool useImageSpacing, bool normalizeAcrossScale) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DiscreteGaussianDerivativeImageFilter_Execute(self, *args)

DiscreteGaussianDerivativeImageFilter_swigregister = _SimpleITK.DiscreteGaussianDerivativeImageFilter_swigregister
DiscreteGaussianDerivativeImageFilter_swigregister(DiscreteGaussianDerivativeImageFilter)


def DiscreteGaussianDerivative(*args, **kwargs):
    """
    DiscreteGaussianDerivative(Image image1, VectorDouble variance, VectorUInt32 order, unsigned int maximumKernelWidth=32, double maximumError=0.01, bool useImageSpacing=True, bool normalizeAcrossScale=False) -> Image



    Calculates image derivatives using discrete derivative gaussian
    kernels. This filter calculates Gaussian derivative by separable
    convolution of an image and a discrete Gaussian derivative operator
    (kernel).


    This function directly calls the execute method of DiscreteGaussianDerivativeImageFilter in order to support a procedural API


    See:
     itk::simple::DiscreteGaussianDerivativeImageFilter for the object oriented interface



    """
    return _SimpleITK.DiscreteGaussianDerivative(*args, **kwargs)
class DiscreteGaussianImageFilter(ImageFilter_1):
    """


    Blurs an image by separable convolution with discrete gaussian
    kernels. This filter performs Gaussian blurring by separable
    convolution of an image and a discrete Gaussian operator (kernel).


    The Gaussian operator used here was described by Tony Lindeberg
    (Discrete Scale-Space Theory and the Scale-Space Primal Sketch.
    Dissertation. Royal Institute of Technology, Stockholm, Sweden. May
    1991.) The Gaussian kernel used here was designed so that smoothing
    and derivative operations commute after discretization.

    The variance or standard deviation (sigma) will be evaluated as pixel
    units if SetUseImageSpacing is off (false) or as physical units if
    SetUseImageSpacing is on (true, default). The variance can be set
    independently in each dimension.

    When the Gaussian kernel is small, this filter tends to run faster
    than itk::RecursiveGaussianImageFilter .


    See:
     GaussianOperator

     Image

     Neighborhood

     NeighborhoodOperator

     RecursiveGaussianImageFilter
    Wiki Examples:

    All Examples

    Smooth an image with a discrete Gaussian filter
    See:
     itk::simple::DiscreteGaussian for the procedural interface

     itk::DiscreteGaussianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkDiscreteGaussianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteGaussianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteGaussianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DiscreteGaussianImageFilter self) -> DiscreteGaussianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DiscreteGaussianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DiscreteGaussianImageFilter
    __del__ = lambda self: None

    def SetVariance(self, Variance):
        """
        SetVariance(DiscreteGaussianImageFilter self, double Variance)



        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetVariance(self, Variance)


    def GetVariance(self):
        """
        GetVariance(DiscreteGaussianImageFilter self) -> double



        The variance for the discrete Gaussian kernel. Sets the variance
        independently for each dimension, but see also SetVariance(const double v) . The default is 0.0 in each dimension. If UseImageSpacing is true,
        the units are the physical units of your image. If UseImageSpacing is
        false then the units are pixels.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetVariance(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(DiscreteGaussianImageFilter self, unsigned int MaximumKernelWidth)



        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(DiscreteGaussianImageFilter self) -> unsigned int



        Set the kernel to be no wider than MaximumKernelWidth pixels, even if
        MaximumError demands it. The default is 32 pixels.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(DiscreteGaussianImageFilter self, double MaximumError)



        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(DiscreteGaussianImageFilter self) -> double



        The algorithm will size the discrete kernel so that the error
        resulting from truncation of the kernel is no greater than
        MaximumError. The default is 0.01 in each dimension.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetMaximumError(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DiscreteGaussianImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.DiscreteGaussianImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DiscreteGaussianImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DiscreteGaussianImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DiscreteGaussianImageFilter self)



        """
        return _SimpleITK.DiscreteGaussianImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DiscreteGaussianImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(DiscreteGaussianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DiscreteGaussianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DiscreteGaussianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DiscreteGaussianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DiscreteGaussianImageFilter self, Image image1) -> Image
        Execute(DiscreteGaussianImageFilter self, Image image1, double variance, unsigned int maximumKernelWidth, double maximumError, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DiscreteGaussianImageFilter_Execute(self, *args)

DiscreteGaussianImageFilter_swigregister = _SimpleITK.DiscreteGaussianImageFilter_swigregister
DiscreteGaussianImageFilter_swigregister(DiscreteGaussianImageFilter)


def DiscreteGaussian(image1, variance=1.0, maximumKernelWidth=32, maximumError=0.01, useImageSpacing=True):
    """
    DiscreteGaussian(Image image1, double variance=1.0, unsigned int maximumKernelWidth=32, double maximumError=0.01, bool useImageSpacing=True) -> Image



    Blurs an image by separable convolution with discrete gaussian
    kernels. This filter performs Gaussian blurring by separable
    convolution of an image and a discrete Gaussian operator (kernel).


    This function directly calls the execute method of DiscreteGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::DiscreteGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.DiscreteGaussian(image1, variance, maximumKernelWidth, maximumError, useImageSpacing)
class DisplacementFieldJacobianDeterminantFilter(ImageFilter_1):
    """


    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].


    Overview
    This filter is based on itkVectorGradientMagnitudeImageFilter and
    supports the m_DerivativeWeights weights for partial derivatives.
     Note that the determinant of a zero vector field is also zero,
    whereas the Jacobian determinant of the corresponding identity warp
    transformation is 1.0. In order to compute the effective deformation
    Jacobian determinant 1.0 must be added to the diagonal elements of
    Jacobian prior to taking the derivative. i.e. det([ (1.0+dx/dx) dx/dy
    dx/dz ; dy/dx (1.0+dy/dy) dy/dz; dz/dx dz/dy (1.0+dz/dz) ])

    Template Parameters (Input and Output)
    This filter has one required template parameter which defines the
    input image type. The pixel type of the input image is assumed to be a
    vector (e.g., itk::Vector , itk::RGBPixel , itk::FixedArray ). The scalar type of the vector components must be castable to
    floating point. Instantiating with an image of RGBPixel<unsigned
    short>, for example, is allowed, but the filter will convert it to an
    image of Vector<float,3> for processing.
     The second template parameter, TRealType, can be optionally specified
    to define the scalar numerical type used in calculations. This is the
    component type of the output image, which will be of
    itk::Vector<TRealType, N>, where N is the number of channels in the
    multiple component input image. The default type of TRealType is
    float. For extra precision, you may safely change this parameter to
    double.

    The third template parameter is the output image type. The third
    parameter will be automatically constructed from the first and second
    parameters, so it is not necessary (or advisable) to set this
    parameter explicitly. Given an M-channel input image with
    dimensionality N, and a numerical type specified as TRealType, the
    output image will be of type itk::Image<TRealType, N>.

    Filter Parameters
    The method SetUseImageSpacingOn will cause derivatives in the image to
    be scaled (inversely) with the pixel size of the input image,
    effectively taking derivatives in world coordinates (versus isotropic
    image space). SetUseImageSpacingOff turns this functionality off.
    Default is UseImageSpacingOn. The parameter UseImageSpacing can be set
    directly with the method SetUseImageSpacing(bool) .
     Weights can be applied to the derivatives directly using the
    SetDerivativeWeights method. Note that if UseImageSpacing is set to
    TRUE (ON), then these weights will be overridden by weights derived
    from the image spacing when the filter is updated. The argument to
    this method is a C array of TRealValue type.

    Constraints
    We use vnl_det for determinent computation, which only supports square
    matrices. So the vector dimension of the input image values must be
    equal to the image dimensions, which is trivially true for a
    deformation field that maps an n-dimensional space onto itself.
     Currently, dimensions up to and including 4 are supported. This
    limitation comes from the presence of vnl_det() functions for matrices
    of dimension up to 4x4.

    The template parameter TRealType must be floating point (float or
    double) or a user-defined "real" numerical type with arithmetic
    operations defined sufficient to compute derivatives.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

    This class was adapted by

    Hans J. Johnson, The University of Iowa from code provided by
     Tom Vercauteren, INRIA & Mauna Kea Technologies

    Torsten Rohlfing, Neuroscience Program, SRI International.
    See:
     itk::simple::DisplacementFieldJacobianDeterminantFilter for the procedural interface

     itk::DisplacementFieldJacobianDeterminantFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDisplacementFieldJacobianDeterminantFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DisplacementFieldJacobianDeterminantFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DisplacementFieldJacobianDeterminantFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DisplacementFieldJacobianDeterminantFilter self) -> DisplacementFieldJacobianDeterminantFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DisplacementFieldJacobianDeterminantFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DisplacementFieldJacobianDeterminantFilter
    __del__ = lambda self: None

    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(DisplacementFieldJacobianDeterminantFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(DisplacementFieldJacobianDeterminantFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(DisplacementFieldJacobianDeterminantFilter self)



        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(DisplacementFieldJacobianDeterminantFilter self) -> bool



        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_GetUseImageSpacing(self)


    def SetDerivativeWeights(self, DerivativeWeights):
        """
        SetDerivativeWeights(DisplacementFieldJacobianDeterminantFilter self, VectorDouble DerivativeWeights)



        Directly Set/Get the array of weights used in the gradient
        calculations. Note that calling UseImageSpacingOn will clobber these
        values.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_SetDerivativeWeights(self, DerivativeWeights)


    def GetDerivativeWeights(self):
        """
        GetDerivativeWeights(DisplacementFieldJacobianDeterminantFilter self) -> VectorDouble



        Directly Set/Get the array of weights used in the gradient
        calculations. Note that calling UseImageSpacingOn will clobber these
        values.


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_GetDerivativeWeights(self)


    def GetName(self):
        """
        GetName(DisplacementFieldJacobianDeterminantFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_GetName(self)


    def __str__(self):
        """
        __str__(DisplacementFieldJacobianDeterminantFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DisplacementFieldJacobianDeterminantFilter self, Image image1) -> Image
        Execute(DisplacementFieldJacobianDeterminantFilter self, Image image1, bool useImageSpacing, VectorDouble derivativeWeights) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DisplacementFieldJacobianDeterminantFilter_Execute(self, *args)

DisplacementFieldJacobianDeterminantFilter_swigregister = _SimpleITK.DisplacementFieldJacobianDeterminantFilter_swigregister
DisplacementFieldJacobianDeterminantFilter_swigregister(DisplacementFieldJacobianDeterminantFilter)


def DisplacementFieldJacobianDeterminant(*args, **kwargs):
    """
    DisplacementFieldJacobianDeterminant(Image image1, bool useImageSpacing=True, VectorDouble derivativeWeights) -> Image



    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].


    This function directly calls the execute method of DisplacementFieldJacobianDeterminantFilter in order to support a procedural API


    See:
     itk::simple::DisplacementFieldJacobianDeterminantFilter for the object oriented interface



    """
    return _SimpleITK.DisplacementFieldJacobianDeterminant(*args, **kwargs)
class DivideFloorImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::DivideFloor for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkDivideFloorImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DivideFloorImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DivideFloorImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DivideFloorImageFilter self) -> DivideFloorImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DivideFloorImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DivideFloorImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(DivideFloorImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DivideFloorImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DivideFloorImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DivideFloorImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DivideFloorImageFilter self, Image image1, Image image2) -> Image
        Execute(DivideFloorImageFilter self, Image image1, double constant) -> Image
        Execute(DivideFloorImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.DivideFloorImageFilter_Execute(self, *args)

DivideFloorImageFilter_swigregister = _SimpleITK.DivideFloorImageFilter_swigregister
DivideFloorImageFilter_swigregister(DivideFloorImageFilter)


def DivideFloor(*args):
    """
    DivideFloor(Image image1, Image image2) -> Image
    DivideFloor(Image image1, double constant) -> Image
    DivideFloor(double constant, Image image2) -> Image



    """
    return _SimpleITK.DivideFloor(*args)
class DivideImageFilter(ImageFilter_2):
    """


    Pixel-wise division of two images.


    This class is templated over the types of the two input images and the
    type of the output image. When the divisor is zero, the division
    result is set to the maximum number that can be represented by default
    to avoid exception. Numeric conversions (castings) are done by the C++
    defaults.

    Wiki Examples:

    All Examples

    Pixel-wise division of two images
    See:
     itk::simple::Divide for the procedural interface

     itk::DivideImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkDivideImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DivideImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DivideImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DivideImageFilter self) -> DivideImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DivideImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DivideImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(DivideImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DivideImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DivideImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DivideImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DivideImageFilter self, Image image1, Image image2) -> Image
        Execute(DivideImageFilter self, Image image1, double constant) -> Image
        Execute(DivideImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.DivideImageFilter_Execute(self, *args)

DivideImageFilter_swigregister = _SimpleITK.DivideImageFilter_swigregister
DivideImageFilter_swigregister(DivideImageFilter)


def Divide(*args):
    """
    Divide(Image image1, Image image2) -> Image
    Divide(Image image1, double constant) -> Image
    Divide(double constant, Image image2) -> Image



    """
    return _SimpleITK.Divide(*args)
class DivideRealImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::DivideReal for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkDivideRealImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DivideRealImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DivideRealImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DivideRealImageFilter self) -> DivideRealImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DivideRealImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DivideRealImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(DivideRealImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DivideRealImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DivideRealImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DivideRealImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DivideRealImageFilter self, Image image1, Image image2) -> Image
        Execute(DivideRealImageFilter self, Image image1, double constant) -> Image
        Execute(DivideRealImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.DivideRealImageFilter_Execute(self, *args)

DivideRealImageFilter_swigregister = _SimpleITK.DivideRealImageFilter_swigregister
DivideRealImageFilter_swigregister(DivideRealImageFilter)


def DivideReal(*args):
    """
    DivideReal(Image image1, Image image2) -> Image
    DivideReal(Image image1, double constant) -> Image
    DivideReal(double constant, Image image2) -> Image



    """
    return _SimpleITK.DivideReal(*args)
class DoubleThresholdImageFilter(ImageFilter_1):
    """


    Binarize an input image using double thresholding.


    Double threshold addresses the difficulty in selecting a threshold
    that will select the objects of interest without selecting extraneous
    objects. Double threshold considers two threshold ranges: a narrow
    range and a wide range (where the wide range encompasses the narrow
    range). If the wide range was used for a traditional threshold (where
    values inside the range map to the foreground and values outside the
    range map to the background), many extraneous pixels may survive the
    threshold operation. If the narrow range was used for a traditional
    threshold, then too few pixels may survive the threshold.

    Double threshold uses the narrow threshold image as a marker image and
    the wide threshold image as a mask image in the geodesic dilation.
    Essentially, the marker image (narrow threshold) is dilated but
    constrained to lie within the mask image (wide threshold). Thus, only
    the objects of interest (those pixels that survived the narrow
    threshold) are extracted but the those objects appear in the final
    image as they would have if the wide threshold was used.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::DoubleThreshold for the procedural interface

     itk::DoubleThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkDoubleThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::DoubleThresholdImageFilter self) -> DoubleThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_DoubleThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_DoubleThresholdImageFilter
    __del__ = lambda self: None

    def SetThreshold1(self, Threshold1):
        """
        SetThreshold1(DoubleThresholdImageFilter self, double Threshold1)



        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold1(self, Threshold1)


    def GetThreshold1(self):
        """
        GetThreshold1(DoubleThresholdImageFilter self) -> double



        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold1(self)


    def SetThreshold2(self, Threshold2):
        """
        SetThreshold2(DoubleThresholdImageFilter self, double Threshold2)



        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold2(self, Threshold2)


    def GetThreshold2(self):
        """
        GetThreshold2(DoubleThresholdImageFilter self) -> double



        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold2(self)


    def SetThreshold3(self, Threshold3):
        """
        SetThreshold3(DoubleThresholdImageFilter self, double Threshold3)



        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold3(self, Threshold3)


    def GetThreshold3(self):
        """
        GetThreshold3(DoubleThresholdImageFilter self) -> double



        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold3(self)


    def SetThreshold4(self, Threshold4):
        """
        SetThreshold4(DoubleThresholdImageFilter self, double Threshold4)



        Set the thresholds. Four thresholds should be specified. The two lower
        thresholds default to NumericTraits<InputPixelType>::NonpositiveMin() . The two upper thresholds default NumericTraits<InputPixelType>::max . Threshold1 <= Threshold2 <= Threshold3 <= Threshold4.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetThreshold4(self, Threshold4)


    def GetThreshold4(self):
        """
        GetThreshold4(DoubleThresholdImageFilter self) -> double



        Get the threshold values.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetThreshold4(self)


    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(DoubleThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(DoubleThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(DoubleThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::ZeroValue() .


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(DoubleThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetOutsideValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(DoubleThresholdImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.DoubleThresholdImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(DoubleThresholdImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.DoubleThresholdImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(DoubleThresholdImageFilter self)



        """
        return _SimpleITK.DoubleThresholdImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(DoubleThresholdImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(DoubleThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.DoubleThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(DoubleThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.DoubleThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(DoubleThresholdImageFilter self, Image image1) -> Image
        Execute(DoubleThresholdImageFilter self, Image image1, double threshold1, double threshold2, double threshold3, double threshold4, uint8_t insideValue, uint8_t outsideValue, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.DoubleThresholdImageFilter_Execute(self, *args)

DoubleThresholdImageFilter_swigregister = _SimpleITK.DoubleThresholdImageFilter_swigregister
DoubleThresholdImageFilter_swigregister(DoubleThresholdImageFilter)


def DoubleThreshold(image1, threshold1=0.0, threshold2=1.0, threshold3=254.0, threshold4=255.0, insideValue=1, outsideValue=0, fullyConnected=False):
    """
    DoubleThreshold(Image image1, double threshold1=0.0, double threshold2=1.0, double threshold3=254.0, double threshold4=255.0, uint8_t insideValue=1, uint8_t outsideValue=0, bool fullyConnected=False) -> Image



    Binarize an input image using double thresholding.


    This function directly calls the execute method of DoubleThresholdImageFilter in order to support a procedural API


    See:
     itk::simple::DoubleThresholdImageFilter for the object oriented interface



    """
    return _SimpleITK.DoubleThreshold(image1, threshold1, threshold2, threshold3, threshold4, insideValue, outsideValue, fullyConnected)
class EdgePotentialImageFilter(ImageFilter_1):
    """


    Computes the edge potential of an image from the image gradient.


    Input to this filter should be a CovariantVector image representing the image gradient.

    The filter expect both the input and output images to have the same
    number of dimensions, and the output to be of a scalar image type.
    See:
     itk::simple::EdgePotential for the procedural interface

     itk::EdgePotentialImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkEdgePotentialImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EdgePotentialImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EdgePotentialImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::EdgePotentialImageFilter self) -> EdgePotentialImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_EdgePotentialImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_EdgePotentialImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(EdgePotentialImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.EdgePotentialImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(EdgePotentialImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.EdgePotentialImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(EdgePotentialImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.EdgePotentialImageFilter_Execute(self, image1)

EdgePotentialImageFilter_swigregister = _SimpleITK.EdgePotentialImageFilter_swigregister
EdgePotentialImageFilter_swigregister(EdgePotentialImageFilter)


def EdgePotential(image1):
    """
    EdgePotential(Image image1) -> Image



    Computes the edge potential of an image from the image gradient.


    This function directly calls the execute method of EdgePotentialImageFilter in order to support a procedural API


    See:
     itk::simple::EdgePotentialImageFilter for the object oriented interface



    """
    return _SimpleITK.EdgePotential(image1)
class EqualImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::Equal for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkEqualImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EqualImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EqualImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::EqualImageFilter self) -> EqualImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_EqualImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_EqualImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(EqualImageFilter self, uint8_t BackgroundValue)



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(EqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(EqualImageFilter self, uint8_t ForegroundValue)



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(EqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.EqualImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(EqualImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.EqualImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(EqualImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.EqualImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(EqualImageFilter self, Image image1, Image image2) -> Image
        Execute(EqualImageFilter self, Image image1, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(EqualImageFilter self, Image image1, double constant) -> Image
        Execute(EqualImageFilter self, double constant, Image image2) -> Image
        Execute(EqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(EqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image



        """
        return _SimpleITK.EqualImageFilter_Execute(self, *args)

EqualImageFilter_swigregister = _SimpleITK.EqualImageFilter_swigregister
EqualImageFilter_swigregister(EqualImageFilter)


def Equal(*args):
    """
    Equal(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Equal(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Equal(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image



    """
    return _SimpleITK.Equal(*args)
class ErodeObjectMorphologyImageFilter(ImageFilter_1):
    """


    Erosion of an object in an image.


    Erosion of an image using binary morphology. Pixel values matching the
    object value are considered the "object" and all other pixels are
    "background". This is useful in processing mask images containing
    only one object.

    If the pixel covered by the center of the kernel has the pixel value
    ObjectValue and the pixel is adjacent to a non-object valued pixel,
    then the kernel is centered on the object-value pixel and neighboring
    pixels covered by the kernel are assigned the background value. The
    structuring element is assumed to be composed of binary values (zero
    or one).


    See:
     ObjectMorphologyImageFilter , BinaryFunctionErodeImageFilter

     BinaryErodeImageFilter

     itk::simple::ErodeObjectMorphology for the procedural interface

     itk::ErodeObjectMorphologyImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkErodeObjectMorphologyImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ErodeObjectMorphologyImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ErodeObjectMorphologyImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ErodeObjectMorphologyImageFilter self) -> ErodeObjectMorphologyImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ErodeObjectMorphologyImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ErodeObjectMorphologyImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.ErodeObjectMorphologyImageFilter_Annulus
    Ball = _SimpleITK.ErodeObjectMorphologyImageFilter_Ball
    Box = _SimpleITK.ErodeObjectMorphologyImageFilter_Box
    Cross = _SimpleITK.ErodeObjectMorphologyImageFilter_Cross

    def SetObjectValue(self, ObjectValue):
        """
        SetObjectValue(ErodeObjectMorphologyImageFilter self, double ObjectValue)



        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetObjectValue(self, ObjectValue)


    def GetObjectValue(self):
        """
        GetObjectValue(ErodeObjectMorphologyImageFilter self) -> double



        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetObjectValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(ErodeObjectMorphologyImageFilter self, double BackgroundValue)



        Set the value to be assigned to eroded pixels


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(ErodeObjectMorphologyImageFilter self) -> double



        Get the value to be assigned to eroded pixels


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetBackgroundValue(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(ErodeObjectMorphologyImageFilter self, uint32_t r)
        SetKernelRadius(ErodeObjectMorphologyImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(ErodeObjectMorphologyImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(ErodeObjectMorphologyImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(ErodeObjectMorphologyImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(ErodeObjectMorphologyImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ErodeObjectMorphologyImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ErodeObjectMorphologyImageFilter self, Image image1) -> Image
        Execute(ErodeObjectMorphologyImageFilter self, Image image1, double objectValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ErodeObjectMorphologyImageFilter_Execute(self, *args)

ErodeObjectMorphologyImageFilter_swigregister = _SimpleITK.ErodeObjectMorphologyImageFilter_swigregister
ErodeObjectMorphologyImageFilter_swigregister(ErodeObjectMorphologyImageFilter)


def ErodeObjectMorphology(*args):
    """
    ErodeObjectMorphology(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, double objectValue=1, double backgroundValue=0) -> Image
    ErodeObjectMorphology(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, double objectValue=1, double backgroundValue=0) -> Image



    itk::simple::ErodeObjectMorphologyImageFilter Functional Interface

    This function directly calls the execute method of ErodeObjectMorphologyImageFilter in order to support a fully functional API


    """
    return _SimpleITK.ErodeObjectMorphology(*args)
class ExpImageFilter(ImageFilter_1):
    """


    Computes the exponential function of each pixel.


    The computation is performed using std::exp(x).
    See:
     itk::simple::Exp for the procedural interface

     itk::ExpImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExpImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ExpImageFilter self) -> ExpImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ExpImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ExpImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ExpImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ExpImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ExpImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ExpImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ExpImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ExpImageFilter_Execute(self, image1)

ExpImageFilter_swigregister = _SimpleITK.ExpImageFilter_swigregister
ExpImageFilter_swigregister(ExpImageFilter)


def Exp(image1):
    """
    Exp(Image image1) -> Image



    Computes the exponential function of each pixel.


    This function directly calls the execute method of ExpImageFilter in order to support a procedural API


    See:
     itk::simple::ExpImageFilter for the object oriented interface



    """
    return _SimpleITK.Exp(image1)
class ExpNegativeImageFilter(ImageFilter_1):
    """


    Computes the function exp(-K.x) for each input pixel.


    Every output pixel is equal to std::exp(-K.x ). where x is the
    intensity of the homologous input pixel, and K is a user-provided
    constant.
    See:
     itk::simple::ExpNegative for the procedural interface

     itk::ExpNegativeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExpNegativeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpNegativeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpNegativeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ExpNegativeImageFilter self) -> ExpNegativeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ExpNegativeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ExpNegativeImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ExpNegativeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ExpNegativeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ExpNegativeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ExpNegativeImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ExpNegativeImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ExpNegativeImageFilter_Execute(self, image1)

ExpNegativeImageFilter_swigregister = _SimpleITK.ExpNegativeImageFilter_swigregister
ExpNegativeImageFilter_swigregister(ExpNegativeImageFilter)


def ExpNegative(image1):
    """
    ExpNegative(Image image1) -> Image



    Computes the function exp(-K.x) for each input pixel.


    This function directly calls the execute method of ExpNegativeImageFilter in order to support a procedural API


    See:
     itk::simple::ExpNegativeImageFilter for the object oriented interface



    """
    return _SimpleITK.ExpNegative(image1)
class ExpandImageFilter(ImageFilter_1):
    """


    Expand the size of an image by an integer factor in each dimension.


    ExpandImageFilter increases the size of an image by an integer factor in each dimension
    using a interpolation method. The output image size in each dimension
    is given by:

    OutputSize[j] = InputSize[j] * ExpandFactors[j]

    The output values are obtained by interpolating the input image. The
    default interpolation type used is the LinearInterpolateImageFunction . The user can specify a particular interpolation function via SetInterpolator() . Note that the input interpolator must derive from base class InterpolateImageFunction .

    This filter will produce an output with different pixel spacing that
    its input image such that:

    OutputSpacing[j] = InputSpacing[j] / ExpandFactors[j]

    The filter is templated over the input image type and the output image
    type.

    This filter is implemented as a multithreaded filter and supports
    streaming.


    WARNING:
    This filter only works for image with scalar pixel types. For vector
    images use VectorExpandImageFilter .
     This filter assumes that the input and output image has the same
    number of dimensions.


    See:
     InterpolateImageFunction

     LinearInterpolationImageFunction

     VectorExpandImageFilter

     itk::simple::Expand for the procedural interface

     itk::ExpandImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkExpandImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpandImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpandImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ExpandImageFilter self) -> ExpandImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ExpandImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ExpandImageFilter
    __del__ = lambda self: None

    def SetExpandFactor(self, e):
        """
        SetExpandFactor(ExpandImageFilter self, unsigned int e) -> ExpandImageFilter



        Custom public declarations


        """
        return _SimpleITK.ExpandImageFilter_SetExpandFactor(self, e)


    def SetExpandFactors(self, *args):
        """
        SetExpandFactors(ExpandImageFilter self, VectorUInt32 ExpandFactors)
        SetExpandFactors(ExpandImageFilter self, unsigned int value)



        Set the values of the ExpandFactors vector all to value


        """
        return _SimpleITK.ExpandImageFilter_SetExpandFactors(self, *args)


    def GetExpandFactors(self):
        """
        GetExpandFactors(ExpandImageFilter self) -> VectorUInt32



        Get the expand factors.


        """
        return _SimpleITK.ExpandImageFilter_GetExpandFactors(self)


    def SetInterpolator(self, Interpolator):
        """
        SetInterpolator(ExpandImageFilter self, itk::simple::InterpolatorEnum Interpolator)



        Get/Set the interpolator function.


        """
        return _SimpleITK.ExpandImageFilter_SetInterpolator(self, Interpolator)


    def GetInterpolator(self):
        """
        GetInterpolator(ExpandImageFilter self) -> itk::simple::InterpolatorEnum



        Get/Set the interpolator function.


        """
        return _SimpleITK.ExpandImageFilter_GetInterpolator(self)


    def GetName(self):
        """
        GetName(ExpandImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ExpandImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ExpandImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ExpandImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ExpandImageFilter self, Image image1) -> Image
        Execute(ExpandImageFilter self, Image image1, VectorUInt32 expandFactors, itk::simple::InterpolatorEnum interpolator) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ExpandImageFilter_Execute(self, *args)

ExpandImageFilter_swigregister = _SimpleITK.ExpandImageFilter_swigregister
ExpandImageFilter_swigregister(ExpandImageFilter)


def Expand(*args, **kwargs):
    """
    Expand(Image image1, VectorUInt32 expandFactors, itk::simple::InterpolatorEnum interpolator) -> Image



    Expand the size of an image by an integer factor in each dimension.


    This function directly calls the execute method of ExpandImageFilter in order to support a procedural API


    See:
     itk::simple::ExpandImageFilter for the object oriented interface



    """
    return _SimpleITK.Expand(*args, **kwargs)
class ExtractImageFilter(ImageFilter_1):
    """


    Decrease the image size by cropping the image to the selected region
    bounds.


    ExtractImageFilter changes the image boundary of an image by removing pixels outside the
    target region. The target region must be specified.

    ExtractImageFilter also collapses dimensions so that the input image may have more
    dimensions than the output image (i.e. 4-D input image to a 3-D output
    image). To specify what dimensions to collapse, the ExtractionRegion
    must be specified. For any dimension dim where
    ExtractionRegion.Size[dim] = 0, that dimension is collapsed. The index
    to collapse on is specified by ExtractionRegion.Index[dim]. For
    example, we have a image 4D = a 4x4x4x4 image, and we want to get a 3D
    image, 3D = a 4x4x4 image, specified as [x,y,z,2] from 4D (i.e. the
    3rd "time" slice from 4D). The ExtractionRegion.Size = [4,4,4,0] and
    ExtractionRegion.Index = [0,0,0,2].

    The number of dimension in ExtractionRegion.Size and Index must = InputImageDimension. The number of non-zero dimensions in
    ExtractionRegion.Size must = OutputImageDimension.

    The output image produced by this filter will have the same origin as
    the input image, while the ImageRegion of the output image will start at the starting index value provided
    in the ExtractRegion parameter. If you are looking for a filter that
    will re-compute the origin of the output image, and provide an output
    image region whose index is set to zeros, then you may want to use the RegionOfInterestImageFilter . The output spacing is is simply the collapsed version of the input
    spacing.

    Determining the direction of the collapsed output image from an larger
    dimensional input space is an ill defined problem in general. It is
    required that the application developer select the desired
    transformation strategy for collapsing direction cosigns. It is
    REQUIRED that a strategy be explicitly requested (i.e. there is no
    working default). Direction Collapsing Strategies: 1)
    DirectionCollapseToUnknown(); This is the default and the filter can
    not run when this is set. The reason is to explicitly force the
    application developer to define their desired behavior. 1)
    DirectionCollapseToIdentity(); Output has identity direction no matter
    what 2) DirectionCollapseToSubmatrix(); Output direction is the sub-
    matrix if it is positive definite, else throw an exception.

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.


    This filter is derived from InPlaceImageFilter . When the input to this filter matched the output requirested
    region, like with streaming filter for input, then setting this filter
    to run in-place will result in no copying of the bulk pixel data.

    See:
     CropImageFilter
    Wiki Examples:

    All Examples

    Crop an image by specifying the region to keep
    See:
     itk::simple::Extract for the procedural interface

     itk::ExtractImageFilter<InputImageType, typename InputImageType::template Rebind for the
    Doxygen on the original ITK class.



    C++ includes: sitkExtractImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExtractImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExtractImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ExtractImageFilter self) -> ExtractImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ExtractImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ExtractImageFilter
    __del__ = lambda self: None

    def SetSize(self, Size):
        """
        SetSize(ExtractImageFilter self, VectorUInt32 Size)



        """
        return _SimpleITK.ExtractImageFilter_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(ExtractImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ExtractImageFilter_GetSize(self)


    def SetIndex(self, Index):
        """
        SetIndex(ExtractImageFilter self, VectorInt32 Index)



        odo the internal setting of the method needs work!!!


        """
        return _SimpleITK.ExtractImageFilter_SetIndex(self, Index)


    def GetIndex(self):
        """
        GetIndex(ExtractImageFilter self) -> VectorInt32



        """
        return _SimpleITK.ExtractImageFilter_GetIndex(self)

    DIRECTIONCOLLAPSETOUNKOWN = _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOUNKOWN
    DIRECTIONCOLLAPSETOIDENTITY = _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOIDENTITY
    DIRECTIONCOLLAPSETOSUBMATRIX = _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOSUBMATRIX
    DIRECTIONCOLLAPSETOGUESS = _SimpleITK.ExtractImageFilter_DIRECTIONCOLLAPSETOGUESS

    def SetDirectionCollapseToStrategy(self, DirectionCollapseToStrategy):
        """
        SetDirectionCollapseToStrategy(ExtractImageFilter self, itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType DirectionCollapseToStrategy)



             Set the strategy to be used to collapse pysical space dimensions.

        itk::itkExtractImageFilter::DIRECTIONCOLLAPSETOIDENTITY Set the
        strategy so that all collapsed images have an identity direction. Use
        this strategy when you know that retention of the physical space
        orientation of the collapsed image is not important.

        itk::itkExtractImageFilter::DIRECTIONCOLLAPSETOGUESS Set the strategy
        so that all collapsed images where output direction is the sub-matrix
        it it is positive definite, else return identity. This is backwards
        compatible with ITKv3, but is highly discouraged because the results
        are difficult to anticipate under differing data scenerios.

        itk::itkExtractImageFilter::DIRECTIONCOLLAPSETOSUBMATRIX Set the
        strategy so that all collapsed images where output direction is the
        sub-matrix it it is positive definite, else throw an exception. Use
        this strategy when it is known that properly identified physical space
        sub-volumes can be reliably extracted from a higher dimensional space.
        For example when the application programmer knows that a 4D image is
        3D+time, and that the 3D sub-space is properly defined.


        """
        return _SimpleITK.ExtractImageFilter_SetDirectionCollapseToStrategy(self, DirectionCollapseToStrategy)


    def GetDirectionCollapseToStrategy(self):
        """
        GetDirectionCollapseToStrategy(ExtractImageFilter self) -> itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType



        NOTE: The SetDirectionCollapseToUknown is explicitly not defined. It
        is a state that a filter can be in only when it is first instantiate
        prior to being initialized. Get the currently set strategy for
        collapsing directions of physical space.


        """
        return _SimpleITK.ExtractImageFilter_GetDirectionCollapseToStrategy(self)


    def GetName(self):
        """
        GetName(ExtractImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ExtractImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ExtractImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ExtractImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ExtractImageFilter self, Image image1) -> Image
        Execute(ExtractImageFilter self, Image image1, VectorUInt32 size, VectorInt32 index, itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType directionCollapseToStrategy) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ExtractImageFilter_Execute(self, *args)

ExtractImageFilter_swigregister = _SimpleITK.ExtractImageFilter_swigregister
ExtractImageFilter_swigregister(ExtractImageFilter)


def Extract(*args, **kwargs):
    """
    Extract(Image image1, VectorUInt32 size, VectorInt32 index, itk::simple::ExtractImageFilter::DirectionCollapseToStrategyType directionCollapseToStrategy) -> Image



    Decrease the image size by cropping the image to the selected region
    bounds.


    This function directly calls the execute method of ExtractImageFilter in order to support a procedural API


    See:
     itk::simple::ExtractImageFilter for the object oriented interface



    """
    return _SimpleITK.Extract(*args, **kwargs)
class FFTConvolutionImageFilter(ImageFilter_2):
    """


    Convolve a given image with an arbitrary image kernel using
    multiplication in the Fourier domain.


    This filter produces output equivalent to the output of the ConvolutionImageFilter . However, it takes advantage of the convolution theorem to
    accelerate the convolution computation when the kernel is large.


    WARNING:
    This filter ignores the spacing, origin, and orientation of the kernel
    image and treats them as identical to those in the input image.
     This code was adapted from the Insight Journal contribution:

    "FFT Based Convolution" by Gaetan Lehmann https://hdl.handle.net/10380/3154


    See:
     ConvolutionImageFilter

     itk::simple::FFTConvolution for the procedural interface

     itk::FFTConvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTConvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FFTConvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FFTConvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FFTConvolutionImageFilter self) -> FFTConvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FFTConvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FFTConvolutionImageFilter
    __del__ = lambda self: None

    def SetNormalize(self, Normalize):
        """
        SetNormalize(FFTConvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.FFTConvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(FFTConvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.FFTConvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(FFTConvolutionImageFilter self)



        """
        return _SimpleITK.FFTConvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(FFTConvolutionImageFilter self) -> bool



        """
        return _SimpleITK.FFTConvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.FFTConvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.FFTConvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.FFTConvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(FFTConvolutionImageFilter self, itk::simple::FFTConvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.FFTConvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(FFTConvolutionImageFilter self) -> itk::simple::FFTConvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.FFTConvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.FFTConvolutionImageFilter_SAME
    VALID = _SimpleITK.FFTConvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(FFTConvolutionImageFilter self, itk::simple::FFTConvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.FFTConvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(FFTConvolutionImageFilter self) -> itk::simple::FFTConvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.FFTConvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(FFTConvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FFTConvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FFTConvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FFTConvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FFTConvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(FFTConvolutionImageFilter self, Image image1, Image image2, bool normalize, itk::simple::FFTConvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::FFTConvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.FFTConvolutionImageFilter_Execute(self, *args)

FFTConvolutionImageFilter_swigregister = _SimpleITK.FFTConvolutionImageFilter_swigregister
FFTConvolutionImageFilter_swigregister(FFTConvolutionImageFilter)


def FFTConvolution(*args, **kwargs):
    """
    FFTConvolution(Image image1, Image image2, bool normalize=False, itk::simple::FFTConvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::FFTConvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    Convolve a given image with an arbitrary image kernel using
    multiplication in the Fourier domain.


    This function directly calls the execute method of FFTConvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::FFTConvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.FFTConvolution(*args, **kwargs)
class FFTNormalizedCorrelationImageFilter(ImageFilter_2):
    """


    Calculate normalized cross correlation using FFTs.


    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general MaskedFFTNormalizedCorrelationImageFilter and operates by essentially setting the masks in that algorithm to
    images of ones. As described in detail in the references below, there
    is no computational overhead to utilizing the more general masked
    algorithm because the FFTs of the images of ones are still necessary
    for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain, all
    input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:


    WARNING:
    The pixel type of the output image must be of real type (float or
    double). ConceptChecking is used to enforce the output pixel type. You
    will get a compilation error if the pixel type of the output image is
    not float or double.
     References: 1) D. Padfield. "Masked object registration in the
    Fourier domain." Transactions on Image Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.


    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    See:
     itk::simple::FFTNormalizedCorrelation for the procedural interface

     itk::FFTNormalizedCorrelationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTNormalizedCorrelationImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FFTNormalizedCorrelationImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FFTNormalizedCorrelationImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FFTNormalizedCorrelationImageFilter self) -> FFTNormalizedCorrelationImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FFTNormalizedCorrelationImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FFTNormalizedCorrelationImageFilter
    __del__ = lambda self: None

    def SetRequiredNumberOfOverlappingPixels(self, RequiredNumberOfOverlappingPixels):
        """
        SetRequiredNumberOfOverlappingPixels(FFTNormalizedCorrelationImageFilter self, uint64_t RequiredNumberOfOverlappingPixels)



        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_SetRequiredNumberOfOverlappingPixels(self, RequiredNumberOfOverlappingPixels)


    def GetRequiredNumberOfOverlappingPixels(self):
        """
        GetRequiredNumberOfOverlappingPixels(FFTNormalizedCorrelationImageFilter self) -> uint64_t



        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_GetRequiredNumberOfOverlappingPixels(self)


    def GetName(self):
        """
        GetName(FFTNormalizedCorrelationImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FFTNormalizedCorrelationImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FFTNormalizedCorrelationImageFilter self, Image image1, Image image2) -> Image
        Execute(FFTNormalizedCorrelationImageFilter self, Image image1, Image image2, uint64_t requiredNumberOfOverlappingPixels) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.FFTNormalizedCorrelationImageFilter_Execute(self, *args)

FFTNormalizedCorrelationImageFilter_swigregister = _SimpleITK.FFTNormalizedCorrelationImageFilter_swigregister
FFTNormalizedCorrelationImageFilter_swigregister(FFTNormalizedCorrelationImageFilter)


def FFTNormalizedCorrelation(image1, image2, requiredNumberOfOverlappingPixels=0):
    """
    FFTNormalizedCorrelation(Image image1, Image image2, uint64_t requiredNumberOfOverlappingPixels=0) -> Image



    Calculate normalized cross correlation using FFTs.


    This function directly calls the execute method of FFTNormalizedCorrelationImageFilter in order to support a procedural API


    See:
     itk::simple::FFTNormalizedCorrelationImageFilter for the object oriented interface



    """
    return _SimpleITK.FFTNormalizedCorrelation(image1, image2, requiredNumberOfOverlappingPixels)
class FFTPadImageFilter(ImageFilter_1):
    """


    Pad an image to make it suitable for an FFT transformation.


    FFT filters usually requires a specific image size. The size is
    decomposed in several prime factors, and the filter only supports
    prime factors up to a maximum value. This filter automatically finds
    the greatest prime factor required by the available implementation and
    pads the input appropriately.

    This code was adapted from the Insight Journal contribution:

    "FFT Based Convolution" by Gaetan Lehmann https://hdl.handle.net/10380/3154


    Gaetan Lehmann

    See:
     FFTShiftImageFilter

     itk::simple::FFTPad for the procedural interface

     itk::FFTPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTPadImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FFTPadImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FFTPadImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FFTPadImageFilter self) -> FFTPadImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FFTPadImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FFTPadImageFilter
    __del__ = lambda self: None
    ZERO_PAD = _SimpleITK.FFTPadImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.FFTPadImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.FFTPadImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(FFTPadImageFilter self, itk::simple::FFTPadImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.FFTPadImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(FFTPadImageFilter self) -> itk::simple::FFTPadImageFilter::BoundaryConditionType



        """
        return _SimpleITK.FFTPadImageFilter_GetBoundaryCondition(self)


    def SetSizeGreatestPrimeFactor(self, SizeGreatestPrimeFactor):
        """
        SetSizeGreatestPrimeFactor(FFTPadImageFilter self, int SizeGreatestPrimeFactor)



        Set/Get the greatest prime factor allowed on the size of the padded
        image. The filter increase the size of the image to reach a size with
        the greatest prime factor smaller or equal to the specified value. The
        default value is 13, which is the greatest prime number for which the
        FFT are precomputed in FFTW, and thus gives very good performance. A
        greatest prime factor of 2 produce a size which is a power of 2, and
        thus is suitable for vnl base fft filters. A greatest prime factor of
        1 or less - typically 0 - disable the extra padding.


        """
        return _SimpleITK.FFTPadImageFilter_SetSizeGreatestPrimeFactor(self, SizeGreatestPrimeFactor)


    def GetSizeGreatestPrimeFactor(self):
        """
        GetSizeGreatestPrimeFactor(FFTPadImageFilter self) -> int



        Set/Get the greatest prime factor allowed on the size of the padded
        image. The filter increase the size of the image to reach a size with
        the greatest prime factor smaller or equal to the specified value. The
        default value is 13, which is the greatest prime number for which the
        FFT are precomputed in FFTW, and thus gives very good performance. A
        greatest prime factor of 2 produce a size which is a power of 2, and
        thus is suitable for vnl base fft filters. A greatest prime factor of
        1 or less - typically 0 - disable the extra padding.


        """
        return _SimpleITK.FFTPadImageFilter_GetSizeGreatestPrimeFactor(self)


    def GetName(self):
        """
        GetName(FFTPadImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FFTPadImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FFTPadImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FFTPadImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FFTPadImageFilter self, Image image1) -> Image
        Execute(FFTPadImageFilter self, Image image1, itk::simple::FFTPadImageFilter::BoundaryConditionType boundaryCondition, int sizeGreatestPrimeFactor) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FFTPadImageFilter_Execute(self, *args)

FFTPadImageFilter_swigregister = _SimpleITK.FFTPadImageFilter_swigregister
FFTPadImageFilter_swigregister(FFTPadImageFilter)


def FFTPad(*args, **kwargs):
    """
    FFTPad(Image image1, itk::simple::FFTPadImageFilter::BoundaryConditionType boundaryCondition, int sizeGreatestPrimeFactor=5) -> Image



    Pad an image to make it suitable for an FFT transformation.


    This function directly calls the execute method of FFTPadImageFilter in order to support a procedural API


    See:
     itk::simple::FFTPadImageFilter for the object oriented interface



    """
    return _SimpleITK.FFTPad(*args, **kwargs)
class FFTShiftImageFilter(ImageFilter_1):
    """


    Shift the zero-frequency components of a Fourier transfrom to the
    center of the image.


    The Fourier transform produces an image where the zero frequency
    components are in the corner of the image, making it difficult to
    understand. This filter shifts the component to the center of the
    image.


    For images with an odd-sized dimension, applying this filter twice
    will not produce the same image as the original one without using
    SetInverse(true) on one (and only one) of the two filters.
    https://hdl.handle.net/1926/321


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ForwardFFTImageFilter , InverseFFTImageFilter

     itk::simple::FFTShift for the procedural interface

     itk::FFTShiftImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFFTShiftImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FFTShiftImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FFTShiftImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FFTShiftImageFilter self) -> FFTShiftImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FFTShiftImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FFTShiftImageFilter
    __del__ = lambda self: None

    def SetInverse(self, Inverse):
        """
        SetInverse(FFTShiftImageFilter self, bool Inverse)



        Set/Get whether the filter must invert the transform or not. This
        option has no effect if none of the size of the input image is even,
        but is required to restore the original image if at least one of the
        dimensions has an odd size.


        """
        return _SimpleITK.FFTShiftImageFilter_SetInverse(self, Inverse)


    def InverseOn(self):
        """
        InverseOn(FFTShiftImageFilter self)



        Set the value of Inverse to true or false respectfully.


        """
        return _SimpleITK.FFTShiftImageFilter_InverseOn(self)


    def InverseOff(self):
        """
        InverseOff(FFTShiftImageFilter self)



        """
        return _SimpleITK.FFTShiftImageFilter_InverseOff(self)


    def GetInverse(self):
        """
        GetInverse(FFTShiftImageFilter self) -> bool



        Set/Get whether the filter must invert the transform or not. This
        option has no effect if none of the size of the input image is even,
        but is required to restore the original image if at least one of the
        dimensions has an odd size.


        """
        return _SimpleITK.FFTShiftImageFilter_GetInverse(self)


    def GetName(self):
        """
        GetName(FFTShiftImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FFTShiftImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FFTShiftImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FFTShiftImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FFTShiftImageFilter self, Image image1) -> Image
        Execute(FFTShiftImageFilter self, Image image1, bool inverse) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FFTShiftImageFilter_Execute(self, *args)

FFTShiftImageFilter_swigregister = _SimpleITK.FFTShiftImageFilter_swigregister
FFTShiftImageFilter_swigregister(FFTShiftImageFilter)


def FFTShift(image1, inverse=False):
    """
    FFTShift(Image image1, bool inverse=False) -> Image



    Shift the zero-frequency components of a Fourier transfrom to the
    center of the image.


    This function directly calls the execute method of FFTShiftImageFilter in order to support a procedural API


    See:
     itk::simple::FFTShiftImageFilter for the object oriented interface



    """
    return _SimpleITK.FFTShift(image1, inverse)
class FastApproximateRankImageFilter(ImageFilter_1):
    """


    A separable rank filter.


    Medians aren't separable, but if you want a large robust smoother to
    be relatively quick then it is worthwhile pretending that they are.

    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://hdl.handle.net/1926/555 http://www.insight-journal.org/browse/publication/160


    Richard Beare

    See:
     itk::simple::FastApproximateRank for the procedural interface

     itk::FastApproximateRankImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastApproximateRankImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FastApproximateRankImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FastApproximateRankImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FastApproximateRankImageFilter self) -> FastApproximateRankImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FastApproximateRankImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FastApproximateRankImageFilter
    __del__ = lambda self: None

    def SetRank(self, Rank):
        """
        SetRank(FastApproximateRankImageFilter self, double Rank)



        """
        return _SimpleITK.FastApproximateRankImageFilter_SetRank(self, Rank)


    def GetRank(self):
        """
        GetRank(FastApproximateRankImageFilter self) -> double



        """
        return _SimpleITK.FastApproximateRankImageFilter_GetRank(self)


    def SetRadius(self, *args):
        """
        SetRadius(FastApproximateRankImageFilter self, VectorUInt32 Radius)
        SetRadius(FastApproximateRankImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.FastApproximateRankImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(FastApproximateRankImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.FastApproximateRankImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(FastApproximateRankImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FastApproximateRankImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FastApproximateRankImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FastApproximateRankImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FastApproximateRankImageFilter self, Image image1) -> Image
        Execute(FastApproximateRankImageFilter self, Image image1, double rank, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FastApproximateRankImageFilter_Execute(self, *args)

FastApproximateRankImageFilter_swigregister = _SimpleITK.FastApproximateRankImageFilter_swigregister
FastApproximateRankImageFilter_swigregister(FastApproximateRankImageFilter)


def FastApproximateRank(*args, **kwargs):
    """
    FastApproximateRank(Image image1, double rank=0.5, VectorUInt32 radius) -> Image



    A separable rank filter.


    This function directly calls the execute method of FastApproximateRankImageFilter in order to support a procedural API


    See:
     itk::simple::FastApproximateRankImageFilter for the object oriented interface



    """
    return _SimpleITK.FastApproximateRank(*args, **kwargs)
class FastMarchingBaseImageFilter(ImageFilter_1):
    """


    Fast Marching Method on Image .


    The speed function can be specified as a speed image or a speed
    constant. The speed image is set using the method SetInput(). If the
    speed image is ITK_NULLPTR, a constant speed function is used and is
    specified using method the SetSpeedConstant() .

    If the speed function is constant and of value one, fast marching
    results is an approximate distance function from the initial alive
    points.

    There are two ways to specify the output image information (
    LargestPossibleRegion, Spacing, Origin):


    it is copied directly from the input speed image

    it is specified by the user. Default values are used if the user does
    not specify all the information.
     The output information is computed as follows.

    If the speed image is ITK_NULLPTR or if the OverrideOutputInformation
    is set to true, the output information is set from user specified
    parameters. These parameters can be specified using methods


    FastMarchingImageFilterBase::SetOutputRegion() ,

    FastMarchingImageFilterBase::SetOutputSpacing() ,

    FastMarchingImageFilterBase::SetOutputDirection() ,

    FastMarchingImageFilterBase::SetOutputOrigin() .
     Else the output information is copied from the input speed image.

    Implementation of this class is based on Chapter 8 of "Level Set
    Methods and Fast Marching Methods", J.A. Sethian, Cambridge Press,
    Second edition, 1999.

    TTraits

    traits


    See:
     ImageFastMarchingTraits

     ImageFastMarchingTraits2

     itk::simple::FastMarchingBase for the procedural interface

     itk::FastMarchingImageFilterBase for the Doxygen on the original ITK class.


    C++ includes: sitkFastMarchingBaseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FastMarchingBaseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FastMarchingBaseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FastMarchingBaseImageFilter self) -> FastMarchingBaseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FastMarchingBaseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FastMarchingBaseImageFilter
    __del__ = lambda self: None

    def SetNormalizationFactor(self, NormalizationFactor):
        """
        SetNormalizationFactor(FastMarchingBaseImageFilter self, double NormalizationFactor)



        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetNormalizationFactor(self, NormalizationFactor)


    def GetNormalizationFactor(self):
        """
        GetNormalizationFactor(FastMarchingBaseImageFilter self) -> double



        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetNormalizationFactor(self)


    def SetStoppingValue(self, StoppingValue):
        """
        SetStoppingValue(FastMarchingBaseImageFilter self, double StoppingValue)



        Set the Fast Marching algorithm Stopping Value. The Fast Marching
        algorithm is terminated when the value of the smallest trial point is
        greater than the stopping value.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetStoppingValue(self, StoppingValue)


    def GetStoppingValue(self):
        """
        GetStoppingValue(FastMarchingBaseImageFilter self) -> double



        Get the Fast Marching algorithm Stopping Value.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetStoppingValue(self)

    Nothing = _SimpleITK.FastMarchingBaseImageFilter_Nothing
    NoHandles = _SimpleITK.FastMarchingBaseImageFilter_NoHandles
    Strict = _SimpleITK.FastMarchingBaseImageFilter_Strict

    def SetTopologyCheck(self, TopologyCheck):
        """
        SetTopologyCheck(FastMarchingBaseImageFilter self, itk::simple::FastMarchingBaseImageFilter::TopologyCheckType TopologyCheck)



        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetTopologyCheck(self, TopologyCheck)


    def GetTopologyCheck(self):
        """
        GetTopologyCheck(FastMarchingBaseImageFilter self) -> itk::simple::FastMarchingBaseImageFilter::TopologyCheckType



        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetTopologyCheck(self)


    def SetTrialPoints(self, t):
        """
        SetTrialPoints(FastMarchingBaseImageFilter self, VectorUIntList t)



        Set trial points. The default trial value (i.e. 0.0) is used for each
        index.


        """
        return _SimpleITK.FastMarchingBaseImageFilter_SetTrialPoints(self, t)


    def AddTrialPoint(self, t):
        """
        AddTrialPoint(FastMarchingBaseImageFilter self, VectorUInt32 t)



        Add trial point


        """
        return _SimpleITK.FastMarchingBaseImageFilter_AddTrialPoint(self, t)


    def ClearTrialPoints(self):
        """
        ClearTrialPoints(FastMarchingBaseImageFilter self)



        Clear trial points


        """
        return _SimpleITK.FastMarchingBaseImageFilter_ClearTrialPoints(self)


    def GetTrialPoints(self):
        """
        GetTrialPoints(FastMarchingBaseImageFilter self) -> VectorUIntList



        Get trial points


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetTrialPoints(self)


    def GetName(self):
        """
        GetName(FastMarchingBaseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FastMarchingBaseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FastMarchingBaseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FastMarchingBaseImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FastMarchingBaseImageFilter self, Image image1) -> Image
        Execute(FastMarchingBaseImageFilter self, Image arg2, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue, itk::simple::FastMarchingBaseImageFilter::TopologyCheckType topologyCheck) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FastMarchingBaseImageFilter_Execute(self, *args)

FastMarchingBaseImageFilter_swigregister = _SimpleITK.FastMarchingBaseImageFilter_swigregister
FastMarchingBaseImageFilter_swigregister(FastMarchingBaseImageFilter)


def FastMarchingBase(*args, **kwargs):
    """
    FastMarchingBase(Image imageA, VectorUIntList trialPoints, double normalizationFactor=1.0, double stoppingValue, itk::simple::FastMarchingBaseImageFilter::TopologyCheckType topologyCheck) -> Image



    itk::simple::FastMarchingBaseImageFilter Functional Interface

    This function directly calls the execute method of FastMarchingBaseImageFilter in order to support a fully functional API


    """
    return _SimpleITK.FastMarchingBase(*args, **kwargs)
class FastMarchingImageFilter(ImageFilter_1):
    """


    Solve an Eikonal equation using Fast Marching.


    Fast marching solves an Eikonal equation where the speed is always
    non-negative and depends on the position only. Starting from an
    initial position on the front, fast marching systematically moves the
    front forward one grid point at a time.

    Updates are preformed using an entropy satisfy scheme where only
    "upwind" neighborhoods are used. This implementation of Fast
    Marching uses a std::priority_queue to locate the next proper grid
    position to update.

    Fast Marching sweeps through N grid points in (N log N) steps to
    obtain the arrival time value as the front propagates through the
    grid.

    Implementation of this class is based on Chapter 8 of "Level Set
    Methods and Fast Marching Methods", J.A. Sethian, Cambridge Press,
    Second edition, 1999.

    This class is templated over the level set image type and the speed
    image type. The initial front is specified by two containers: one
    containing the known points and one containing the trial points. Alive
    points are those that are already part of the object, and trial points
    are considered for inclusion. In order for the filter to evolve, at
    least some trial points must be specified. These can for instance be
    specified as the layer of pixels around the alive points.

    The speed function can be specified as a speed image or a speed
    constant. The speed image is set using the method SetInput() . If the
    speed image is ITK_NULLPTR, a constant speed function is used and is
    specified using method the SetSpeedConstant() .

    If the speed function is constant and of value one, fast marching
    results in an approximate distance function from the initial alive
    points. FastMarchingImageFilter is used in the ReinitializeLevelSetImageFilter object to create a signed distance function from the zero level set.

    The algorithm can be terminated early by setting an appropriate
    stopping value. The algorithm terminates when the current arrival time
    being processed is greater than the stopping value.

    There are two ways to specify the output image information (
    LargestPossibleRegion, Spacing, Origin): (a) it is copied directly
    from the input speed image or (b) it is specified by the user. Default
    values are used if the user does not specify all the information.

    The output information is computed as follows. If the speed image is
    ITK_NULLPTR or if the OverrideOutputInformation is set to true, the
    output information is set from user specified parameters. These
    parameters can be specified using methods SetOutputRegion() ,
    SetOutputSpacing() , SetOutputDirection() , and SetOutputOrigin() .
    Else if the speed image is not ITK_NULLPTR, the output information is
    copied from the input speed image.

    Possible Improvements: In the current implemenation,
    std::priority_queue only allows taking nodes out from the front and
    putting nodes in from the back. To update a value already on the heap,
    a new node is added to the heap. The defunct old node is left on the
    heap. When it is removed from the top, it will be recognized as
    invalid and not used. Future implementations can implement the heap in
    a different way allowing the values to be updated. This will generally
    require some sift-up and sift-down functions and an image of back-
    pointers going from the image to heap in order to locate the node
    which is to be updated.


    See:
     LevelSetTypeDefault

     itk::simple::FastMarching for the procedural interface

     itk::FastMarchingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastMarchingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FastMarchingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FastMarchingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FastMarchingImageFilter self) -> FastMarchingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FastMarchingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FastMarchingImageFilter
    __del__ = lambda self: None

    def SetTrialPoints(self, TrialPoints):
        """
        SetTrialPoints(FastMarchingImageFilter self, VectorUIntList TrialPoints)



        Set the container of Trial Points representing the initial front.
        Trial points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.FastMarchingImageFilter_SetTrialPoints(self, TrialPoints)


    def GetTrialPoints(self):
        """
        GetTrialPoints(FastMarchingImageFilter self) -> VectorUIntList



        Get the container of Trial Points representing the initial front.


        """
        return _SimpleITK.FastMarchingImageFilter_GetTrialPoints(self)


    def AddTrialPoint(self, point):
        """
        AddTrialPoint(FastMarchingImageFilter self, VectorUInt32 point)



        Add TrialPoints point.


        """
        return _SimpleITK.FastMarchingImageFilter_AddTrialPoint(self, point)


    def ClearTrialPoints(self):
        """
        ClearTrialPoints(FastMarchingImageFilter self)



        Remove all TrialPoints points.


        """
        return _SimpleITK.FastMarchingImageFilter_ClearTrialPoints(self)


    def SetNormalizationFactor(self, NormalizationFactor):
        """
        SetNormalizationFactor(FastMarchingImageFilter self, double NormalizationFactor)



        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingImageFilter_SetNormalizationFactor(self, NormalizationFactor)


    def GetNormalizationFactor(self):
        """
        GetNormalizationFactor(FastMarchingImageFilter self) -> double



        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingImageFilter_GetNormalizationFactor(self)


    def SetStoppingValue(self, StoppingValue):
        """
        SetStoppingValue(FastMarchingImageFilter self, double StoppingValue)



        Set the Fast Marching algorithm Stopping Value. The Fast Marching
        algorithm is terminated when the value of the smallest trial point is
        greater than the stopping value.


        """
        return _SimpleITK.FastMarchingImageFilter_SetStoppingValue(self, StoppingValue)


    def GetStoppingValue(self):
        """
        GetStoppingValue(FastMarchingImageFilter self) -> double



        Get the Fast Marching algorithm Stopping Value.


        """
        return _SimpleITK.FastMarchingImageFilter_GetStoppingValue(self)


    def GetName(self):
        """
        GetName(FastMarchingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FastMarchingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FastMarchingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FastMarchingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FastMarchingImageFilter self, Image image1) -> Image
        Execute(FastMarchingImageFilter self, Image image1, VectorUIntList trialPoints, double normalizationFactor, double stoppingValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FastMarchingImageFilter_Execute(self, *args)

FastMarchingImageFilter_swigregister = _SimpleITK.FastMarchingImageFilter_swigregister
FastMarchingImageFilter_swigregister(FastMarchingImageFilter)


def FastMarching(*args, **kwargs):
    """
    FastMarching(Image image1, VectorUIntList trialPoints, double normalizationFactor=1.0, double stoppingValue) -> Image



    Solve an Eikonal equation using Fast Marching.


    This function directly calls the execute method of FastMarchingImageFilter in order to support a procedural API


    See:
     itk::simple::FastMarchingImageFilter for the object oriented interface



    """
    return _SimpleITK.FastMarching(*args, **kwargs)
class FastMarchingUpwindGradientImageFilter(ImageFilter_1):
    """


    Generates the upwind gradient field of fast marching arrival times.


    This filter adds some extra functionality to its base class. While the
    solution T(x) of the Eikonal equation is being generated by the base
    class with the fast marching method, the filter generates the upwind
    gradient vectors of T(x), storing them in an image.

    Since the Eikonal equation generates the arrival times of a wave
    travelling at a given speed, the generated gradient vectors can be
    interpreted as the slowness (1/velocity) vectors of the front (the
    quantity inside the modulus operator in the Eikonal equation).

    Gradient vectors are computed using upwind finite differences, that
    is, information only propagates from points where the wavefront has
    already passed. This is consistent with how the fast marching method
    works.

    One more extra feature is the possibility to define a set of Target
    points where the propagation stops. This can be used to avoid
    computing the Eikonal solution for the whole domain. The front can be
    stopped either when one Target point is reached or all Target points
    are reached. The propagation can stop after a time TargetOffset has
    passed since the stop condition is met. This way the solution is
    computed a bit downstream the Target points, so that the level sets of
    T(x) corresponding to the Target are smooth.


    Luca Antiga Ph.D. Biomedical Technologies Laboratory, Bioengineering
    Department, Mario Negri Institute, Italy.

    See:
     itk::simple::FastMarchingUpwindGradient for the procedural interface

     itk::FastMarchingUpwindGradientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastMarchingUpwindGradientImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FastMarchingUpwindGradientImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FastMarchingUpwindGradientImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FastMarchingUpwindGradientImageFilter self) -> FastMarchingUpwindGradientImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FastMarchingUpwindGradientImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FastMarchingUpwindGradientImageFilter
    __del__ = lambda self: None

    def SetTrialPoints(self, TrialPoints):
        """
        SetTrialPoints(FastMarchingUpwindGradientImageFilter self, VectorUIntList TrialPoints)



        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetTrialPoints(self, TrialPoints)


    def GetTrialPoints(self):
        """
        GetTrialPoints(FastMarchingUpwindGradientImageFilter self) -> VectorUIntList



        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTrialPoints(self)


    def AddTrialPoint(self, point):
        """
        AddTrialPoint(FastMarchingUpwindGradientImageFilter self, VectorUInt32 point)



        Add TrialPoints point.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_AddTrialPoint(self, point)


    def ClearTrialPoints(self):
        """
        ClearTrialPoints(FastMarchingUpwindGradientImageFilter self)



        Remove all TrialPoints points.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_ClearTrialPoints(self)


    def SetNumberOfTargets(self, NumberOfTargets):
        """
        SetNumberOfTargets(FastMarchingUpwindGradientImageFilter self, unsigned int NumberOfTargets)



        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetNumberOfTargets(self, NumberOfTargets)


    def GetNumberOfTargets(self):
        """
        GetNumberOfTargets(FastMarchingUpwindGradientImageFilter self) -> unsigned int



        Get the number of targets.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetNumberOfTargets(self)


    def SetTargetPoints(self, TargetPoints):
        """
        SetTargetPoints(FastMarchingUpwindGradientImageFilter self, VectorUIntList TargetPoints)



        Set the container of Target Points. If a target point is reached, the
        propagation stops. Trial points are represented as a VectorContainer of LevelSetNodes.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetTargetPoints(self, TargetPoints)


    def GetTargetPoints(self):
        """
        GetTargetPoints(FastMarchingUpwindGradientImageFilter self) -> VectorUIntList



        Get the container of Target Points.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTargetPoints(self)


    def AddTargetPoint(self, point):
        """
        AddTargetPoint(FastMarchingUpwindGradientImageFilter self, VectorUInt32 point)



        Add TargetPoints point.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_AddTargetPoint(self, point)


    def ClearTargetPoints(self):
        """
        ClearTargetPoints(FastMarchingUpwindGradientImageFilter self)



        Remove all TargetPoints points.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_ClearTargetPoints(self)


    def SetTargetOffset(self, TargetOffset):
        """
        SetTargetOffset(FastMarchingUpwindGradientImageFilter self, double TargetOffset)



        Set how long (in terms of arrival times) after targets are reached the
        front must stop. This is useful to ensure that the level set of target
        arrival time is smooth.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetTargetOffset(self, TargetOffset)


    def GetTargetOffset(self):
        """
        GetTargetOffset(FastMarchingUpwindGradientImageFilter self) -> double



        Get the TargetOffset ivar.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTargetOffset(self)


    def SetNormalizationFactor(self, NormalizationFactor):
        """
        SetNormalizationFactor(FastMarchingUpwindGradientImageFilter self, double NormalizationFactor)



        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_SetNormalizationFactor(self, NormalizationFactor)


    def GetNormalizationFactor(self):
        """
        GetNormalizationFactor(FastMarchingUpwindGradientImageFilter self) -> double



        Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer
        pixel types to represent the speed.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetNormalizationFactor(self)


    def GetGradientImage(self):
        """
        GetGradientImage(FastMarchingUpwindGradientImageFilter self) -> Image



        Get the gradient image.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetGradientImage(self)


    def GetTargetValue(self):
        """
        GetTargetValue(FastMarchingUpwindGradientImageFilter self) -> double



        Get the arrival time corresponding to the last reached target. If
        TargetReachedMode is set to NoTargets, TargetValue contains the last
        (aka largest) Eikonal solution value generated.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetTargetValue(self)


    def GetName(self):
        """
        GetName(FastMarchingUpwindGradientImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FastMarchingUpwindGradientImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FastMarchingUpwindGradientImageFilter self, Image image1) -> Image
        Execute(FastMarchingUpwindGradientImageFilter self, Image image1, VectorUIntList trialPoints, unsigned int numberOfTargets, VectorUIntList targetPoints, double targetOffset, double normalizationFactor) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FastMarchingUpwindGradientImageFilter_Execute(self, *args)

FastMarchingUpwindGradientImageFilter_swigregister = _SimpleITK.FastMarchingUpwindGradientImageFilter_swigregister
FastMarchingUpwindGradientImageFilter_swigregister(FastMarchingUpwindGradientImageFilter)


def FastMarchingUpwindGradient(*args, **kwargs):
    """
    FastMarchingUpwindGradient(Image image1, VectorUIntList trialPoints, unsigned int numberOfTargets=0, VectorUIntList targetPoints, double targetOffset=1, double normalizationFactor=1.0) -> Image



    Generates the upwind gradient field of fast marching arrival times.


    This function directly calls the execute method of FastMarchingUpwindGradientImageFilter in order to support a procedural API


    See:
     itk::simple::FastMarchingUpwindGradientImageFilter for the object oriented interface



    """
    return _SimpleITK.FastMarchingUpwindGradient(*args, **kwargs)
class FastSymmetricForcesDemonsRegistrationFilter(ImageFilter_0):
    """


    Deformably register two images using a symmetric forces demons
    algorithm.


    This class was contributed by Tom Vercauteren, INRIA & Mauna Kea
    Technologies based on a variation of the DemonsRegistrationFilter .

    FastSymmetricForcesDemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the deformation field which will map a moving image onto
    a fixed image.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    Tom Vercauteren, INRIA & Mauna Kea Technologies
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/510


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.

    See:
     DemonsRegistrationFilter

     DemonsRegistrationFunction

     itk::FastSymmetricForcesDemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkFastSymmetricForcesDemonsRegistrationFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FastSymmetricForcesDemonsRegistrationFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FastSymmetricForcesDemonsRegistrationFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FastSymmetricForcesDemonsRegistrationFilter self) -> FastSymmetricForcesDemonsRegistrationFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FastSymmetricForcesDemonsRegistrationFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FastSymmetricForcesDemonsRegistrationFilter
    __del__ = lambda self: None

    def SetStandardDeviations(self, *args):
        """
        SetStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, double value)



        Set the values of the StandardDeviations vector all to value


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetStandardDeviations(self, *args)


    def GetStandardDeviations(self):
        """
        GetStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self) -> VectorDouble



        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetStandardDeviations(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(FastSymmetricForcesDemonsRegistrationFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(FastSymmetricForcesDemonsRegistrationFilter self) -> uint32_t



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetNumberOfIterations(self)


    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(FastSymmetricForcesDemonsRegistrationFilter self, double MaximumRMSError)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(FastSymmetricForcesDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumRMSError(self)

    Symmetric = _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_Symmetric
    Fixed = _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_Fixed
    WarpedMoving = _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_WarpedMoving
    MappedMoving = _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_MappedMoving

    def SetUseGradientType(self, UseGradientType):
        """
        SetUseGradientType(FastSymmetricForcesDemonsRegistrationFilter self, itk::simple::FastSymmetricForcesDemonsRegistrationFilter::UseGradientTypeType UseGradientType)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetUseGradientType(self, UseGradientType)


    def GetUseGradientType(self):
        """
        GetUseGradientType(FastSymmetricForcesDemonsRegistrationFilter self) -> itk::simple::FastSymmetricForcesDemonsRegistrationFilter::UseGradientTypeType



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetUseGradientType(self)


    def SetMaximumUpdateStepLength(self, MaximumUpdateStepLength):
        """
        SetMaximumUpdateStepLength(FastSymmetricForcesDemonsRegistrationFilter self, double MaximumUpdateStepLength)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumUpdateStepLength(self, MaximumUpdateStepLength)


    def GetMaximumUpdateStepLength(self):
        """
        GetMaximumUpdateStepLength(FastSymmetricForcesDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumUpdateStepLength(self)


    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        """
        SetSmoothDisplacementField(FastSymmetricForcesDemonsRegistrationFilter self, bool SmoothDisplacementField)



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetSmoothDisplacementField(self, SmoothDisplacementField)


    def SmoothDisplacementFieldOn(self):
        """
        SmoothDisplacementFieldOn(FastSymmetricForcesDemonsRegistrationFilter self)



        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOn(self)


    def SmoothDisplacementFieldOff(self):
        """
        SmoothDisplacementFieldOff(FastSymmetricForcesDemonsRegistrationFilter self)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOff(self)


    def GetSmoothDisplacementField(self):
        """
        GetSmoothDisplacementField(FastSymmetricForcesDemonsRegistrationFilter self) -> bool



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetSmoothDisplacementField(self)


    def SetSmoothUpdateField(self, SmoothUpdateField):
        """
        SetSmoothUpdateField(FastSymmetricForcesDemonsRegistrationFilter self, bool SmoothUpdateField)



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetSmoothUpdateField(self, SmoothUpdateField)


    def SmoothUpdateFieldOn(self):
        """
        SmoothUpdateFieldOn(FastSymmetricForcesDemonsRegistrationFilter self)



        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOn(self)


    def SmoothUpdateFieldOff(self):
        """
        SmoothUpdateFieldOff(FastSymmetricForcesDemonsRegistrationFilter self)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOff(self)


    def GetSmoothUpdateField(self):
        """
        GetSmoothUpdateField(FastSymmetricForcesDemonsRegistrationFilter self) -> bool



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetSmoothUpdateField(self)


    def SetUpdateFieldStandardDeviations(self, *args):
        """
        SetUpdateFieldStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self, double value)



        Set the values of the UpdateFieldStandardDeviations vector all to
        value


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetUpdateFieldStandardDeviations(self, *args)


    def GetUpdateFieldStandardDeviations(self):
        """
        GetUpdateFieldStandardDeviations(FastSymmetricForcesDemonsRegistrationFilter self) -> VectorDouble



        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetUpdateFieldStandardDeviations(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(FastSymmetricForcesDemonsRegistrationFilter self, unsigned int MaximumKernelWidth)



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(FastSymmetricForcesDemonsRegistrationFilter self) -> unsigned int



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(FastSymmetricForcesDemonsRegistrationFilter self, double MaximumError)



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(FastSymmetricForcesDemonsRegistrationFilter self) -> double



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMaximumError(self)


    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        """
        SetIntensityDifferenceThreshold(FastSymmetricForcesDemonsRegistrationFilter self, double IntensityDifferenceThreshold)



        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold)


    def GetIntensityDifferenceThreshold(self):
        """
        GetIntensityDifferenceThreshold(FastSymmetricForcesDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetIntensityDifferenceThreshold(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(FastSymmetricForcesDemonsRegistrationFilter self, bool UseImageSpacing)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(FastSymmetricForcesDemonsRegistrationFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(FastSymmetricForcesDemonsRegistrationFilter self)



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(FastSymmetricForcesDemonsRegistrationFilter self) -> bool



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetUseImageSpacing(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(FastSymmetricForcesDemonsRegistrationFilter self) -> uint32_t



        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(FastSymmetricForcesDemonsRegistrationFilter self) -> double



        Set/Get the root mean squared change of the previous iteration. May
        not be used by all solvers.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetRMSChange(self)


    def GetMetric(self):
        """
        GetMetric(FastSymmetricForcesDemonsRegistrationFilter self) -> double



        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the the overlapping region between the two images. This
        value is calculated for the current iteration

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetMetric(self)


    def GetName(self):
        """
        GetName(FastSymmetricForcesDemonsRegistrationFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_GetName(self)


    def __str__(self):
        """
        __str__(FastSymmetricForcesDemonsRegistrationFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FastSymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(FastSymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image
        Execute(FastSymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, itk::simple::FastSymmetricForcesDemonsRegistrationFilter::UseGradientTypeType useGradientType, double maximumUpdateStepLength, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image
        Execute(FastSymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, itk::simple::FastSymmetricForcesDemonsRegistrationFilter::UseGradientTypeType useGradientType, double maximumUpdateStepLength, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image



        """
        return _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_Execute(self, *args)

FastSymmetricForcesDemonsRegistrationFilter_swigregister = _SimpleITK.FastSymmetricForcesDemonsRegistrationFilter_swigregister
FastSymmetricForcesDemonsRegistrationFilter_swigregister(FastSymmetricForcesDemonsRegistrationFilter)

class FlipImageFilter(ImageFilter_1):
    """


    Flips an image across user specified axes.


    FlipImageFilter flips an image across user specified axes. The flip axes are set via
    method SetFlipAxes( array ) where the input is a
    FixedArray<bool,ImageDimension>. The image is flipped across axes for
    which array[i] is true.

    In terms of grid coordinates the image is flipped within the
    LargestPossibleRegion of the input image. As such, the
    LargestPossibleRegion of the ouput image is the same as the input.

    In terms of geometric coordinates, the output origin is such that the
    image is flipped with respect to the coordinate axes.

    Wiki Examples:

    All Examples

    Flip an image over specified axes
    See:
     itk::simple::Flip for the procedural interface

     itk::FlipImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkFlipImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlipImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlipImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::FlipImageFilter self) -> FlipImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_FlipImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_FlipImageFilter
    __del__ = lambda self: None

    def SetFlipAxes(self, FlipAxes):
        """
        SetFlipAxes(FlipImageFilter self, VectorBool FlipAxes)



        Set/Get the axis to be flipped. The image is flipped along axes for
        which array[i] is true.


        """
        return _SimpleITK.FlipImageFilter_SetFlipAxes(self, FlipAxes)


    def GetFlipAxes(self):
        """
        GetFlipAxes(FlipImageFilter self) -> VectorBool



        Set/Get the axis to be flipped. The image is flipped along axes for
        which array[i] is true.


        """
        return _SimpleITK.FlipImageFilter_GetFlipAxes(self)


    def SetFlipAboutOrigin(self, FlipAboutOrigin):
        """
        SetFlipAboutOrigin(FlipImageFilter self, bool FlipAboutOrigin)



        Controls how the output origin is computed. If FlipAboutOrigin is
        "on", the flip will occur about the origin of the axis, otherwise,
        the flip will occur about the center of the axis.


        """
        return _SimpleITK.FlipImageFilter_SetFlipAboutOrigin(self, FlipAboutOrigin)


    def FlipAboutOriginOn(self):
        """
        FlipAboutOriginOn(FlipImageFilter self)



        Set the value of FlipAboutOrigin to true or false respectfully.


        """
        return _SimpleITK.FlipImageFilter_FlipAboutOriginOn(self)


    def FlipAboutOriginOff(self):
        """
        FlipAboutOriginOff(FlipImageFilter self)



        """
        return _SimpleITK.FlipImageFilter_FlipAboutOriginOff(self)


    def GetFlipAboutOrigin(self):
        """
        GetFlipAboutOrigin(FlipImageFilter self) -> bool



        Controls how the output origin is computed. If FlipAboutOrigin is
        "on", the flip will occur about the origin of the axis, otherwise,
        the flip will occur about the center of the axis.


        """
        return _SimpleITK.FlipImageFilter_GetFlipAboutOrigin(self)


    def GetName(self):
        """
        GetName(FlipImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.FlipImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(FlipImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.FlipImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(FlipImageFilter self, Image image1) -> Image
        Execute(FlipImageFilter self, Image image1, VectorBool flipAxes, bool flipAboutOrigin) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.FlipImageFilter_Execute(self, *args)

FlipImageFilter_swigregister = _SimpleITK.FlipImageFilter_swigregister
FlipImageFilter_swigregister(FlipImageFilter)


def Flip(*args, **kwargs):
    """
    Flip(Image image1, VectorBool flipAxes, bool flipAboutOrigin=False) -> Image



    Flips an image across user specified axes.


    This function directly calls the execute method of FlipImageFilter in order to support a procedural API


    See:
     itk::simple::FlipImageFilter for the object oriented interface



    """
    return _SimpleITK.Flip(*args, **kwargs)
class ForwardFFTImageFilter(ImageFilter_1):
    """


    Base class for forward Fast Fourier Transform .


    This is a base class for the "forward" or "direct" discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child class available on the system when the
    object is created via the object factory system.

    This class transforms a real input image into its full complex Fourier
    transform. The Fourier transform of a real input image has Hermitian
    symmetry: $ f(\\mathbf{x}) = f^*(-\\mathbf{x}) $ . That is, when the result of the transform is split in half along
    the x-dimension, the values in the second half of the transform are
    the complex conjugates of values in the first half reflected about the
    center of the image in each dimension.

    This filter works only for real single-component input image types.


    See:
     InverseFFTImageFilter , FFTComplexToComplexImageFilter

     itk::simple::ForwardFFT for the procedural interface

     itk::ForwardFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkForwardFFTImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ForwardFFTImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ForwardFFTImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ForwardFFTImageFilter self) -> ForwardFFTImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ForwardFFTImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ForwardFFTImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ForwardFFTImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ForwardFFTImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ForwardFFTImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ForwardFFTImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(ForwardFFTImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.ForwardFFTImageFilter_Execute(self, image1)

ForwardFFTImageFilter_swigregister = _SimpleITK.ForwardFFTImageFilter_swigregister
ForwardFFTImageFilter_swigregister(ForwardFFTImageFilter)


def ForwardFFT(image1):
    """
    ForwardFFT(Image image1) -> Image



    Base class for forward Fast Fourier Transform .


    This function directly calls the execute method of ForwardFFTImageFilter in order to support a procedural API


    See:
     itk::simple::ForwardFFTImageFilter for the object oriented interface



    """
    return _SimpleITK.ForwardFFT(image1)
class GaborImageSource(ImageFilter_0):
    """


    Generate an n-dimensional image of a Gabor filter.


    GaborImageSource generates an image of either the real (i.e. symmetric) or complex
    (i.e. antisymmetric) part of the Gabor filter with the orientation
    directed along the x-axis. The GaborKernelFunction is used to evaluate the contribution along the x-axis whereas a non-
    normalized 1-D Gaussian envelope provides the contribution in each of
    the remaining N dimensions. Orientation can be manipulated via the Transform classes of the toolkit.

    The output image may be of any dimension.

    This implementation was contributed as a paper to the Insight Journal https://hdl.handle.net/1926/500
    See:
     itk::simple::GaborImageSource for the procedural interface

     itk::GaborImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkGaborImageSource.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaborImageSource, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaborImageSource, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GaborImageSource self) -> GaborImageSource



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GaborImageSource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GaborImageSource
    __del__ = lambda self: None

    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(GaborImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)



        """
        return _SimpleITK.GaborImageSource_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(GaborImageSource self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.GaborImageSource_GetOutputPixelType(self)


    def SetSize(self, Size):
        """
        SetSize(GaborImageSource self, VectorUInt32 Size)



        """
        return _SimpleITK.GaborImageSource_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(GaborImageSource self) -> VectorUInt32



        """
        return _SimpleITK.GaborImageSource_GetSize(self)


    def SetSigma(self, *args):
        """
        SetSigma(GaborImageSource self, VectorDouble Sigma)
        SetSigma(GaborImageSource self, double value)



        Set the values of the Sigma vector all to value


        """
        return _SimpleITK.GaborImageSource_SetSigma(self, *args)


    def GetSigma(self):
        """
        GetSigma(GaborImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaborImageSource_GetSigma(self)


    def SetMean(self, *args):
        """
        SetMean(GaborImageSource self, VectorDouble Mean)
        SetMean(GaborImageSource self, double value)



        Set the values of the Mean vector all to value


        """
        return _SimpleITK.GaborImageSource_SetMean(self, *args)


    def GetMean(self):
        """
        GetMean(GaborImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaborImageSource_GetMean(self)


    def SetFrequency(self, Frequency):
        """
        SetFrequency(GaborImageSource self, double Frequency)



        """
        return _SimpleITK.GaborImageSource_SetFrequency(self, Frequency)


    def GetFrequency(self):
        """
        GetFrequency(GaborImageSource self) -> double



        """
        return _SimpleITK.GaborImageSource_GetFrequency(self)


    def SetOrigin(self, Origin):
        """
        SetOrigin(GaborImageSource self, VectorDouble Origin)



        """
        return _SimpleITK.GaborImageSource_SetOrigin(self, Origin)


    def GetOrigin(self):
        """
        GetOrigin(GaborImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaborImageSource_GetOrigin(self)


    def SetSpacing(self, Spacing):
        """
        SetSpacing(GaborImageSource self, VectorDouble Spacing)



        """
        return _SimpleITK.GaborImageSource_SetSpacing(self, Spacing)


    def GetSpacing(self):
        """
        GetSpacing(GaborImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaborImageSource_GetSpacing(self)


    def SetDirection(self, Direction):
        """
        SetDirection(GaborImageSource self, VectorDouble Direction)



        """
        return _SimpleITK.GaborImageSource_SetDirection(self, Direction)


    def GetDirection(self):
        """
        GetDirection(GaborImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaborImageSource_GetDirection(self)


    def GetName(self):
        """
        GetName(GaborImageSource self) -> std::string



        Name of this class


        """
        return _SimpleITK.GaborImageSource_GetName(self)


    def __str__(self):
        """
        __str__(GaborImageSource self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GaborImageSource___str__(self)


    def Execute(self, *args):
        """
        Execute(GaborImageSource self) -> Image
        Execute(GaborImageSource self, itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble sigma, VectorDouble mean, double frequency, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GaborImageSource_Execute(self, *args)

GaborImageSource_swigregister = _SimpleITK.GaborImageSource_swigregister
GaborImageSource_swigregister(GaborImageSource)


def GaborSource(*args, **kwargs):
    """
    GaborSource(itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble sigma, VectorDouble mean, double frequency=0.4, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



    Generate an n-dimensional image of a Gabor filter.


    This function directly calls the execute method of GaborImageSource in order to support a procedural API


    See:
     itk::simple::GaborImageSource for the object oriented interface



    """
    return _SimpleITK.GaborSource(*args, **kwargs)
class GaussianImageSource(ImageFilter_0):
    """


    Generate an n-dimensional image of a Gaussian.


    GaussianImageSource generates an image of a Gaussian. m_Normalized determines whether or
    not the Gaussian is normalized (whether or not the sum over infinite
    space is 1.0) When creating an image, it is preferable to not
    normalize the Gaussian m_Scale scales the output of the Gaussian to
    span a range larger than 0->1, and is typically set to the maximum
    value of the output data type (for instance, 255 for uchars)

    The output image may be of any dimension.
    See:
     itk::simple::GaussianImageSource for the procedural interface

     itk::GaussianImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkGaussianImageSource.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianImageSource, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianImageSource, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GaussianImageSource self) -> GaussianImageSource



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GaussianImageSource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GaussianImageSource
    __del__ = lambda self: None

    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(GaussianImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)



        """
        return _SimpleITK.GaussianImageSource_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(GaussianImageSource self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.GaussianImageSource_GetOutputPixelType(self)


    def SetSize(self, Size):
        """
        SetSize(GaussianImageSource self, VectorUInt32 Size)



        """
        return _SimpleITK.GaussianImageSource_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(GaussianImageSource self) -> VectorUInt32



        """
        return _SimpleITK.GaussianImageSource_GetSize(self)


    def SetSigma(self, *args):
        """
        SetSigma(GaussianImageSource self, VectorDouble Sigma)
        SetSigma(GaussianImageSource self, double value)



        Set the values of the Sigma vector all to value


        """
        return _SimpleITK.GaussianImageSource_SetSigma(self, *args)


    def GetSigma(self):
        """
        GetSigma(GaussianImageSource self) -> VectorDouble



        Gets and sets for Gaussian parameters


        """
        return _SimpleITK.GaussianImageSource_GetSigma(self)


    def SetMean(self, *args):
        """
        SetMean(GaussianImageSource self, VectorDouble Mean)
        SetMean(GaussianImageSource self, double value)



        Set the values of the Mean vector all to value


        """
        return _SimpleITK.GaussianImageSource_SetMean(self, *args)


    def GetMean(self):
        """
        GetMean(GaussianImageSource self) -> VectorDouble



        Gets and sets for Gaussian parameters


        """
        return _SimpleITK.GaussianImageSource_GetMean(self)


    def SetScale(self, Scale):
        """
        SetScale(GaussianImageSource self, double Scale)



        Gets and sets for Gaussian parameters


        """
        return _SimpleITK.GaussianImageSource_SetScale(self, Scale)


    def GetScale(self):
        """
        GetScale(GaussianImageSource self) -> double



        Gets and sets for Gaussian parameters


        """
        return _SimpleITK.GaussianImageSource_GetScale(self)


    def SetOrigin(self, Origin):
        """
        SetOrigin(GaussianImageSource self, VectorDouble Origin)



        """
        return _SimpleITK.GaussianImageSource_SetOrigin(self, Origin)


    def GetOrigin(self):
        """
        GetOrigin(GaussianImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaussianImageSource_GetOrigin(self)


    def SetSpacing(self, Spacing):
        """
        SetSpacing(GaussianImageSource self, VectorDouble Spacing)



        """
        return _SimpleITK.GaussianImageSource_SetSpacing(self, Spacing)


    def GetSpacing(self):
        """
        GetSpacing(GaussianImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaussianImageSource_GetSpacing(self)


    def SetDirection(self, Direction):
        """
        SetDirection(GaussianImageSource self, VectorDouble Direction)



        """
        return _SimpleITK.GaussianImageSource_SetDirection(self, Direction)


    def GetDirection(self):
        """
        GetDirection(GaussianImageSource self) -> VectorDouble



        """
        return _SimpleITK.GaussianImageSource_GetDirection(self)


    def GetName(self):
        """
        GetName(GaussianImageSource self) -> std::string



        Name of this class


        """
        return _SimpleITK.GaussianImageSource_GetName(self)


    def __str__(self):
        """
        __str__(GaussianImageSource self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GaussianImageSource___str__(self)


    def Execute(self, *args):
        """
        Execute(GaussianImageSource self) -> Image
        Execute(GaussianImageSource self, itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble sigma, VectorDouble mean, double scale, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GaussianImageSource_Execute(self, *args)

GaussianImageSource_swigregister = _SimpleITK.GaussianImageSource_swigregister
GaussianImageSource_swigregister(GaussianImageSource)


def GaussianSource(*args, **kwargs):
    """
    GaussianSource(itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble sigma, VectorDouble mean, double scale=255, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



    Generate an n-dimensional image of a Gaussian.


    This function directly calls the execute method of GaussianImageSource in order to support a procedural API


    See:
     itk::simple::GaussianImageSource for the object oriented interface



    """
    return _SimpleITK.GaussianSource(*args, **kwargs)
class GeodesicActiveContourLevelSetImageFilter(ImageFilter_2):
    """


    Segments structures in images based on a user supplied edge potential
    map.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the GeodesicActiveContourLevelSetFunction class contain additional information necessary to gain full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. An initial
    contour is propagated outwards (or inwards) until it ''sticks'' to the
    shape boundaries. This is done by using a level set speed function
    based on a user supplied edge potential map.
    INPUTS
    This filter requires two inputs. The first input is a initial level
    set. The initial level set is a real image which contains the initial
    contour/surface as the zero level set. For example, a signed distance
    function from the initial contour/surface is typically used. Unlike
    the simpler ShapeDetectionLevelSetImageFilter the initial contour does not have to lie wholly within the shape to
    be segmented. The initial contour is allow to overlap the shape
    boundary. The extra advection term in the update equation behaves like
    a doublet and attracts the contour to the boundary. This approach for
    segmentation follows that of Caselles et al (1997).

    The second input is the feature image. For this filter, this is the
    edge potential map. General characteristics of an edge potential map
    is that it has values close to zero in regions near the edges and
    values close to one inside the shape itself. Typically, the edge
    potential map is compute from the image gradient, for example:
    \\[ g(I) = 1 / ( 1 + | (\\nabla * G)(I)| ) \\] \\[ g(I) = \\exp^{-|(\\nabla * G)(I)|} \\]

    where $ I $ is image intensity and $ (\\nabla * G) $ is the derivative of Gaussian operator.


    See SegmentationLevelSetImageFilter and SparseFieldLevelSetImageFilter for more information on Inputs.
    PARAMETERS
    The PropagationScaling parameter can be used to switch from
    propagation outwards (POSITIVE scaling parameter) versus propagating
    inwards (NEGATIVE scaling parameter).
     This implementation allows the user to set the weights between the
    propagation, advection and curvature term using methods SetPropagationScaling() , SetAdvectionScaling() , SetCurvatureScaling() . In general, the larger the CurvatureScaling, the smoother the
    resulting contour. To follow the implementation in Caselles et al
    paper, set the PropagationScaling to $ c $ (the inflation or ballon force) and AdvectionScaling and
    CurvatureScaling both to 1.0.

    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Negative
    values in the output image represent the inside of the segmented
    region and positive values in the image represent the outside of the
    segmented region. The zero crossings of the image correspond to the
    position of the propagating front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    REFERENCES

    "Geodesic Active Contours", V. Caselles, R. Kimmel and G. Sapiro.
    International Journal on Computer Vision, Vol 22, No. 1, pp 61-97,
    1997

    See:
     SegmentationLevelSetImageFilter

     GeodesicActiveContourLevelSetFunction

     SparseFieldLevelSetImageFilter

     itk::simple::GeodesicActiveContourLevelSet for the procedural interface

     itk::GeodesicActiveContourLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGeodesicActiveContourLevelSetImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeodesicActiveContourLevelSetImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GeodesicActiveContourLevelSetImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GeodesicActiveContourLevelSetImageFilter self) -> GeodesicActiveContourLevelSetImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GeodesicActiveContourLevelSetImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GeodesicActiveContourLevelSetImageFilter
    __del__ = lambda self: None

    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(GeodesicActiveContourLevelSetImageFilter self, double MaximumRMSError)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(GeodesicActiveContourLevelSetImageFilter self) -> double



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetMaximumRMSError(self)


    def SetPropagationScaling(self, PropagationScaling):
        """
        SetPropagationScaling(GeodesicActiveContourLevelSetImageFilter self, double PropagationScaling)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetPropagationScaling(self, PropagationScaling)


    def GetPropagationScaling(self):
        """
        GetPropagationScaling(GeodesicActiveContourLevelSetImageFilter self) -> double



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetPropagationScaling(self)


    def SetCurvatureScaling(self, CurvatureScaling):
        """
        SetCurvatureScaling(GeodesicActiveContourLevelSetImageFilter self, double CurvatureScaling)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetCurvatureScaling(self, CurvatureScaling)


    def GetCurvatureScaling(self):
        """
        GetCurvatureScaling(GeodesicActiveContourLevelSetImageFilter self) -> double



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetCurvatureScaling(self)


    def SetAdvectionScaling(self, AdvectionScaling):
        """
        SetAdvectionScaling(GeodesicActiveContourLevelSetImageFilter self, double AdvectionScaling)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetAdvectionScaling(self, AdvectionScaling)


    def GetAdvectionScaling(self):
        """
        GetAdvectionScaling(GeodesicActiveContourLevelSetImageFilter self) -> double



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetAdvectionScaling(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(GeodesicActiveContourLevelSetImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(GeodesicActiveContourLevelSetImageFilter self) -> uint32_t



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetNumberOfIterations(self)


    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        """
        SetReverseExpansionDirection(GeodesicActiveContourLevelSetImageFilter self, bool ReverseExpansionDirection)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_SetReverseExpansionDirection(self, ReverseExpansionDirection)


    def ReverseExpansionDirectionOn(self):
        """
        ReverseExpansionDirectionOn(GeodesicActiveContourLevelSetImageFilter self)



        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_ReverseExpansionDirectionOn(self)


    def ReverseExpansionDirectionOff(self):
        """
        ReverseExpansionDirectionOff(GeodesicActiveContourLevelSetImageFilter self)



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_ReverseExpansionDirectionOff(self)


    def GetReverseExpansionDirection(self):
        """
        GetReverseExpansionDirection(GeodesicActiveContourLevelSetImageFilter self) -> bool



        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetReverseExpansionDirection(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(GeodesicActiveContourLevelSetImageFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(GeodesicActiveContourLevelSetImageFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetRMSChange(self)


    def GetName(self):
        """
        GetName(GeodesicActiveContourLevelSetImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GeodesicActiveContourLevelSetImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GeodesicActiveContourLevelSetImageFilter self, Image image1, Image image2) -> Image
        Execute(GeodesicActiveContourLevelSetImageFilter self, Image image1, Image image2, double maximumRMSError, double propagationScaling, double curvatureScaling, double advectionScaling, uint32_t numberOfIterations, bool reverseExpansionDirection) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.GeodesicActiveContourLevelSetImageFilter_Execute(self, *args)

GeodesicActiveContourLevelSetImageFilter_swigregister = _SimpleITK.GeodesicActiveContourLevelSetImageFilter_swigregister
GeodesicActiveContourLevelSetImageFilter_swigregister(GeodesicActiveContourLevelSetImageFilter)


def GeodesicActiveContourLevelSet(image1, image2, maximumRMSError=0.01, propagationScaling=1.0, curvatureScaling=1.0, advectionScaling=1.0, numberOfIterations=1000, reverseExpansionDirection=False):
    """
    GeodesicActiveContourLevelSet(Image image1, Image image2, double maximumRMSError=0.01, double propagationScaling=1.0, double curvatureScaling=1.0, double advectionScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image



    Segments structures in images based on a user supplied edge potential
    map.


    This function directly calls the execute method of GeodesicActiveContourLevelSetImageFilter in order to support a procedural API


    See:
     itk::simple::GeodesicActiveContourLevelSetImageFilter for the object oriented interface



    """
    return _SimpleITK.GeodesicActiveContourLevelSet(image1, image2, maximumRMSError, propagationScaling, curvatureScaling, advectionScaling, numberOfIterations, reverseExpansionDirection)
class GradientAnisotropicDiffusionImageFilter(ImageFilter_1):
    """


    This filter performs anisotropic diffusion on a scalar itk::Image using the classic Perona-Malik, gradient magnitude based equation
    implemented in itkGradientNDAnisotropicDiffusionFunction. For detailed
    information on anisotropic diffusion, see
    itkAnisotropicDiffusionFunction and
    itkGradientNDAnisotropicDiffusionFunction.

    Inputs and Outputs
    The input to this filter should be a scalar itk::Image of any dimensionality. The output image will be a diffused copy of
    the input.
    Parameters
    Please see the description of parameters given in
    itkAnisotropicDiffusionImageFilter.

    See:
     AnisotropicDiffusionImageFilter

     AnisotropicDiffusionFunction

     GradientAnisotropicDiffusionFunction

     itk::simple::GradientAnisotropicDiffusion for the procedural interface

     itk::GradientAnisotropicDiffusionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientAnisotropicDiffusionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GradientAnisotropicDiffusionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GradientAnisotropicDiffusionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GradientAnisotropicDiffusionImageFilter self) -> GradientAnisotropicDiffusionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GradientAnisotropicDiffusionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GradientAnisotropicDiffusionImageFilter
    __del__ = lambda self: None

    def SetTimeStep(self, TimeStep):
        """
        SetTimeStep(GradientAnisotropicDiffusionImageFilter self, double TimeStep)



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetTimeStep(self, TimeStep)


    def GetTimeStep(self):
        """
        GetTimeStep(GradientAnisotropicDiffusionImageFilter self) -> double



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetTimeStep(self)


    def SetConductanceParameter(self, ConductanceParameter):
        """
        SetConductanceParameter(GradientAnisotropicDiffusionImageFilter self, double ConductanceParameter)



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetConductanceParameter(self, ConductanceParameter)


    def GetConductanceParameter(self):
        """
        GetConductanceParameter(GradientAnisotropicDiffusionImageFilter self) -> double



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetConductanceParameter(self)


    def SetConductanceScalingUpdateInterval(self, ConductanceScalingUpdateInterval):
        """
        SetConductanceScalingUpdateInterval(GradientAnisotropicDiffusionImageFilter self, unsigned int ConductanceScalingUpdateInterval)



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetConductanceScalingUpdateInterval(self, ConductanceScalingUpdateInterval)


    def GetConductanceScalingUpdateInterval(self):
        """
        GetConductanceScalingUpdateInterval(GradientAnisotropicDiffusionImageFilter self) -> unsigned int



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetConductanceScalingUpdateInterval(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(GradientAnisotropicDiffusionImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(GradientAnisotropicDiffusionImageFilter self) -> uint32_t



        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetNumberOfIterations(self)


    def GetName(self):
        """
        GetName(GradientAnisotropicDiffusionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GradientAnisotropicDiffusionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GradientAnisotropicDiffusionImageFilter self, Image image1) -> Image
        Execute(GradientAnisotropicDiffusionImageFilter self, Image image1, double timeStep, double conductanceParameter, unsigned int conductanceScalingUpdateInterval, uint32_t numberOfIterations) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_Execute(self, *args)


    def EstimateOptimalTimeStep(self, inImage):
        """
        EstimateOptimalTimeStep(GradientAnisotropicDiffusionImageFilter self, Image inImage) -> double



        This method autmatically sets the optimal timestep for an image given
        its spacing.


        """
        return _SimpleITK.GradientAnisotropicDiffusionImageFilter_EstimateOptimalTimeStep(self, inImage)

GradientAnisotropicDiffusionImageFilter_swigregister = _SimpleITK.GradientAnisotropicDiffusionImageFilter_swigregister
GradientAnisotropicDiffusionImageFilter_swigregister(GradientAnisotropicDiffusionImageFilter)


def GradientAnisotropicDiffusion(image1, timeStep=0.125, conductanceParameter=3, conductanceScalingUpdateInterval=1, numberOfIterations=5):
    """
    GradientAnisotropicDiffusion(Image image1, double timeStep=0.125, double conductanceParameter=3, unsigned int conductanceScalingUpdateInterval=1, uint32_t numberOfIterations=5) -> Image



    itk::simple::GradientAnisotropicDiffusionImageFilter Procedural Interface


    This function directly calls the execute method of GradientAnisotropicDiffusionImageFilter in order to support a procedural API


    See:
     itk::simple::GradientAnisotropicDiffusionImageFilter for the object oriented interface



    """
    return _SimpleITK.GradientAnisotropicDiffusion(image1, timeStep, conductanceParameter, conductanceScalingUpdateInterval, numberOfIterations)
class GradientImageFilter(ImageFilter_1):
    """


    Computes the gradient of an image using directional derivatives.


    Computes the gradient of an image using directional derivatives. The
    directional derivative at each pixel location is computed by
    convolution with a first-order derivative operator.

    The second template parameter defines the value type used in the
    derivative operator (defaults to float). The third template parameter
    defines the value type used for output image (defaults to float). The
    output image is defined as a covariant vector image whose value type
    is specified as this third template parameter.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::Gradient for the procedural interface

     itk::GradientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGradientImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GradientImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GradientImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GradientImageFilter self) -> GradientImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GradientImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GradientImageFilter
    __del__ = lambda self: None

    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(GradientImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.GradientImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(GradientImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.GradientImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(GradientImageFilter self)



        """
        return _SimpleITK.GradientImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(GradientImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.GradientImageFilter_GetUseImageSpacing(self)


    def SetUseImageDirection(self, UseImageDirection):
        """
        SetUseImageDirection(GradientImageFilter self, bool UseImageDirection)



        The UseImageDirection flag determines whether image derivatives are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the derivatives are computed with
        respect to the coodinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientImageFilter_SetUseImageDirection(self, UseImageDirection)


    def UseImageDirectionOn(self):
        """
        UseImageDirectionOn(GradientImageFilter self)



        Set the value of UseImageDirection to true or false respectfully.


        """
        return _SimpleITK.GradientImageFilter_UseImageDirectionOn(self)


    def UseImageDirectionOff(self):
        """
        UseImageDirectionOff(GradientImageFilter self)



        """
        return _SimpleITK.GradientImageFilter_UseImageDirectionOff(self)


    def GetUseImageDirection(self):
        """
        GetUseImageDirection(GradientImageFilter self) -> bool



        The UseImageDirection flag determines whether image derivatives are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the derivatives are computed with
        respect to the coodinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientImageFilter_GetUseImageDirection(self)


    def GetName(self):
        """
        GetName(GradientImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GradientImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GradientImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GradientImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GradientImageFilter self, Image image1) -> Image
        Execute(GradientImageFilter self, Image image1, bool useImageSpacing, bool useImageDirection) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GradientImageFilter_Execute(self, *args)

GradientImageFilter_swigregister = _SimpleITK.GradientImageFilter_swigregister
GradientImageFilter_swigregister(GradientImageFilter)


def Gradient(image1, useImageSpacing=True, useImageDirection=False):
    """
    Gradient(Image image1, bool useImageSpacing=True, bool useImageDirection=False) -> Image



    Computes the gradient of an image using directional derivatives.


    This function directly calls the execute method of GradientImageFilter in order to support a procedural API


    See:
     itk::simple::GradientImageFilter for the object oriented interface



    """
    return _SimpleITK.Gradient(image1, useImageSpacing, useImageDirection)
class GradientMagnitudeImageFilter(ImageFilter_1):
    """


    Computes the gradient magnitude of an image region at each pixel.



    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Compute the gradient magnitude image
    See:
     itk::simple::GradientMagnitude for the procedural interface

     itk::GradientMagnitudeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGradientMagnitudeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GradientMagnitudeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GradientMagnitudeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GradientMagnitudeImageFilter self) -> GradientMagnitudeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GradientMagnitudeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GradientMagnitudeImageFilter
    __del__ = lambda self: None

    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(GradientMagnitudeImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.GradientMagnitudeImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(GradientMagnitudeImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.GradientMagnitudeImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(GradientMagnitudeImageFilter self)



        """
        return _SimpleITK.GradientMagnitudeImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(GradientMagnitudeImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.GradientMagnitudeImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(GradientMagnitudeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GradientMagnitudeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GradientMagnitudeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GradientMagnitudeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GradientMagnitudeImageFilter self, Image image1) -> Image
        Execute(GradientMagnitudeImageFilter self, Image image1, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GradientMagnitudeImageFilter_Execute(self, *args)

GradientMagnitudeImageFilter_swigregister = _SimpleITK.GradientMagnitudeImageFilter_swigregister
GradientMagnitudeImageFilter_swigregister(GradientMagnitudeImageFilter)


def GradientMagnitude(image1, useImageSpacing=True):
    """
    GradientMagnitude(Image image1, bool useImageSpacing=True) -> Image



    Computes the gradient magnitude of an image region at each pixel.


    This function directly calls the execute method of GradientMagnitudeImageFilter in order to support a procedural API


    See:
     itk::simple::GradientMagnitudeImageFilter for the object oriented interface



    """
    return _SimpleITK.GradientMagnitude(image1, useImageSpacing)
class GradientMagnitudeRecursiveGaussianImageFilter(ImageFilter_1):
    """


    Computes the Magnitude of the Gradient of an image by convolution with
    the first derivative of a Gaussian.


    This filter is implemented using the recursive gaussian filters

    Wiki Examples:

    All Examples

    Find the gradient magnitude of the image first smoothed with a
    Gaussian kernel
    See:
     itk::simple::GradientMagnitudeRecursiveGaussian for the procedural interface

     itk::GradientMagnitudeRecursiveGaussianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGradientMagnitudeRecursiveGaussianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GradientMagnitudeRecursiveGaussianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GradientMagnitudeRecursiveGaussianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GradientMagnitudeRecursiveGaussianImageFilter self) -> GradientMagnitudeRecursiveGaussianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GradientMagnitudeRecursiveGaussianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GradientMagnitudeRecursiveGaussianImageFilter
    __del__ = lambda self: None

    def SetSigma(self, Sigma):
        """
        SetSigma(GradientMagnitudeRecursiveGaussianImageFilter self, double Sigma)



        Set Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_SetSigma(self, Sigma)


    def GetSigma(self):
        """
        GetSigma(GradientMagnitudeRecursiveGaussianImageFilter self) -> double



        Set Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_GetSigma(self)


    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        """
        SetNormalizeAcrossScale(GradientMagnitudeRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)



        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_SetNormalizeAcrossScale(self, NormalizeAcrossScale)


    def NormalizeAcrossScaleOn(self):
        """
        NormalizeAcrossScaleOn(GradientMagnitudeRecursiveGaussianImageFilter self)



        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(self)


    def NormalizeAcrossScaleOff(self):
        """
        NormalizeAcrossScaleOff(GradientMagnitudeRecursiveGaussianImageFilter self)



        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(self)


    def GetNormalizeAcrossScale(self):
        """
        GetNormalizeAcrossScale(GradientMagnitudeRecursiveGaussianImageFilter self) -> bool



        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_GetNormalizeAcrossScale(self)


    def GetName(self):
        """
        GetName(GradientMagnitudeRecursiveGaussianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GradientMagnitudeRecursiveGaussianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GradientMagnitudeRecursiveGaussianImageFilter self, Image image1) -> Image
        Execute(GradientMagnitudeRecursiveGaussianImageFilter self, Image image1, double sigma, bool normalizeAcrossScale) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_Execute(self, *args)

GradientMagnitudeRecursiveGaussianImageFilter_swigregister = _SimpleITK.GradientMagnitudeRecursiveGaussianImageFilter_swigregister
GradientMagnitudeRecursiveGaussianImageFilter_swigregister(GradientMagnitudeRecursiveGaussianImageFilter)


def GradientMagnitudeRecursiveGaussian(image1, sigma=1.0, normalizeAcrossScale=False):
    """
    GradientMagnitudeRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False) -> Image



    Computes the Magnitude of the Gradient of an image by convolution with
    the first derivative of a Gaussian.


    This function directly calls the execute method of GradientMagnitudeRecursiveGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::GradientMagnitudeRecursiveGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.GradientMagnitudeRecursiveGaussian(image1, sigma, normalizeAcrossScale)
class GradientRecursiveGaussianImageFilter(ImageFilter_1):
    """


    Computes the gradient of an image by convolution with the first
    derivative of a Gaussian.


    This filter is implemented using the recursive gaussian filters.

    This filter supports both scalar and vector pixel types within the
    input image, including VectorImage type.

    Wiki Examples:

    All Examples

    Compute the gradient of an image by convolution with the first
    derivative of a Gaussian
    See:
     itk::simple::GradientRecursiveGaussian for the procedural interface

     itk::GradientRecursiveGaussianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGradientRecursiveGaussianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GradientRecursiveGaussianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GradientRecursiveGaussianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GradientRecursiveGaussianImageFilter self) -> GradientRecursiveGaussianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GradientRecursiveGaussianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GradientRecursiveGaussianImageFilter
    __del__ = lambda self: None

    def SetSigma(self, Sigma):
        """
        SetSigma(GradientRecursiveGaussianImageFilter self, double Sigma)



        Set Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_SetSigma(self, Sigma)


    def GetSigma(self):
        """
        GetSigma(GradientRecursiveGaussianImageFilter self) -> double



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetSigma(self)


    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        """
        SetNormalizeAcrossScale(GradientRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)



        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_SetNormalizeAcrossScale(self, NormalizeAcrossScale)


    def NormalizeAcrossScaleOn(self):
        """
        NormalizeAcrossScaleOn(GradientRecursiveGaussianImageFilter self)



        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(self)


    def NormalizeAcrossScaleOff(self):
        """
        NormalizeAcrossScaleOff(GradientRecursiveGaussianImageFilter self)



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(self)


    def GetNormalizeAcrossScale(self):
        """
        GetNormalizeAcrossScale(GradientRecursiveGaussianImageFilter self) -> bool



        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetNormalizeAcrossScale(self)


    def SetUseImageDirection(self, UseImageDirection):
        """
        SetUseImageDirection(GradientRecursiveGaussianImageFilter self, bool UseImageDirection)



        The UseImageDirection flag determines whether the gradients are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the gradients are computed with
        respect to the coodinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_SetUseImageDirection(self, UseImageDirection)


    def UseImageDirectionOn(self):
        """
        UseImageDirectionOn(GradientRecursiveGaussianImageFilter self)



        Set the value of UseImageDirection to true or false respectfully.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_UseImageDirectionOn(self)


    def UseImageDirectionOff(self):
        """
        UseImageDirectionOff(GradientRecursiveGaussianImageFilter self)



        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_UseImageDirectionOff(self)


    def GetUseImageDirection(self):
        """
        GetUseImageDirection(GradientRecursiveGaussianImageFilter self) -> bool



        The UseImageDirection flag determines whether the gradients are
        computed with respect to the image grid or with respect to the
        physical space. When this flag is ON the gradients are computed with
        respect to the coodinate system of physical space. The difference is
        whether we take into account the image Direction or not. The flag ON
        will take into account the image direction and will result in an extra
        matrix multiplication compared to the amount of computation performed
        when the flag is OFF. The default value of this flag is On.


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetUseImageDirection(self)


    def GetName(self):
        """
        GetName(GradientRecursiveGaussianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GradientRecursiveGaussianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GradientRecursiveGaussianImageFilter self, Image image1) -> Image
        Execute(GradientRecursiveGaussianImageFilter self, Image image1, double sigma, bool normalizeAcrossScale, bool useImageDirection) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GradientRecursiveGaussianImageFilter_Execute(self, *args)

GradientRecursiveGaussianImageFilter_swigregister = _SimpleITK.GradientRecursiveGaussianImageFilter_swigregister
GradientRecursiveGaussianImageFilter_swigregister(GradientRecursiveGaussianImageFilter)


def GradientRecursiveGaussian(image1, sigma=1.0, normalizeAcrossScale=False, useImageDirection=False):
    """
    GradientRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False, bool useImageDirection=False) -> Image



    Computes the gradient of an image by convolution with the first
    derivative of a Gaussian.


    This function directly calls the execute method of GradientRecursiveGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::GradientRecursiveGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.GradientRecursiveGaussian(image1, sigma, normalizeAcrossScale, useImageDirection)
class GrayscaleConnectedClosingImageFilter(ImageFilter_1):
    """


    Enhance pixels associated with a dark object (identified by a seed
    pixel) where the dark object is surrounded by a brigher object.


    GrayscaleConnectedClosingImagefilter is useful for enhancing dark
    objects that are surrounded by bright borders. This filter makes it
    easier to threshold the image and extract just the object of interest.

    Geodesic morphology and the connected closing algorithm are described
    in Chapter 6 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleConnectedClosing for the procedural interface

     itk::GrayscaleConnectedClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleConnectedClosingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleConnectedClosingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleConnectedClosingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleConnectedClosingImageFilter self) -> GrayscaleConnectedClosingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleConnectedClosingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleConnectedClosingImageFilter
    __del__ = lambda self: None

    def SetSeed(self, Seed):
        """
        SetSeed(GrayscaleConnectedClosingImageFilter self, VectorUInt32 Seed)



        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_SetSeed(self, Seed)


    def GetSeed(self):
        """
        GetSeed(GrayscaleConnectedClosingImageFilter self) -> VectorUInt32



        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_GetSeed(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(GrayscaleConnectedClosingImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(GrayscaleConnectedClosingImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(GrayscaleConnectedClosingImageFilter self)



        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(GrayscaleConnectedClosingImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(GrayscaleConnectedClosingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleConnectedClosingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleConnectedClosingImageFilter self, Image image1) -> Image
        Execute(GrayscaleConnectedClosingImageFilter self, Image image1, VectorUInt32 seed, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GrayscaleConnectedClosingImageFilter_Execute(self, *args)

GrayscaleConnectedClosingImageFilter_swigregister = _SimpleITK.GrayscaleConnectedClosingImageFilter_swigregister
GrayscaleConnectedClosingImageFilter_swigregister(GrayscaleConnectedClosingImageFilter)


def GrayscaleConnectedClosing(*args, **kwargs):
    """
    GrayscaleConnectedClosing(Image image1, VectorUInt32 seed, bool fullyConnected=False) -> Image



    Enhance pixels associated with a dark object (identified by a seed
    pixel) where the dark object is surrounded by a brigher object.


    This function directly calls the execute method of GrayscaleConnectedClosingImageFilter in order to support a procedural API


    See:
     itk::simple::GrayscaleConnectedClosingImageFilter for the object oriented interface



    """
    return _SimpleITK.GrayscaleConnectedClosing(*args, **kwargs)
class GrayscaleConnectedOpeningImageFilter(ImageFilter_1):
    """


    Enhance pixels associated with a bright object (identified by a seed
    pixel) where the bright object is surrounded by a darker object.


    GrayscaleConnectedOpeningImagefilter is useful for enhancing bright
    objects that are surrounded by dark borders. This filter makes it
    easier to threshold the image and extract just the object of interest.

    Geodesic morphology and the connected opening algorithm is described
    in Chapter 6 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleConnectedOpening for the procedural interface

     itk::GrayscaleConnectedOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleConnectedOpeningImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleConnectedOpeningImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleConnectedOpeningImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleConnectedOpeningImageFilter self) -> GrayscaleConnectedOpeningImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleConnectedOpeningImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleConnectedOpeningImageFilter
    __del__ = lambda self: None

    def SetSeed(self, Seed):
        """
        SetSeed(GrayscaleConnectedOpeningImageFilter self, VectorUInt32 Seed)



        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_SetSeed(self, Seed)


    def GetSeed(self):
        """
        GetSeed(GrayscaleConnectedOpeningImageFilter self) -> VectorUInt32



        Set/Get the seed pixel for the segmentation


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_GetSeed(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(GrayscaleConnectedOpeningImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(GrayscaleConnectedOpeningImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(GrayscaleConnectedOpeningImageFilter self)



        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(GrayscaleConnectedOpeningImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(GrayscaleConnectedOpeningImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleConnectedOpeningImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleConnectedOpeningImageFilter self, Image image1) -> Image
        Execute(GrayscaleConnectedOpeningImageFilter self, Image image1, VectorUInt32 seed, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GrayscaleConnectedOpeningImageFilter_Execute(self, *args)

GrayscaleConnectedOpeningImageFilter_swigregister = _SimpleITK.GrayscaleConnectedOpeningImageFilter_swigregister
GrayscaleConnectedOpeningImageFilter_swigregister(GrayscaleConnectedOpeningImageFilter)


def GrayscaleConnectedOpening(*args, **kwargs):
    """
    GrayscaleConnectedOpening(Image image1, VectorUInt32 seed, bool fullyConnected=False) -> Image



    Enhance pixels associated with a bright object (identified by a seed
    pixel) where the bright object is surrounded by a darker object.


    This function directly calls the execute method of GrayscaleConnectedOpeningImageFilter in order to support a procedural API


    See:
     itk::simple::GrayscaleConnectedOpeningImageFilter for the object oriented interface



    """
    return _SimpleITK.GrayscaleConnectedOpening(*args, **kwargs)
class GrayscaleDilateImageFilter(ImageFilter_1):
    """


    Grayscale dilation of an image.


    Dilate an image using grayscale morphology. Dilation takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter
    Wiki Examples:

    All Examples

    Dilate a grayscale image
    See:
     itk::simple::GrayscaleDilate for the procedural interface

     itk::GrayscaleDilateImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGrayscaleDilateImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleDilateImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleDilateImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleDilateImageFilter self) -> GrayscaleDilateImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleDilateImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleDilateImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.GrayscaleDilateImageFilter_Annulus
    Ball = _SimpleITK.GrayscaleDilateImageFilter_Ball
    Box = _SimpleITK.GrayscaleDilateImageFilter_Box
    Cross = _SimpleITK.GrayscaleDilateImageFilter_Cross

    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(GrayscaleDilateImageFilter self, uint32_t r)
        SetKernelRadius(GrayscaleDilateImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.GrayscaleDilateImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(GrayscaleDilateImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.GrayscaleDilateImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(GrayscaleDilateImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.GrayscaleDilateImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(GrayscaleDilateImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.GrayscaleDilateImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(GrayscaleDilateImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleDilateImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleDilateImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleDilateImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(GrayscaleDilateImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleDilateImageFilter_Execute(self, image1)

GrayscaleDilateImageFilter_swigregister = _SimpleITK.GrayscaleDilateImageFilter_swigregister
GrayscaleDilateImageFilter_swigregister(GrayscaleDilateImageFilter)


def GrayscaleDilate(*args):
    """
    GrayscaleDilate(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel) -> Image
    GrayscaleDilate(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel) -> Image



    itk::simple::GrayscaleDilateImageFilter Functional Interface

    This function directly calls the execute method of GrayscaleDilateImageFilter in order to support a fully functional API


    """
    return _SimpleITK.GrayscaleDilate(*args)
class GrayscaleErodeImageFilter(ImageFilter_1):
    """


    Grayscale erosion of an image.


    Erode an image using grayscale morphology. Erosion takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter
    Wiki Examples:

    All Examples

    Erode a grayscale image
    See:
     itk::simple::GrayscaleErode for the procedural interface

     itk::GrayscaleErodeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGrayscaleErodeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleErodeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleErodeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleErodeImageFilter self) -> GrayscaleErodeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleErodeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleErodeImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.GrayscaleErodeImageFilter_Annulus
    Ball = _SimpleITK.GrayscaleErodeImageFilter_Ball
    Box = _SimpleITK.GrayscaleErodeImageFilter_Box
    Cross = _SimpleITK.GrayscaleErodeImageFilter_Cross

    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(GrayscaleErodeImageFilter self, uint32_t r)
        SetKernelRadius(GrayscaleErodeImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.GrayscaleErodeImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(GrayscaleErodeImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.GrayscaleErodeImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(GrayscaleErodeImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.GrayscaleErodeImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(GrayscaleErodeImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.GrayscaleErodeImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(GrayscaleErodeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleErodeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleErodeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleErodeImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(GrayscaleErodeImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.GrayscaleErodeImageFilter_Execute(self, image1)

GrayscaleErodeImageFilter_swigregister = _SimpleITK.GrayscaleErodeImageFilter_swigregister
GrayscaleErodeImageFilter_swigregister(GrayscaleErodeImageFilter)


def GrayscaleErode(*args):
    """
    GrayscaleErode(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel) -> Image
    GrayscaleErode(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel) -> Image



    itk::simple::GrayscaleErodeImageFilter Functional Interface

    This function directly calls the execute method of GrayscaleErodeImageFilter in order to support a fully functional API


    """
    return _SimpleITK.GrayscaleErode(*args)
class GrayscaleFillholeImageFilter(ImageFilter_1):
    """


    Remove local minima not connected to the boundary of the image.


    GrayscaleFillholeImageFilter fills holes in a grayscale image. Holes are local minima in the
    grayscale topography that are not connected to boundaries of the
    image. Gray level values adjacent to a hole are extrapolated across
    the hole.

    This filter is used to smooth over local minima without affecting the
    values of local maxima. If you take the difference between the output
    of this filter and the original image (and perhaps threshold the
    difference above a small value), you'll obtain a map of the local
    minima.

    This filter uses the ReconstructionByErosionImageFilter . It provides its own input as the "mask" input to the geodesic
    erosion. The "marker" image for the geodesic erosion is constructed
    such that boundary pixels match the boundary pixels of the input image
    and the interior pixels are set to the maximum pixel value in the
    input image.

    Geodesic morphology and the Fillhole algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     ReconstructionByErosionImageFilter

     MorphologyImageFilter , GrayscaleErodeImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter

     itk::simple::GrayscaleFillhole for the procedural interface

     itk::GrayscaleFillholeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleFillholeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleFillholeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleFillholeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleFillholeImageFilter self) -> GrayscaleFillholeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleFillholeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleFillholeImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(GrayscaleFillholeImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(GrayscaleFillholeImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(GrayscaleFillholeImageFilter self)



        """
        return _SimpleITK.GrayscaleFillholeImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(GrayscaleFillholeImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(GrayscaleFillholeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleFillholeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleFillholeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleFillholeImageFilter self, Image image1) -> Image
        Execute(GrayscaleFillholeImageFilter self, Image image1, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GrayscaleFillholeImageFilter_Execute(self, *args)

GrayscaleFillholeImageFilter_swigregister = _SimpleITK.GrayscaleFillholeImageFilter_swigregister
GrayscaleFillholeImageFilter_swigregister(GrayscaleFillholeImageFilter)


def GrayscaleFillhole(image1, fullyConnected=False):
    """
    GrayscaleFillhole(Image image1, bool fullyConnected=False) -> Image



    Remove local minima not connected to the boundary of the image.


    This function directly calls the execute method of GrayscaleFillholeImageFilter in order to support a procedural API


    See:
     itk::simple::GrayscaleFillholeImageFilter for the object oriented interface



    """
    return _SimpleITK.GrayscaleFillhole(image1, fullyConnected)
class GrayscaleGeodesicDilateImageFilter(ImageFilter_2):
    """


    geodesic gray scale dilation of an image


    Geodesic dilation operates on a "marker" image and a "mask" image.
    The marker image is dilated using an elementary structuring element
    (neighborhood of radius one using only the face connected neighbors).
    The resulting image is then compared with the mask image. The output
    image is the pixelwise minimum of the dilated marker image and the
    mask image.

    Geodesic dilation is run either one iteration or until convergence. In
    the convergence case, the filter is equivalent to "reconstruction by
    dilation". This filter is implemented to handle both scenarios. The
    one iteration case is multi-threaded. The convergence case is
    delegated to another instance of the same filter (but configured to
    run a single iteration).

    The marker image must be less than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.

    A noniterative version of this algorithm can be found in the ReconstructionByDilationImageFilter . This noniterative solution is much faster than the implementation
    provided here. All ITK filters that previously used
    GrayscaleGeodesicDiliateImageFilter as part of their implementation
    have been converted to use the ReconstructionByDilationImageFilter . The GrayscaleGeodesicDilateImageFilter is maintained for backward compatibility.


    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter , ReconstructionByDilationImageFilter

     itk::simple::GrayscaleGeodesicDilate for the procedural interface

     itk::GrayscaleGeodesicDilateImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleGeodesicDilateImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleGeodesicDilateImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleGeodesicDilateImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleGeodesicDilateImageFilter self) -> GrayscaleGeodesicDilateImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleGeodesicDilateImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleGeodesicDilateImageFilter
    __del__ = lambda self: None

    def SetRunOneIteration(self, RunOneIteration):
        """
        SetRunOneIteration(GrayscaleGeodesicDilateImageFilter self, bool RunOneIteration)



        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by dilation". Default is off.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_SetRunOneIteration(self, RunOneIteration)


    def RunOneIterationOn(self):
        """
        RunOneIterationOn(GrayscaleGeodesicDilateImageFilter self)



        Set the value of RunOneIteration to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_RunOneIterationOn(self)


    def RunOneIterationOff(self):
        """
        RunOneIterationOff(GrayscaleGeodesicDilateImageFilter self)



        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_RunOneIterationOff(self)


    def GetRunOneIteration(self):
        """
        GetRunOneIteration(GrayscaleGeodesicDilateImageFilter self) -> bool



        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by dilation". Default is off.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_GetRunOneIteration(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(GrayscaleGeodesicDilateImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(GrayscaleGeodesicDilateImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(GrayscaleGeodesicDilateImageFilter self)



        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(GrayscaleGeodesicDilateImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(GrayscaleGeodesicDilateImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleGeodesicDilateImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleGeodesicDilateImageFilter self, Image image1, Image image2) -> Image
        Execute(GrayscaleGeodesicDilateImageFilter self, Image image1, Image image2, bool runOneIteration, bool fullyConnected) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.GrayscaleGeodesicDilateImageFilter_Execute(self, *args)

GrayscaleGeodesicDilateImageFilter_swigregister = _SimpleITK.GrayscaleGeodesicDilateImageFilter_swigregister
GrayscaleGeodesicDilateImageFilter_swigregister(GrayscaleGeodesicDilateImageFilter)


def GrayscaleGeodesicDilate(image1, image2, runOneIteration=False, fullyConnected=False):
    """
    GrayscaleGeodesicDilate(Image image1, Image image2, bool runOneIteration=False, bool fullyConnected=False) -> Image



    geodesic gray scale dilation of an image


    This function directly calls the execute method of GrayscaleGeodesicDilateImageFilter in order to support a procedural API


    See:
     itk::simple::GrayscaleGeodesicDilateImageFilter for the object oriented interface



    """
    return _SimpleITK.GrayscaleGeodesicDilate(image1, image2, runOneIteration, fullyConnected)
class GrayscaleGeodesicErodeImageFilter(ImageFilter_2):
    """


    geodesic gray scale erosion of an image


    Geodesic erosion operates on a "marker" image and a "mask" image.
    The marker image is eroded using an elementary structuring element
    (neighborhood of radius one using only the face connected neighbors).
    The resulting image is then compared with the mask image. The output
    image is the pixelwise maximum of the eroded marker image and the mask
    image.

    Geodesic erosion is run either one iteration or until convergence. In
    the convergence case, the filter is equivalent to "reconstruction by
    erosion". This filter is implemented to handle both scenarios. The
    one iteration case is multi-threaded. The convergence case is
    delegated to another instance of the same filter (but configured to
    run a single iteration).

    The marker image must be greater than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.

    A noniterative version of this algorithm can be found in the ReconstructionByErosionImageFilter . This noniterative solution is much faster than the implementation
    provided here. All ITK filters that previously used GrayscaleGeodesicErodeImageFilter as part of their implementation have been converted to use the ReconstructionByErosionImageFilter . The GrayscaleGeodesicErodeImageFilter is maintained for backward compatibility.


    See:
     MorphologyImageFilter , GrayscaleErodeImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter , ReconstructionByErosionImageFilter

     itk::simple::GrayscaleGeodesicErode for the procedural interface

     itk::GrayscaleGeodesicErodeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleGeodesicErodeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleGeodesicErodeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleGeodesicErodeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleGeodesicErodeImageFilter self) -> GrayscaleGeodesicErodeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleGeodesicErodeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleGeodesicErodeImageFilter
    __del__ = lambda self: None

    def SetRunOneIteration(self, RunOneIteration):
        """
        SetRunOneIteration(GrayscaleGeodesicErodeImageFilter self, bool RunOneIteration)



        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by erosion". Default is off.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_SetRunOneIteration(self, RunOneIteration)


    def RunOneIterationOn(self):
        """
        RunOneIterationOn(GrayscaleGeodesicErodeImageFilter self)



        Set the value of RunOneIteration to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_RunOneIterationOn(self)


    def RunOneIterationOff(self):
        """
        RunOneIterationOff(GrayscaleGeodesicErodeImageFilter self)



        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_RunOneIterationOff(self)


    def GetRunOneIteration(self):
        """
        GetRunOneIteration(GrayscaleGeodesicErodeImageFilter self) -> bool



        Set/Get whether the filter should run one iteration or until
        convergence. When run to convergence, this filter is equivalent to
        "reconstruction by erosion". Default is off.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_GetRunOneIteration(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(GrayscaleGeodesicErodeImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(GrayscaleGeodesicErodeImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(GrayscaleGeodesicErodeImageFilter self)



        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(GrayscaleGeodesicErodeImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(GrayscaleGeodesicErodeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleGeodesicErodeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleGeodesicErodeImageFilter self, Image image1, Image image2) -> Image
        Execute(GrayscaleGeodesicErodeImageFilter self, Image image1, Image image2, bool runOneIteration, bool fullyConnected) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.GrayscaleGeodesicErodeImageFilter_Execute(self, *args)

GrayscaleGeodesicErodeImageFilter_swigregister = _SimpleITK.GrayscaleGeodesicErodeImageFilter_swigregister
GrayscaleGeodesicErodeImageFilter_swigregister(GrayscaleGeodesicErodeImageFilter)


def GrayscaleGeodesicErode(image1, image2, runOneIteration=False, fullyConnected=False):
    """
    GrayscaleGeodesicErode(Image image1, Image image2, bool runOneIteration=False, bool fullyConnected=False) -> Image



    geodesic gray scale erosion of an image


    This function directly calls the execute method of GrayscaleGeodesicErodeImageFilter in order to support a procedural API


    See:
     itk::simple::GrayscaleGeodesicErodeImageFilter for the object oriented interface



    """
    return _SimpleITK.GrayscaleGeodesicErode(image1, image2, runOneIteration, fullyConnected)
class GrayscaleGrindPeakImageFilter(ImageFilter_1):
    """


    Remove local maxima not connected to the boundary of the image.


    GrayscaleGrindPeakImageFilter removes peaks in a grayscale image. Peaks are local maxima in the
    grayscale topography that are not connected to boundaries of the
    image. Gray level values adjacent to a peak are extrapolated through
    the peak.

    This filter is used to smooth over local maxima without affecting the
    values of local minima. If you take the difference between the output
    of this filter and the original image (and perhaps threshold the
    difference above a small value), you'll obtain a map of the local
    maxima.

    This filter uses the GrayscaleGeodesicDilateImageFilter . It provides its own input as the "mask" input to the geodesic
    erosion. The "marker" image for the geodesic erosion is constructed
    such that boundary pixels match the boundary pixels of the input image
    and the interior pixels are set to the minimum pixel value in the
    input image.

    This filter is the dual to the GrayscaleFillholeImageFilter which implements the Fillhole algorithm. Since it is a dual, it is
    somewhat superfluous but is provided as a convenience.

    Geodesic morphology and the Fillhole algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleGrindPeak for the procedural interface

     itk::GrayscaleGrindPeakImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleGrindPeakImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleGrindPeakImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleGrindPeakImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleGrindPeakImageFilter self) -> GrayscaleGrindPeakImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleGrindPeakImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleGrindPeakImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(GrayscaleGrindPeakImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(GrayscaleGrindPeakImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(GrayscaleGrindPeakImageFilter self)



        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(GrayscaleGrindPeakImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(GrayscaleGrindPeakImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleGrindPeakImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleGrindPeakImageFilter self, Image image1) -> Image
        Execute(GrayscaleGrindPeakImageFilter self, Image image1, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GrayscaleGrindPeakImageFilter_Execute(self, *args)

GrayscaleGrindPeakImageFilter_swigregister = _SimpleITK.GrayscaleGrindPeakImageFilter_swigregister
GrayscaleGrindPeakImageFilter_swigregister(GrayscaleGrindPeakImageFilter)


def GrayscaleGrindPeak(image1, fullyConnected=False):
    """
    GrayscaleGrindPeak(Image image1, bool fullyConnected=False) -> Image



    Remove local maxima not connected to the boundary of the image.


    This function directly calls the execute method of GrayscaleGrindPeakImageFilter in order to support a procedural API


    See:
     itk::simple::GrayscaleGrindPeakImageFilter for the object oriented interface



    """
    return _SimpleITK.GrayscaleGrindPeak(image1, fullyConnected)
class GrayscaleMorphologicalClosingImageFilter(ImageFilter_1):
    """


    gray scale dilation of an image


    Erode an image using grayscale morphology. Dilation takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionErodeImageFilter , BinaryErodeImageFilter

     itk::simple::GrayscaleMorphologicalClosing for the procedural interface

     itk::GrayscaleMorphologicalClosingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleMorphologicalClosingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleMorphologicalClosingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleMorphologicalClosingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleMorphologicalClosingImageFilter self) -> GrayscaleMorphologicalClosingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleMorphologicalClosingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleMorphologicalClosingImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.GrayscaleMorphologicalClosingImageFilter_Annulus
    Ball = _SimpleITK.GrayscaleMorphologicalClosingImageFilter_Ball
    Box = _SimpleITK.GrayscaleMorphologicalClosingImageFilter_Box
    Cross = _SimpleITK.GrayscaleMorphologicalClosingImageFilter_Cross

    def SetSafeBorder(self, SafeBorder):
        """
        SetSafeBorder(GrayscaleMorphologicalClosingImageFilter self, bool SafeBorder)



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SetSafeBorder(self, SafeBorder)


    def SafeBorderOn(self):
        """
        SafeBorderOn(GrayscaleMorphologicalClosingImageFilter self)



        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SafeBorderOn(self)


    def SafeBorderOff(self):
        """
        SafeBorderOff(GrayscaleMorphologicalClosingImageFilter self)



        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SafeBorderOff(self)


    def GetSafeBorder(self):
        """
        GetSafeBorder(GrayscaleMorphologicalClosingImageFilter self) -> bool



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetSafeBorder(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(GrayscaleMorphologicalClosingImageFilter self, uint32_t r)
        SetKernelRadius(GrayscaleMorphologicalClosingImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(GrayscaleMorphologicalClosingImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(GrayscaleMorphologicalClosingImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(GrayscaleMorphologicalClosingImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(GrayscaleMorphologicalClosingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleMorphologicalClosingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleMorphologicalClosingImageFilter self, Image image1) -> Image
        Execute(GrayscaleMorphologicalClosingImageFilter self, Image image1, bool safeBorder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GrayscaleMorphologicalClosingImageFilter_Execute(self, *args)

GrayscaleMorphologicalClosingImageFilter_swigregister = _SimpleITK.GrayscaleMorphologicalClosingImageFilter_swigregister
GrayscaleMorphologicalClosingImageFilter_swigregister(GrayscaleMorphologicalClosingImageFilter)


def GrayscaleMorphologicalClosing(*args):
    """
    GrayscaleMorphologicalClosing(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image
    GrayscaleMorphologicalClosing(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image



    itk::simple::GrayscaleMorphologicalClosingImageFilter Functional Interface

    This function directly calls the execute method of GrayscaleMorphologicalClosingImageFilter in order to support a fully functional API


    """
    return _SimpleITK.GrayscaleMorphologicalClosing(*args)
class GrayscaleMorphologicalOpeningImageFilter(ImageFilter_1):
    """


    gray scale dilation of an image


    Dilate an image using grayscale morphology. Dilation takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::GrayscaleMorphologicalOpening for the procedural interface

     itk::GrayscaleMorphologicalOpeningImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkGrayscaleMorphologicalOpeningImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GrayscaleMorphologicalOpeningImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GrayscaleMorphologicalOpeningImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GrayscaleMorphologicalOpeningImageFilter self) -> GrayscaleMorphologicalOpeningImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GrayscaleMorphologicalOpeningImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GrayscaleMorphologicalOpeningImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_Annulus
    Ball = _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_Ball
    Box = _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_Box
    Cross = _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_Cross

    def SetSafeBorder(self, SafeBorder):
        """
        SetSafeBorder(GrayscaleMorphologicalOpeningImageFilter self, bool SafeBorder)



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SetSafeBorder(self, SafeBorder)


    def SafeBorderOn(self):
        """
        SafeBorderOn(GrayscaleMorphologicalOpeningImageFilter self)



        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SafeBorderOn(self)


    def SafeBorderOff(self):
        """
        SafeBorderOff(GrayscaleMorphologicalOpeningImageFilter self)



        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SafeBorderOff(self)


    def GetSafeBorder(self):
        """
        GetSafeBorder(GrayscaleMorphologicalOpeningImageFilter self) -> bool



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetSafeBorder(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(GrayscaleMorphologicalOpeningImageFilter self, uint32_t r)
        SetKernelRadius(GrayscaleMorphologicalOpeningImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(GrayscaleMorphologicalOpeningImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(GrayscaleMorphologicalOpeningImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(GrayscaleMorphologicalOpeningImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(GrayscaleMorphologicalOpeningImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GrayscaleMorphologicalOpeningImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GrayscaleMorphologicalOpeningImageFilter self, Image image1) -> Image
        Execute(GrayscaleMorphologicalOpeningImageFilter self, Image image1, bool safeBorder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_Execute(self, *args)

GrayscaleMorphologicalOpeningImageFilter_swigregister = _SimpleITK.GrayscaleMorphologicalOpeningImageFilter_swigregister
GrayscaleMorphologicalOpeningImageFilter_swigregister(GrayscaleMorphologicalOpeningImageFilter)


def GrayscaleMorphologicalOpening(*args):
    """
    GrayscaleMorphologicalOpening(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image
    GrayscaleMorphologicalOpening(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image



    itk::simple::GrayscaleMorphologicalOpeningImageFilter Functional Interface

    This function directly calls the execute method of GrayscaleMorphologicalOpeningImageFilter in order to support a fully functional API


    """
    return _SimpleITK.GrayscaleMorphologicalOpening(*args)
class GreaterEqualImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::GreaterEqual for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGreaterEqualImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GreaterEqualImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GreaterEqualImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GreaterEqualImageFilter self) -> GreaterEqualImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GreaterEqualImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GreaterEqualImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(GreaterEqualImageFilter self, uint8_t BackgroundValue)



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(GreaterEqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(GreaterEqualImageFilter self, uint8_t ForegroundValue)



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(GreaterEqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterEqualImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(GreaterEqualImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GreaterEqualImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GreaterEqualImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GreaterEqualImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GreaterEqualImageFilter self, Image image1, Image image2) -> Image
        Execute(GreaterEqualImageFilter self, Image image1, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(GreaterEqualImageFilter self, Image image1, double constant) -> Image
        Execute(GreaterEqualImageFilter self, double constant, Image image2) -> Image
        Execute(GreaterEqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(GreaterEqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image



        """
        return _SimpleITK.GreaterEqualImageFilter_Execute(self, *args)

GreaterEqualImageFilter_swigregister = _SimpleITK.GreaterEqualImageFilter_swigregister
GreaterEqualImageFilter_swigregister(GreaterEqualImageFilter)


def GreaterEqual(*args):
    """
    GreaterEqual(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    GreaterEqual(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    GreaterEqual(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image



    """
    return _SimpleITK.GreaterEqual(*args)
class GreaterImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::Greater for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkGreaterImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GreaterImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GreaterImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GreaterImageFilter self) -> GreaterImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GreaterImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GreaterImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(GreaterImageFilter self, uint8_t BackgroundValue)



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(GreaterImageFilter self) -> uint8_t



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(GreaterImageFilter self, uint8_t ForegroundValue)



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(GreaterImageFilter self) -> uint8_t



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.GreaterImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(GreaterImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.GreaterImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(GreaterImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GreaterImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(GreaterImageFilter self, Image image1, Image image2) -> Image
        Execute(GreaterImageFilter self, Image image1, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(GreaterImageFilter self, Image image1, double constant) -> Image
        Execute(GreaterImageFilter self, double constant, Image image2) -> Image
        Execute(GreaterImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(GreaterImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image



        """
        return _SimpleITK.GreaterImageFilter_Execute(self, *args)

GreaterImageFilter_swigregister = _SimpleITK.GreaterImageFilter_swigregister
GreaterImageFilter_swigregister(GreaterImageFilter)


def Greater(*args):
    """
    Greater(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Greater(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Greater(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image



    """
    return _SimpleITK.Greater(*args)
class GridImageSource(ImageFilter_0):
    """


    Generate an n-dimensional image of a grid.


    GridImageSource generates an image of a grid. From the abstract... "Certain classes
    of images find disparate use amongst members of the ITK community for
    such purposes as visualization, simulation, testing, etc. Currently
    there exists two derived classes from the ImageSource class used for
    generating specific images for various applications, viz.
    RandomImageSource and GaussianImageSource . We propose to add to this
    set with the class GridImageSource which, obviously enough, produces a
    grid image. Such images are useful for visualizing deformation when
    used in conjunction with the WarpImageFilter , simulating magnetic
    resonance tagging images, or creating optical illusions with which to
    amaze your friends."

    The output image may be of any dimension.


    Tustison N., Avants B., Gee J. University of Pennsylvania
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/475
    See:
     itk::simple::GridImageSource for the procedural interface

     itk::GridImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkGridImageSource.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GridImageSource, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GridImageSource, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::GridImageSource self) -> GridImageSource



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_GridImageSource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_GridImageSource
    __del__ = lambda self: None

    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(GridImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)



        """
        return _SimpleITK.GridImageSource_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(GridImageSource self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.GridImageSource_GetOutputPixelType(self)


    def SetSize(self, Size):
        """
        SetSize(GridImageSource self, VectorUInt32 Size)



        """
        return _SimpleITK.GridImageSource_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(GridImageSource self) -> VectorUInt32



        """
        return _SimpleITK.GridImageSource_GetSize(self)


    def SetSigma(self, *args):
        """
        SetSigma(GridImageSource self, VectorDouble Sigma)
        SetSigma(GridImageSource self, double value)



        Set the values of the Sigma vector all to value


        """
        return _SimpleITK.GridImageSource_SetSigma(self, *args)


    def GetSigma(self):
        """
        GetSigma(GridImageSource self) -> VectorDouble



        """
        return _SimpleITK.GridImageSource_GetSigma(self)


    def SetGridSpacing(self, GridSpacing):
        """
        SetGridSpacing(GridImageSource self, VectorDouble GridSpacing)



        """
        return _SimpleITK.GridImageSource_SetGridSpacing(self, GridSpacing)


    def GetGridSpacing(self):
        """
        GetGridSpacing(GridImageSource self) -> VectorDouble



        """
        return _SimpleITK.GridImageSource_GetGridSpacing(self)


    def SetGridOffset(self, GridOffset):
        """
        SetGridOffset(GridImageSource self, VectorDouble GridOffset)



        """
        return _SimpleITK.GridImageSource_SetGridOffset(self, GridOffset)


    def GetGridOffset(self):
        """
        GetGridOffset(GridImageSource self) -> VectorDouble



        """
        return _SimpleITK.GridImageSource_GetGridOffset(self)


    def SetScale(self, Scale):
        """
        SetScale(GridImageSource self, double Scale)



        """
        return _SimpleITK.GridImageSource_SetScale(self, Scale)


    def GetScale(self):
        """
        GetScale(GridImageSource self) -> double



        """
        return _SimpleITK.GridImageSource_GetScale(self)


    def SetOrigin(self, Origin):
        """
        SetOrigin(GridImageSource self, VectorDouble Origin)



        """
        return _SimpleITK.GridImageSource_SetOrigin(self, Origin)


    def GetOrigin(self):
        """
        GetOrigin(GridImageSource self) -> VectorDouble



        """
        return _SimpleITK.GridImageSource_GetOrigin(self)


    def SetSpacing(self, Spacing):
        """
        SetSpacing(GridImageSource self, VectorDouble Spacing)



        """
        return _SimpleITK.GridImageSource_SetSpacing(self, Spacing)


    def GetSpacing(self):
        """
        GetSpacing(GridImageSource self) -> VectorDouble



        """
        return _SimpleITK.GridImageSource_GetSpacing(self)


    def SetDirection(self, Direction):
        """
        SetDirection(GridImageSource self, VectorDouble Direction)



        """
        return _SimpleITK.GridImageSource_SetDirection(self, Direction)


    def GetDirection(self):
        """
        GetDirection(GridImageSource self) -> VectorDouble



        """
        return _SimpleITK.GridImageSource_GetDirection(self)


    def GetName(self):
        """
        GetName(GridImageSource self) -> std::string



        Name of this class


        """
        return _SimpleITK.GridImageSource_GetName(self)


    def __str__(self):
        """
        __str__(GridImageSource self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.GridImageSource___str__(self)


    def Execute(self, *args):
        """
        Execute(GridImageSource self) -> Image
        Execute(GridImageSource self, itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble sigma, VectorDouble gridSpacing, VectorDouble gridOffset, double scale, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.GridImageSource_Execute(self, *args)

GridImageSource_swigregister = _SimpleITK.GridImageSource_swigregister
GridImageSource_swigregister(GridImageSource)


def GridSource(*args, **kwargs):
    """
    GridSource(itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble sigma, VectorDouble gridSpacing, VectorDouble gridOffset, double scale=255.0, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



    Generate an n-dimensional image of a grid.


    This function directly calls the execute method of GridImageSource in order to support a procedural API


    See:
     itk::simple::GridImageSource for the object oriented interface



    """
    return _SimpleITK.GridSource(*args, **kwargs)
class HConcaveImageFilter(ImageFilter_1):
    """


    Identify local minima whose depth below the baseline is greater than
    h.


    HConcaveImageFilter extract local minima that are more than h intensity units below the
    (local) background. This has the effect of extracting objects that are
    darker than the background by at least h intensity units.

    This filter uses the HMinimaImageFilter .

    Geodesic morphology and the H-Convex algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter , HMaximaImageFilter ,

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HConcave for the procedural interface

     itk::HConcaveImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHConcaveImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HConcaveImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HConcaveImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HConcaveImageFilter self) -> HConcaveImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HConcaveImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HConcaveImageFilter
    __del__ = lambda self: None

    def SetHeight(self, Height):
        """
        SetHeight(HConcaveImageFilter self, double Height)



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConcaveImageFilter_SetHeight(self, Height)


    def GetHeight(self):
        """
        GetHeight(HConcaveImageFilter self) -> double



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConcaveImageFilter_GetHeight(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(HConcaveImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConcaveImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(HConcaveImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.HConcaveImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(HConcaveImageFilter self)



        """
        return _SimpleITK.HConcaveImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(HConcaveImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConcaveImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(HConcaveImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HConcaveImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HConcaveImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HConcaveImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HConcaveImageFilter self, Image image1) -> Image
        Execute(HConcaveImageFilter self, Image image1, double height, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.HConcaveImageFilter_Execute(self, *args)

HConcaveImageFilter_swigregister = _SimpleITK.HConcaveImageFilter_swigregister
HConcaveImageFilter_swigregister(HConcaveImageFilter)


def HConcave(image1, height=2.0, fullyConnected=False):
    """
    HConcave(Image image1, double height=2.0, bool fullyConnected=False) -> Image



    Identify local minima whose depth below the baseline is greater than
    h.


    This function directly calls the execute method of HConcaveImageFilter in order to support a procedural API


    See:
     itk::simple::HConcaveImageFilter for the object oriented interface



    """
    return _SimpleITK.HConcave(image1, height, fullyConnected)
class HConvexImageFilter(ImageFilter_1):
    """


    Identify local maxima whose height above the baseline is greater than
    h.


    HConvexImageFilter extract local maxima that are more than h intensity units above the
    (local) background. This has the effect of extracting objects that are
    brighter than background by at least h intensity units.

    This filter uses the HMaximaImageFilter .

    Geodesic morphology and the H-Convex algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter , HMinimaImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HConvex for the procedural interface

     itk::HConvexImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHConvexImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HConvexImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HConvexImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HConvexImageFilter self) -> HConvexImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HConvexImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HConvexImageFilter
    __del__ = lambda self: None

    def SetHeight(self, Height):
        """
        SetHeight(HConvexImageFilter self, double Height)



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConvexImageFilter_SetHeight(self, Height)


    def GetHeight(self):
        """
        GetHeight(HConvexImageFilter self) -> double



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HConvexImageFilter_GetHeight(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(HConvexImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConvexImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(HConvexImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.HConvexImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(HConvexImageFilter self)



        """
        return _SimpleITK.HConvexImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(HConvexImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HConvexImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(HConvexImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HConvexImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HConvexImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HConvexImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HConvexImageFilter self, Image image1) -> Image
        Execute(HConvexImageFilter self, Image image1, double height, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.HConvexImageFilter_Execute(self, *args)

HConvexImageFilter_swigregister = _SimpleITK.HConvexImageFilter_swigregister
HConvexImageFilter_swigregister(HConvexImageFilter)


def HConvex(image1, height=2.0, fullyConnected=False):
    """
    HConvex(Image image1, double height=2.0, bool fullyConnected=False) -> Image



    Identify local maxima whose height above the baseline is greater than
    h.


    This function directly calls the execute method of HConvexImageFilter in order to support a procedural API


    See:
     itk::simple::HConvexImageFilter for the object oriented interface



    """
    return _SimpleITK.HConvex(image1, height, fullyConnected)
class HMaximaImageFilter(ImageFilter_1):
    """


    Suppress local maxima whose height above the baseline is less than h.


    HMaximaImageFilter suppresses local maxima that are less than h intensity units above
    the (local) background. This has the effect of smoothing over the
    "high" parts of the noise in the image without smoothing over large
    changes in intensity (region boundaries). See the HMinimaImageFilter to suppress the local minima whose depth is less than h intensity
    units below the (local) background.

    If the output of HMaximaImageFilter is subtracted from the original image, the signicant "peaks" in the
    image can be identified. This is what the HConvexImageFilter provides.

    This filter uses the ReconstructionByDilationImageFilter . It provides its own input as the "mask" input to the geodesic
    dilation. The "marker" image for the geodesic dilation is the input
    image minus the height parameter h.

    Geodesic morphology and the H-Maxima algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.

    The height parameter is set using SetHeight.


    See:
     ReconstructionByDilationImageFilter , HMinimaImageFilter , HConvexImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HMaxima for the procedural interface

     itk::HMaximaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHMaximaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMaximaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMaximaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HMaximaImageFilter self) -> HMaximaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HMaximaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HMaximaImageFilter
    __del__ = lambda self: None

    def SetHeight(self, Height):
        """
        SetHeight(HMaximaImageFilter self, double Height)



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMaximaImageFilter_SetHeight(self, Height)


    def GetHeight(self):
        """
        GetHeight(HMaximaImageFilter self) -> double



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMaximaImageFilter_GetHeight(self)


    def GetName(self):
        """
        GetName(HMaximaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HMaximaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HMaximaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HMaximaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HMaximaImageFilter self, Image image1) -> Image
        Execute(HMaximaImageFilter self, Image image1, double height) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.HMaximaImageFilter_Execute(self, *args)

HMaximaImageFilter_swigregister = _SimpleITK.HMaximaImageFilter_swigregister
HMaximaImageFilter_swigregister(HMaximaImageFilter)


def HMaxima(image1, height=2.0):
    """
    HMaxima(Image image1, double height=2.0) -> Image



    Suppress local maxima whose height above the baseline is less than h.


    This function directly calls the execute method of HMaximaImageFilter in order to support a procedural API


    See:
     itk::simple::HMaximaImageFilter for the object oriented interface



    """
    return _SimpleITK.HMaxima(image1, height)
class HMinimaImageFilter(ImageFilter_1):
    """


    Suppress local minima whose depth below the baseline is less than h.


    HMinimaImageFilter suppresses local minima that are less than h intensity units below
    the (local) background. This has the effect of smoothing over the
    "low" parts of the noise in the image without smoothing over large
    changes in intensity (region boundaries). See the HMaximaImageFilter to suppress the local maxima whose height is less than h intensity
    units above the (local) background.

    If original image is subtracted from the output of HMinimaImageFilter , the signicant "valleys" in the image can be identified. This is
    what the HConcaveImageFilter provides.

    This filter uses the GrayscaleGeodesicErodeImageFilter . It provides its own input as the "mask" input to the geodesic
    dilation. The "marker" image for the geodesic dilation is the input
    image plus the height parameter h.

    Geodesic morphology and the H-Minima algorithm is described in Chapter
    6 of Pierre Soille's book "Morphological Image Analysis: Principles
    and Applications", Second Edition, Springer, 2003.


    See:
     GrayscaleGeodesicDilateImageFilter , HMinimaImageFilter , HConvexImageFilter

     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::HMinima for the procedural interface

     itk::HMinimaImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHMinimaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMinimaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMinimaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HMinimaImageFilter self) -> HMinimaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HMinimaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HMinimaImageFilter
    __del__ = lambda self: None

    def SetHeight(self, Height):
        """
        SetHeight(HMinimaImageFilter self, double Height)



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMinimaImageFilter_SetHeight(self, Height)


    def GetHeight(self):
        """
        GetHeight(HMinimaImageFilter self) -> double



        Set/Get the height that a local maximum must be above the local
        background (local contrast) in order to survive the processing. Local
        maxima below this value are replaced with an estimate of the local
        background.


        """
        return _SimpleITK.HMinimaImageFilter_GetHeight(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(HMinimaImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HMinimaImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(HMinimaImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.HMinimaImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(HMinimaImageFilter self)



        """
        return _SimpleITK.HMinimaImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(HMinimaImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.HMinimaImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(HMinimaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HMinimaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HMinimaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HMinimaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HMinimaImageFilter self, Image image1) -> Image
        Execute(HMinimaImageFilter self, Image image1, double height, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.HMinimaImageFilter_Execute(self, *args)

HMinimaImageFilter_swigregister = _SimpleITK.HMinimaImageFilter_swigregister
HMinimaImageFilter_swigregister(HMinimaImageFilter)


def HMinima(image1, height=2.0, fullyConnected=False):
    """
    HMinima(Image image1, double height=2.0, bool fullyConnected=False) -> Image



    Suppress local minima whose depth below the baseline is less than h.


    This function directly calls the execute method of HMinimaImageFilter in order to support a procedural API


    See:
     itk::simple::HMinimaImageFilter for the object oriented interface



    """
    return _SimpleITK.HMinima(image1, height, fullyConnected)
class HalfHermitianToRealInverseFFTImageFilter(ImageFilter_1):
    """


    Base class for specialized complex-to-real inverse Fast Fourier Transform .


    This is a base class for the "inverse" or "reverse" Discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child class available on the system when the
    object is created via the object factory system.

    The input to this filter is assumed to have the same format as the
    output of the RealToHalfHermitianForwardFFTImageFilter . That is, the input is assumed to consist of roughly half the full
    complex image resulting from a real-to-complex discrete Fourier
    transform. This half is expected to be the first half of the image in
    the X-dimension. Because this filter assumes that the input stores
    only about half of the non-redundant complex pixels, the output is
    larger in the X-dimension than it is in the input. To determine the
    actual size of the output image, this filter needs additional
    information in the form of a flag indicating whether the output image
    has an odd size in the X-dimension. Use SetActualXDimensionIsOdd() to set this flag.


    See:
     ForwardFFTImageFilter , HalfHermitianToRealInverseFFTImageFilter

     itk::simple::HalfHermitianToRealInverseFFT for the procedural interface

     itk::HalfHermitianToRealInverseFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHalfHermitianToRealInverseFFTImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HalfHermitianToRealInverseFFTImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HalfHermitianToRealInverseFFTImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HalfHermitianToRealInverseFFTImageFilter self) -> HalfHermitianToRealInverseFFTImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HalfHermitianToRealInverseFFTImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HalfHermitianToRealInverseFFTImageFilter
    __del__ = lambda self: None

    def SetActualXDimensionIsOdd(self, ActualXDimensionIsOdd):
        """
        SetActualXDimensionIsOdd(HalfHermitianToRealInverseFFTImageFilter self, bool ActualXDimensionIsOdd)



        Was the original truncated dimension size odd?


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_SetActualXDimensionIsOdd(self, ActualXDimensionIsOdd)


    def ActualXDimensionIsOddOn(self):
        """
        ActualXDimensionIsOddOn(HalfHermitianToRealInverseFFTImageFilter self)



        Set the value of ActualXDimensionIsOdd to true or false respectfully.


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_ActualXDimensionIsOddOn(self)


    def ActualXDimensionIsOddOff(self):
        """
        ActualXDimensionIsOddOff(HalfHermitianToRealInverseFFTImageFilter self)



        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_ActualXDimensionIsOddOff(self)


    def GetActualXDimensionIsOdd(self):
        """
        GetActualXDimensionIsOdd(HalfHermitianToRealInverseFFTImageFilter self) -> bool



        Was the original truncated dimension size odd?


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_GetActualXDimensionIsOdd(self)


    def GetName(self):
        """
        GetName(HalfHermitianToRealInverseFFTImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HalfHermitianToRealInverseFFTImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HalfHermitianToRealInverseFFTImageFilter self, Image image1) -> Image
        Execute(HalfHermitianToRealInverseFFTImageFilter self, Image image1, bool actualXDimensionIsOdd) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_Execute(self, *args)

HalfHermitianToRealInverseFFTImageFilter_swigregister = _SimpleITK.HalfHermitianToRealInverseFFTImageFilter_swigregister
HalfHermitianToRealInverseFFTImageFilter_swigregister(HalfHermitianToRealInverseFFTImageFilter)


def HalfHermitianToRealInverseFFT(image1, actualXDimensionIsOdd=False):
    """
    HalfHermitianToRealInverseFFT(Image image1, bool actualXDimensionIsOdd=False) -> Image



    Base class for specialized complex-to-real inverse Fast Fourier Transform .


    This function directly calls the execute method of HalfHermitianToRealInverseFFTImageFilter in order to support a procedural API


    See:
     itk::simple::HalfHermitianToRealInverseFFTImageFilter for the object oriented interface



    """
    return _SimpleITK.HalfHermitianToRealInverseFFT(image1, actualXDimensionIsOdd)
class HausdorffDistanceImageFilter(ImageFilter_2):
    """


    Computes the Hausdorff distance between the set of non-zero pixels of
    two images.


    HausdorffDistanceImageFilter computes the distance between the set non-zero pixels of two images
    using the following formula: \\[ H(A,B) = \\max(h(A,B),h(B,A)) \\] where \\[ h(A,B) = \\max_{a \\in A} \\min_{b \\in B} \\| a -
    b\\| \\] is the directed Hausdorff distance and $A$ and $B$ are respectively the set of non-zero pixels in the first and second
    input images.

    In particular, this filter uses the DirectedHausdorffImageFilter
    inside to compute the two directed distances and then select the
    largest of the two.

    The Hausdorff distance measures the degree of mismatch between two
    sets and behaves like a metric over the set of all closed bounded sets
    - with properties of identity, symmetry and triangle inequality.

    This filter requires the largest possible region of the first image
    and the same corresponding region in the second image. It behaves as
    filter with two inputs and one output. Thus it can be inserted in a
    pipeline with other filters. The filter passes the first input through
    unmodified.

    This filter is templated over the two input image types. It assume
    both images have the same number of dimensions.


    See:
     DirectedHausdorffDistanceImageFilter

     itk::HausdorffDistanceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHausdorffDistanceImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HausdorffDistanceImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HausdorffDistanceImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HausdorffDistanceImageFilter self) -> HausdorffDistanceImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HausdorffDistanceImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HausdorffDistanceImageFilter
    __del__ = lambda self: None

    def GetHausdorffDistance(self):
        """
        GetHausdorffDistance(HausdorffDistanceImageFilter self) -> double



        Return the computed Hausdorff distance.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.HausdorffDistanceImageFilter_GetHausdorffDistance(self)


    def GetAverageHausdorffDistance(self):
        """
        GetAverageHausdorffDistance(HausdorffDistanceImageFilter self) -> double



        Return the computed Hausdorff distance.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.HausdorffDistanceImageFilter_GetAverageHausdorffDistance(self)


    def GetName(self):
        """
        GetName(HausdorffDistanceImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HausdorffDistanceImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HausdorffDistanceImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HausdorffDistanceImageFilter___str__(self)


    def Execute(self, image1, image2):
        """
        Execute(HausdorffDistanceImageFilter self, Image image1, Image image2)



        Execute the filter on the input images


        """
        return _SimpleITK.HausdorffDistanceImageFilter_Execute(self, image1, image2)

HausdorffDistanceImageFilter_swigregister = _SimpleITK.HausdorffDistanceImageFilter_swigregister
HausdorffDistanceImageFilter_swigregister(HausdorffDistanceImageFilter)

class HistogramMatchingImageFilter(ImageFilter_2):
    """


    Normalize the grayscale values between two images by histogram
    matching.


    HistogramMatchingImageFilter normalizes the grayscale values of a source image based on the
    grayscale values of a reference image. This filter uses a histogram
    matching technique where the histograms of the two images are matched
    only at a specified number of quantile values.

    This filter was originally designed to normalize MR images of the same
    MR protocol and same body part. The algorithm works best if background
    pixels are excluded from both the source and reference histograms. A
    simple background exclusion method is to exclude all pixels whose
    grayscale values are smaller than the mean grayscale value. ThresholdAtMeanIntensityOn() switches on this simple background exclusion method.

    The source image can be set via either SetInput() or SetSourceImage()
    . The reference image can be set via SetReferenceImage() .

    SetNumberOfHistogramLevels() sets the number of bins used when creating histograms of the source
    and reference images. SetNumberOfMatchPoints() governs the number of quantile values to be matched.

    This filter assumes that both the source and reference are of the same
    type and that the input and output image type have the same number of
    dimension and have scalar pixel types.

    REFERENCE
    Laszlo G. Nyul, Jayaram K. Udupa, and Xuan Zhang, "New Variants of a
    Method of MRI Scale Standardization", IEEE Transactions on Medical
    Imaging, 19(2):143-150, 2000.

    See:
     itk::simple::HistogramMatching for the procedural interface

     itk::HistogramMatchingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHistogramMatchingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HistogramMatchingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HistogramMatchingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HistogramMatchingImageFilter self) -> HistogramMatchingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HistogramMatchingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HistogramMatchingImageFilter
    __del__ = lambda self: None

    def SetNumberOfHistogramLevels(self, NumberOfHistogramLevels):
        """
        SetNumberOfHistogramLevels(HistogramMatchingImageFilter self, uint32_t NumberOfHistogramLevels)



        Set/Get the number of histogram levels used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_SetNumberOfHistogramLevels(self, NumberOfHistogramLevels)


    def GetNumberOfHistogramLevels(self):
        """
        GetNumberOfHistogramLevels(HistogramMatchingImageFilter self) -> uint32_t



        Set/Get the number of histogram levels used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetNumberOfHistogramLevels(self)


    def SetNumberOfMatchPoints(self, NumberOfMatchPoints):
        """
        SetNumberOfMatchPoints(HistogramMatchingImageFilter self, uint32_t NumberOfMatchPoints)



        Set/Get the number of match points used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_SetNumberOfMatchPoints(self, NumberOfMatchPoints)


    def GetNumberOfMatchPoints(self):
        """
        GetNumberOfMatchPoints(HistogramMatchingImageFilter self) -> uint32_t



        Set/Get the number of match points used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetNumberOfMatchPoints(self)


    def SetThresholdAtMeanIntensity(self, ThresholdAtMeanIntensity):
        """
        SetThresholdAtMeanIntensity(HistogramMatchingImageFilter self, bool ThresholdAtMeanIntensity)



        Set/Get the threshold at mean intensity flag. If true, only source
        (reference) pixels which are greater than the mean source (reference)
        intensity is used in the histogram matching. If false, all pixels are
        used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_SetThresholdAtMeanIntensity(self, ThresholdAtMeanIntensity)


    def ThresholdAtMeanIntensityOn(self):
        """
        ThresholdAtMeanIntensityOn(HistogramMatchingImageFilter self)



        Set the value of ThresholdAtMeanIntensity to true or false
        respectfully.


        """
        return _SimpleITK.HistogramMatchingImageFilter_ThresholdAtMeanIntensityOn(self)


    def ThresholdAtMeanIntensityOff(self):
        """
        ThresholdAtMeanIntensityOff(HistogramMatchingImageFilter self)



        """
        return _SimpleITK.HistogramMatchingImageFilter_ThresholdAtMeanIntensityOff(self)


    def GetThresholdAtMeanIntensity(self):
        """
        GetThresholdAtMeanIntensity(HistogramMatchingImageFilter self) -> bool



        Set/Get the threshold at mean intensity flag. If true, only source
        (reference) pixels which are greater than the mean source (reference)
        intensity is used in the histogram matching. If false, all pixels are
        used.


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetThresholdAtMeanIntensity(self)


    def GetName(self):
        """
        GetName(HistogramMatchingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HistogramMatchingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HistogramMatchingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HistogramMatchingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HistogramMatchingImageFilter self, Image image1, Image image2) -> Image
        Execute(HistogramMatchingImageFilter self, Image image1, Image image2, uint32_t numberOfHistogramLevels, uint32_t numberOfMatchPoints, bool thresholdAtMeanIntensity) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.HistogramMatchingImageFilter_Execute(self, *args)

HistogramMatchingImageFilter_swigregister = _SimpleITK.HistogramMatchingImageFilter_swigregister
HistogramMatchingImageFilter_swigregister(HistogramMatchingImageFilter)


def HistogramMatching(image1, image2, numberOfHistogramLevels=256, numberOfMatchPoints=1, thresholdAtMeanIntensity=True):
    """
    HistogramMatching(Image image1, Image image2, uint32_t numberOfHistogramLevels=256, uint32_t numberOfMatchPoints=1, bool thresholdAtMeanIntensity=True) -> Image



    Normalize the grayscale values between two images by histogram
    matching.


    This function directly calls the execute method of HistogramMatchingImageFilter in order to support a procedural API


    See:
     itk::simple::HistogramMatchingImageFilter for the object oriented interface



    """
    return _SimpleITK.HistogramMatching(image1, image2, numberOfHistogramLevels, numberOfMatchPoints, thresholdAtMeanIntensity)
class HuangThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Huang Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the HuangThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::HuangThreshold for the procedural interface

     itk::HuangThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkHuangThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HuangThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HuangThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::HuangThresholdImageFilter self) -> HuangThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_HuangThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_HuangThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(HuangThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.HuangThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(HuangThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.HuangThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(HuangThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.HuangThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(HuangThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.HuangThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(HuangThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins. Defaults is 128.


        """
        return _SimpleITK.HuangThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(HuangThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.HuangThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(HuangThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.HuangThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(HuangThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.HuangThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(HuangThresholdImageFilter self)



        """
        return _SimpleITK.HuangThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(HuangThresholdImageFilter self) -> bool



        """
        return _SimpleITK.HuangThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(HuangThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.HuangThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(HuangThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.HuangThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(HuangThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.HuangThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(HuangThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.HuangThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(HuangThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.HuangThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(HuangThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(HuangThresholdImageFilter self, Image image) -> Image
        Execute(HuangThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(HuangThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.HuangThresholdImageFilter_Execute(self, *args)

HuangThresholdImageFilter_swigregister = _SimpleITK.HuangThresholdImageFilter_swigregister
HuangThresholdImageFilter_swigregister(HuangThresholdImageFilter)


def HuangThreshold(*args):
    """
    HuangThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255) -> Image
    HuangThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.HuangThreshold(*args)
class IntensityWindowingImageFilter(ImageFilter_1):
    """


    Applies a linear transformation to the intensity levels of the input Image that are inside a user-defined interval. Values below this interval
    are mapped to a constant. Values over the interval are mapped to
    another constant.


    IntensityWindowingImageFilter applies pixel-wise a linear transformation to the intensity values of
    input image pixels. The linear transformation is defined by the user
    in terms of the minimum and maximum values that the output image
    should have and the lower and upper limits of the intensity window of
    the input image. This operation is very common in visualization, and
    can also be applied as a convenient preprocessing operation for image
    segmentation.

    All computations are performed in the precison of the input pixel's
    RealType. Before assigning the computed value to the output pixel.

    Wiki Examples:

    All Examples

    IntensityWindowingImageFilter

    See:
     RescaleIntensityImageFilter

     itk::simple::IntensityWindowing for the procedural interface

     itk::IntensityWindowingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIntensityWindowingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntensityWindowingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntensityWindowingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::IntensityWindowingImageFilter self) -> IntensityWindowingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_IntensityWindowingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_IntensityWindowingImageFilter
    __del__ = lambda self: None

    def SetWindowMinimum(self, WindowMinimum):
        """
        SetWindowMinimum(IntensityWindowingImageFilter self, double WindowMinimum)



        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetWindowMinimum(self, WindowMinimum)


    def GetWindowMinimum(self):
        """
        GetWindowMinimum(IntensityWindowingImageFilter self) -> double



        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetWindowMinimum(self)


    def SetWindowMaximum(self, WindowMaximum):
        """
        SetWindowMaximum(IntensityWindowingImageFilter self, double WindowMaximum)



        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetWindowMaximum(self, WindowMaximum)


    def GetWindowMaximum(self):
        """
        GetWindowMaximum(IntensityWindowingImageFilter self) -> double



        Set/Get the values of the maximum and minimum intensities of the input
        intensity window.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetWindowMaximum(self)


    def SetOutputMinimum(self, OutputMinimum):
        """
        SetOutputMinimum(IntensityWindowingImageFilter self, double OutputMinimum)



        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetOutputMinimum(self, OutputMinimum)


    def GetOutputMinimum(self):
        """
        GetOutputMinimum(IntensityWindowingImageFilter self) -> double



        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetOutputMinimum(self)


    def SetOutputMaximum(self, OutputMaximum):
        """
        SetOutputMaximum(IntensityWindowingImageFilter self, double OutputMaximum)



        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_SetOutputMaximum(self, OutputMaximum)


    def GetOutputMaximum(self):
        """
        GetOutputMaximum(IntensityWindowingImageFilter self) -> double



        Set/Get the values of the maximum and minimum intensities of the
        output image.


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetOutputMaximum(self)


    def GetName(self):
        """
        GetName(IntensityWindowingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.IntensityWindowingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(IntensityWindowingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.IntensityWindowingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(IntensityWindowingImageFilter self, Image image1) -> Image
        Execute(IntensityWindowingImageFilter self, Image image1, double windowMinimum, double windowMaximum, double outputMinimum, double outputMaximum) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.IntensityWindowingImageFilter_Execute(self, *args)

IntensityWindowingImageFilter_swigregister = _SimpleITK.IntensityWindowingImageFilter_swigregister
IntensityWindowingImageFilter_swigregister(IntensityWindowingImageFilter)


def IntensityWindowing(image1, windowMinimum=0.0, windowMaximum=255, outputMinimum=0, outputMaximum=255):
    """
    IntensityWindowing(Image image1, double windowMinimum=0.0, double windowMaximum=255, double outputMinimum=0, double outputMaximum=255) -> Image



    Applies a linear transformation to the intensity levels of the input Image that are inside a user-defined interval. Values below this interval
    are mapped to a constant. Values over the interval are mapped to
    another constant.


    This function directly calls the execute method of IntensityWindowingImageFilter in order to support a procedural API


    See:
     itk::simple::IntensityWindowingImageFilter for the object oriented interface



    """
    return _SimpleITK.IntensityWindowing(image1, windowMinimum, windowMaximum, outputMinimum, outputMaximum)
class IntermodesThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Intermodes Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the IntermodesThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::IntermodesThreshold for the procedural interface

     itk::IntermodesThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIntermodesThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntermodesThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntermodesThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::IntermodesThresholdImageFilter self) -> IntermodesThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_IntermodesThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_IntermodesThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(IntermodesThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(IntermodesThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(IntermodesThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(IntermodesThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(IntermodesThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(IntermodesThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(IntermodesThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(IntermodesThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(IntermodesThresholdImageFilter self)



        """
        return _SimpleITK.IntermodesThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(IntermodesThresholdImageFilter self) -> bool



        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(IntermodesThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.IntermodesThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(IntermodesThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(IntermodesThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(IntermodesThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.IntermodesThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(IntermodesThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.IntermodesThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(IntermodesThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(IntermodesThresholdImageFilter self, Image image) -> Image
        Execute(IntermodesThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(IntermodesThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.IntermodesThresholdImageFilter_Execute(self, *args)

IntermodesThresholdImageFilter_swigregister = _SimpleITK.IntermodesThresholdImageFilter_swigregister
IntermodesThresholdImageFilter_swigregister(IntermodesThresholdImageFilter)


def IntermodesThreshold(*args):
    """
    IntermodesThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    IntermodesThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.IntermodesThreshold(*args)
class InverseDeconvolutionImageFilter(ImageFilter_2):
    """


    The direct linear inverse deconvolution filter.


    The inverse filter is the most straightforward deconvolution method.
    Considering that convolution of two images in the spatial domain is
    equivalent to multiplying the Fourier transform of the two images, the
    inverse filter consists of inverting the multiplication. In other
    words, this filter computes the following: \\[ hat{F}(\\omega) = \\begin{cases} G(\\omega) / H(\\omega)
    & \\text{if \\f$|H(\\omega)| \\geq \\epsilon\\f$} \\\\
    0 & \\text{otherwise} \\end{cases} \\] where $\\hat{F}(\\omega)$ is the Fourier transform of the estimate produced by this filter, $G(\\omega)$ is the Fourier transform of the input blurred image, $H(\\omega)$ is the Fourier transform of the blurring kernel, and $\\epsilon$ is a constant real non-negative threshold (called
    KernelZeroMagnitudeThreshold in this filter) that determines when the
    magnitude of a complex number is considered zero.


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France
     Cory Quammen, The University of North Carolina at Chapel Hill
    See:
     itk::simple::InverseDeconvolution for the procedural interface

     itk::InverseDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInverseDeconvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InverseDeconvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InverseDeconvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::InverseDeconvolutionImageFilter self) -> InverseDeconvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_InverseDeconvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_InverseDeconvolutionImageFilter
    __del__ = lambda self: None

    def SetKernelZeroMagnitudeThreshold(self, KernelZeroMagnitudeThreshold):
        """
        SetKernelZeroMagnitudeThreshold(InverseDeconvolutionImageFilter self, double KernelZeroMagnitudeThreshold)



        Set/get the threshold value uused to determine whether a frequency of
        the Fourier transform of the blurring kernel is considered to be zero.
        Default value is 1.0e-4.


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetKernelZeroMagnitudeThreshold(self, KernelZeroMagnitudeThreshold)


    def GetKernelZeroMagnitudeThreshold(self):
        """
        GetKernelZeroMagnitudeThreshold(InverseDeconvolutionImageFilter self) -> double



        Set/get the threshold value uused to determine whether a frequency of
        the Fourier transform of the blurring kernel is considered to be zero.
        Default value is 1.0e-4.


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetKernelZeroMagnitudeThreshold(self)


    def SetNormalize(self, Normalize):
        """
        SetNormalize(InverseDeconvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(InverseDeconvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(InverseDeconvolutionImageFilter self)



        """
        return _SimpleITK.InverseDeconvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(InverseDeconvolutionImageFilter self) -> bool



        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.InverseDeconvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.InverseDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.InverseDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(InverseDeconvolutionImageFilter self, itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(InverseDeconvolutionImageFilter self) -> itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.InverseDeconvolutionImageFilter_SAME
    VALID = _SimpleITK.InverseDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(InverseDeconvolutionImageFilter self, itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.InverseDeconvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(InverseDeconvolutionImageFilter self) -> itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(InverseDeconvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(InverseDeconvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.InverseDeconvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(InverseDeconvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(InverseDeconvolutionImageFilter self, Image image1, Image image2, double kernelZeroMagnitudeThreshold, bool normalize, itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.InverseDeconvolutionImageFilter_Execute(self, *args)

InverseDeconvolutionImageFilter_swigregister = _SimpleITK.InverseDeconvolutionImageFilter_swigregister
InverseDeconvolutionImageFilter_swigregister(InverseDeconvolutionImageFilter)


def InverseDeconvolution(*args, **kwargs):
    """
    InverseDeconvolution(Image image1, Image image2, double kernelZeroMagnitudeThreshold=1.0e-4, bool normalize=False, itk::simple::InverseDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::InverseDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    The direct linear inverse deconvolution filter.


    This function directly calls the execute method of InverseDeconvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::InverseDeconvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.InverseDeconvolution(*args, **kwargs)
class InverseDisplacementFieldImageFilter(ImageFilter_1):
    """


    Computes the inverse of a displacement field.


    InverseDisplacementFieldImageFilter takes a displacement field as input and computes the displacement
    field that is its inverse. If the input displacement field was mapping
    coordinates from a space A into a space B, the output of this filter
    will map coordinates from the space B into the space A.

    Given that both the input and output displacement field are
    represented as discrete images with pixel type vector, the inverse
    will be only an estimation and will probably not correspond to a
    perfect inverse. The precision of the inverse can be improved at the
    price of increasing the computation time and memory consumption in
    this filter.

    The method used for computing the inverse displacement field is to
    subsample the input field using a regular grid and create Kerned-Base
    Spline in which the reference landmarks are the coordinates of the
    deformed point and the target landmarks are the negative of the
    displacement vectors. The kernel-base spline is then used for
    regularly sampling the output space and recover vector values for
    every single pixel.

    The subsampling factor used for the regular grid of the input field
    will determine the number of landmarks in the KernelBased spline and
    therefore it will have a dramatic effect on both the precision of
    output displacement field and the computational time required for the
    filter to complete the estimation. A large subsampling factor will
    result in few landmarks in the KernelBased spline, therefore on fast
    computation and low precision. A small subsampling factor will result
    in a large number of landmarks in the KernelBased spline, therefore a
    large memory consumption, long computation time and high precision for
    the inverse estimation.

    This filter expects both the input and output images to be of pixel
    type Vector .
    See:
     itk::simple::InverseDisplacementField for the procedural interface

     itk::InverseDisplacementFieldImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInverseDisplacementFieldImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InverseDisplacementFieldImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InverseDisplacementFieldImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::InverseDisplacementFieldImageFilter self) -> InverseDisplacementFieldImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_InverseDisplacementFieldImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_InverseDisplacementFieldImageFilter
    __del__ = lambda self: None

    def SetSize(self, Size):
        """
        SetSize(InverseDisplacementFieldImageFilter self, VectorUInt32 Size)



        Set the size of the output image.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(InverseDisplacementFieldImageFilter self) -> VectorUInt32



        Get the size of the output image.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetSize(self)


    def SetOutputOrigin(self, OutputOrigin):
        """
        SetOutputOrigin(InverseDisplacementFieldImageFilter self, VectorDouble OutputOrigin)



        Set the output image origin.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetOutputOrigin(self, OutputOrigin)


    def GetOutputOrigin(self):
        """
        GetOutputOrigin(InverseDisplacementFieldImageFilter self) -> VectorDouble



        Get the output image origin.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetOutputOrigin(self)


    def SetOutputSpacing(self, OutputSpacing):
        """
        SetOutputSpacing(InverseDisplacementFieldImageFilter self, VectorDouble OutputSpacing)



        Set the output image spacing.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetOutputSpacing(self, OutputSpacing)


    def GetOutputSpacing(self):
        """
        GetOutputSpacing(InverseDisplacementFieldImageFilter self) -> VectorDouble



        Get the output image spacing.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetOutputSpacing(self)


    def SetSubsamplingFactor(self, SubsamplingFactor):
        """
        SetSubsamplingFactor(InverseDisplacementFieldImageFilter self, unsigned int SubsamplingFactor)



        Set/Get the factor used for subsampling the input displacement field.
        A large value in this factor will produce a fast computation of the
        inverse field but with low precision. A small value of this factor
        will produce a precise computation of the inverse field at the price
        of large memory consumption and long computational time.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetSubsamplingFactor(self, SubsamplingFactor)


    def GetSubsamplingFactor(self):
        """
        GetSubsamplingFactor(InverseDisplacementFieldImageFilter self) -> unsigned int



        Set/Get the factor used for subsampling the input displacement field.
        A large value in this factor will produce a fast computation of the
        inverse field but with low precision. A small value of this factor
        will produce a precise computation of the inverse field at the price
        of large memory consumption and long computational time.


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetSubsamplingFactor(self)


    def GetName(self):
        """
        GetName(InverseDisplacementFieldImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(InverseDisplacementFieldImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(InverseDisplacementFieldImageFilter self, Image image1) -> Image
        Execute(InverseDisplacementFieldImageFilter self, Image image1, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing, unsigned int subsamplingFactor) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_Execute(self, *args)


    def SetReferenceImage(self, refImage):
        """
        SetReferenceImage(InverseDisplacementFieldImageFilter self, Image refImage)



        This methods sets the output size, origin, and direction to that of
        the provided image


        """
        return _SimpleITK.InverseDisplacementFieldImageFilter_SetReferenceImage(self, refImage)

InverseDisplacementFieldImageFilter_swigregister = _SimpleITK.InverseDisplacementFieldImageFilter_swigregister
InverseDisplacementFieldImageFilter_swigregister(InverseDisplacementFieldImageFilter)


def InverseDisplacementField(*args, **kwargs):
    """
    InverseDisplacementField(Image image1, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing, unsigned int subsamplingFactor=16) -> Image



    Computes the inverse of a displacement field.


    This function directly calls the execute method of InverseDisplacementFieldImageFilter in order to support a procedural API


    See:
     itk::simple::InverseDisplacementFieldImageFilter for the object oriented interface



    """
    return _SimpleITK.InverseDisplacementField(*args, **kwargs)
class InverseFFTImageFilter(ImageFilter_1):
    """


    Base class for inverse Fast Fourier Transform .


    This is a base class for the "inverse" or "reverse" Discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child available on the system when the object is
    created via the object factory system.

    This class transforms a full complex image with Hermitian symmetry
    into its real spatial domain representation. If the input does not
    have Hermitian symmetry, the imaginary component is discarded.


    See:
     ForwardFFTImageFilter , InverseFFTImageFilter

     itk::simple::InverseFFT for the procedural interface

     itk::InverseFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInverseFFTImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InverseFFTImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InverseFFTImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::InverseFFTImageFilter self) -> InverseFFTImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_InverseFFTImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_InverseFFTImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(InverseFFTImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.InverseFFTImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(InverseFFTImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.InverseFFTImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(InverseFFTImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.InverseFFTImageFilter_Execute(self, image1)

InverseFFTImageFilter_swigregister = _SimpleITK.InverseFFTImageFilter_swigregister
InverseFFTImageFilter_swigregister(InverseFFTImageFilter)


def InverseFFT(image1):
    """
    InverseFFT(Image image1) -> Image



    Base class for inverse Fast Fourier Transform .


    This function directly calls the execute method of InverseFFTImageFilter in order to support a procedural API


    See:
     itk::simple::InverseFFTImageFilter for the object oriented interface



    """
    return _SimpleITK.InverseFFT(image1)
class InvertDisplacementFieldImageFilter(ImageFilter_1):
    """


    Iteratively estimate the inverse field of a displacement field.



    Nick Tustison
     Brian Avants
    See:
     itk::simple::InvertDisplacementField for the procedural interface

     itk::InvertDisplacementFieldImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkInvertDisplacementFieldImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvertDisplacementFieldImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvertDisplacementFieldImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::InvertDisplacementFieldImageFilter self) -> InvertDisplacementFieldImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_InvertDisplacementFieldImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_InvertDisplacementFieldImageFilter
    __del__ = lambda self: None

    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        """
        SetMaximumNumberOfIterations(InvertDisplacementFieldImageFilter self, uint32_t MaximumNumberOfIterations)



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetMaximumNumberOfIterations(self, MaximumNumberOfIterations)


    def GetMaximumNumberOfIterations(self):
        """
        GetMaximumNumberOfIterations(InvertDisplacementFieldImageFilter self) -> uint32_t



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMaximumNumberOfIterations(self)


    def SetMaxErrorToleranceThreshold(self, MaxErrorToleranceThreshold):
        """
        SetMaxErrorToleranceThreshold(InvertDisplacementFieldImageFilter self, double MaxErrorToleranceThreshold)



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetMaxErrorToleranceThreshold(self, MaxErrorToleranceThreshold)


    def GetMaxErrorToleranceThreshold(self):
        """
        GetMaxErrorToleranceThreshold(InvertDisplacementFieldImageFilter self) -> double



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMaxErrorToleranceThreshold(self)


    def SetMeanErrorToleranceThreshold(self, MeanErrorToleranceThreshold):
        """
        SetMeanErrorToleranceThreshold(InvertDisplacementFieldImageFilter self, double MeanErrorToleranceThreshold)



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetMeanErrorToleranceThreshold(self, MeanErrorToleranceThreshold)


    def GetMeanErrorToleranceThreshold(self):
        """
        GetMeanErrorToleranceThreshold(InvertDisplacementFieldImageFilter self) -> double



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMeanErrorToleranceThreshold(self)


    def SetEnforceBoundaryCondition(self, EnforceBoundaryCondition):
        """
        SetEnforceBoundaryCondition(InvertDisplacementFieldImageFilter self, bool EnforceBoundaryCondition)



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_SetEnforceBoundaryCondition(self, EnforceBoundaryCondition)


    def EnforceBoundaryConditionOn(self):
        """
        EnforceBoundaryConditionOn(InvertDisplacementFieldImageFilter self)



        Set the value of EnforceBoundaryCondition to true or false
        respectfully.


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_EnforceBoundaryConditionOn(self)


    def EnforceBoundaryConditionOff(self):
        """
        EnforceBoundaryConditionOff(InvertDisplacementFieldImageFilter self)



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_EnforceBoundaryConditionOff(self)


    def GetEnforceBoundaryCondition(self):
        """
        GetEnforceBoundaryCondition(InvertDisplacementFieldImageFilter self) -> bool



        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetEnforceBoundaryCondition(self)


    def GetMaxErrorNorm(self):
        """
        GetMaxErrorNorm(InvertDisplacementFieldImageFilter self) -> double



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMaxErrorNorm(self)


    def GetMeanErrorNorm(self):
        """
        GetMeanErrorNorm(InvertDisplacementFieldImageFilter self) -> double



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetMeanErrorNorm(self)


    def GetName(self):
        """
        GetName(InvertDisplacementFieldImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(InvertDisplacementFieldImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(InvertDisplacementFieldImageFilter self, Image image1) -> Image
        Execute(InvertDisplacementFieldImageFilter self, Image image1, uint32_t maximumNumberOfIterations, double maxErrorToleranceThreshold, double meanErrorToleranceThreshold, bool enforceBoundaryCondition) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.InvertDisplacementFieldImageFilter_Execute(self, *args)

InvertDisplacementFieldImageFilter_swigregister = _SimpleITK.InvertDisplacementFieldImageFilter_swigregister
InvertDisplacementFieldImageFilter_swigregister(InvertDisplacementFieldImageFilter)


def InvertDisplacementField(image1, maximumNumberOfIterations=10, maxErrorToleranceThreshold=0.1, meanErrorToleranceThreshold=0.001, enforceBoundaryCondition=True):
    """
    InvertDisplacementField(Image image1, uint32_t maximumNumberOfIterations=10, double maxErrorToleranceThreshold=0.1, double meanErrorToleranceThreshold=0.001, bool enforceBoundaryCondition=True) -> Image



    Iteratively estimate the inverse field of a displacement field.


    This function directly calls the execute method of InvertDisplacementFieldImageFilter in order to support a procedural API


    See:
     itk::simple::InvertDisplacementFieldImageFilter for the object oriented interface



    """
    return _SimpleITK.InvertDisplacementField(image1, maximumNumberOfIterations, maxErrorToleranceThreshold, meanErrorToleranceThreshold, enforceBoundaryCondition)
class InvertIntensityImageFilter(ImageFilter_1):
    """


    Invert the intensity of an image.


    InvertIntensityImageFilter inverts intensity of pixels by subtracting pixel value to a maximum
    value. The maximum value can be set with SetMaximum and defaults the
    maximum of input pixel type. This filter can be used to invert, for
    example, a binary image, a distance map, etc.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     IntensityWindowingImageFilter ShiftScaleImageFilter
    Wiki Examples:

    All Examples

    Invert an image
    See:
     itk::simple::InvertIntensity for the procedural interface

     itk::InvertIntensityImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkInvertIntensityImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InvertIntensityImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InvertIntensityImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::InvertIntensityImageFilter self) -> InvertIntensityImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_InvertIntensityImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_InvertIntensityImageFilter
    __del__ = lambda self: None

    def SetMaximum(self, Maximum):
        """
        SetMaximum(InvertIntensityImageFilter self, double Maximum)



        Set/Get the maximum intensity value for the inversion.


        """
        return _SimpleITK.InvertIntensityImageFilter_SetMaximum(self, Maximum)


    def GetMaximum(self):
        """
        GetMaximum(InvertIntensityImageFilter self) -> double



        Set/Get the maximum intensity value for the inversion.


        """
        return _SimpleITK.InvertIntensityImageFilter_GetMaximum(self)


    def GetName(self):
        """
        GetName(InvertIntensityImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.InvertIntensityImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(InvertIntensityImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.InvertIntensityImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(InvertIntensityImageFilter self, Image image1) -> Image
        Execute(InvertIntensityImageFilter self, Image image1, double maximum) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.InvertIntensityImageFilter_Execute(self, *args)

InvertIntensityImageFilter_swigregister = _SimpleITK.InvertIntensityImageFilter_swigregister
InvertIntensityImageFilter_swigregister(InvertIntensityImageFilter)


def InvertIntensity(image1, maximum=255):
    """
    InvertIntensity(Image image1, double maximum=255) -> Image



    Invert the intensity of an image.


    This function directly calls the execute method of InvertIntensityImageFilter in order to support a procedural API


    See:
     itk::simple::InvertIntensityImageFilter for the object oriented interface



    """
    return _SimpleITK.InvertIntensity(image1, maximum)
class IsoContourDistanceImageFilter(ImageFilter_1):
    """


    Compute an approximate distance from an interpolated isocontour to the
    close grid points.


    For standard level set algorithms, it is useful to periodically
    reinitialize the evolving image to prevent numerical accuracy problems
    in computing derivatives. This reinitialization is done by computing a
    signed distance map to the current level set. This class provides the
    first step in this reinitialization by computing an estimate of the
    distance from the interpolated isocontour to the pixels (or voxels)
    that are close to it, i.e. for which the isocontour crosses a segment
    between them and one of their direct neighbors. This class supports
    narrowbanding. If the input narrowband is provided, the algorithm will
    only locate the level set within the input narrowband.

    Implementation of this class is based on Fast and Accurate
    Redistancing for Level Set Methods `Krissian K. and Westin C.F.',
    EUROCAST NeuroImaging Workshop Las Palmas Spain, Ninth International
    Conference on Computer Aided Systems Theory , pages 48-51, Feb 2003.
    See:
     itk::simple::IsoContourDistance for the procedural interface

     itk::IsoContourDistanceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsoContourDistanceImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsoContourDistanceImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IsoContourDistanceImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::IsoContourDistanceImageFilter self) -> IsoContourDistanceImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_IsoContourDistanceImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_IsoContourDistanceImageFilter
    __del__ = lambda self: None

    def SetLevelSetValue(self, LevelSetValue):
        """
        SetLevelSetValue(IsoContourDistanceImageFilter self, double LevelSetValue)



        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_SetLevelSetValue(self, LevelSetValue)


    def GetLevelSetValue(self):
        """
        GetLevelSetValue(IsoContourDistanceImageFilter self) -> double



        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_GetLevelSetValue(self)


    def SetFarValue(self, FarValue):
        """
        SetFarValue(IsoContourDistanceImageFilter self, double FarValue)



        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_SetFarValue(self, FarValue)


    def GetFarValue(self):
        """
        GetFarValue(IsoContourDistanceImageFilter self) -> double



        Set/Get the value of the level set to be located. The default value is
        0.


        """
        return _SimpleITK.IsoContourDistanceImageFilter_GetFarValue(self)


    def GetName(self):
        """
        GetName(IsoContourDistanceImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.IsoContourDistanceImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(IsoContourDistanceImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.IsoContourDistanceImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(IsoContourDistanceImageFilter self, Image image1) -> Image
        Execute(IsoContourDistanceImageFilter self, Image image1, double levelSetValue, double farValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.IsoContourDistanceImageFilter_Execute(self, *args)

IsoContourDistanceImageFilter_swigregister = _SimpleITK.IsoContourDistanceImageFilter_swigregister
IsoContourDistanceImageFilter_swigregister(IsoContourDistanceImageFilter)


def IsoContourDistance(image1, levelSetValue=0, farValue=10):
    """
    IsoContourDistance(Image image1, double levelSetValue=0, double farValue=10) -> Image



    Compute an approximate distance from an interpolated isocontour to the
    close grid points.


    This function directly calls the execute method of IsoContourDistanceImageFilter in order to support a procedural API


    See:
     itk::simple::IsoContourDistanceImageFilter for the object oriented interface



    """
    return _SimpleITK.IsoContourDistance(image1, levelSetValue, farValue)
class IsoDataThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the IsoData Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the IsoDataThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::IsoDataThreshold for the procedural interface

     itk::IsoDataThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsoDataThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsoDataThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IsoDataThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::IsoDataThresholdImageFilter self) -> IsoDataThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_IsoDataThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_IsoDataThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(IsoDataThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(IsoDataThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(IsoDataThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(IsoDataThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(IsoDataThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(IsoDataThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(IsoDataThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(IsoDataThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(IsoDataThresholdImageFilter self)



        """
        return _SimpleITK.IsoDataThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(IsoDataThresholdImageFilter self) -> bool



        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(IsoDataThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.IsoDataThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(IsoDataThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(IsoDataThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(IsoDataThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.IsoDataThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(IsoDataThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.IsoDataThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(IsoDataThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(IsoDataThresholdImageFilter self, Image image) -> Image
        Execute(IsoDataThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(IsoDataThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.IsoDataThresholdImageFilter_Execute(self, *args)

IsoDataThresholdImageFilter_swigregister = _SimpleITK.IsoDataThresholdImageFilter_swigregister
IsoDataThresholdImageFilter_swigregister(IsoDataThresholdImageFilter)


def IsoDataThreshold(*args):
    """
    IsoDataThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    IsoDataThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.IsoDataThreshold(*args)
class IsolatedConnectedImageFilter(ImageFilter_1):
    """


    Label pixels that are connected to one set of seeds but not another.


    IsolatedConnectedImageFilter finds the optimal threshold to separate two regions. It has two
    modes, one to separate dark regions surrounded by bright regions by
    automatically finding a minimum isolating upper threshold, and another
    to separate bright regions surrounded by dark regions by automatically
    finding a maximum lower isolating threshold. The mode can be chosen by
    setting FindUpperThresholdOn() /Off(). In both cases, the isolating threshold is retrieved with GetIsolatedValue() .

    The algorithm labels pixels with ReplaceValue that are connected to
    Seeds1 AND NOT connected to Seeds2. When finding the threshold to
    separate two dark regions surrounded by bright regions, given a fixed
    lower threshold, the filter adjusts the upper threshold until the two
    sets of seeds are not connected. The algorithm uses a binary search to
    adjust the upper threshold, starting at Upper. The reverse is true for
    finding the threshold to separate two bright regions. Lower defaults
    to the smallest possible value for the InputImagePixelType, and Upper
    defaults to the largest possible value for the InputImagePixelType.

    The user can also supply the Lower and Upper values to restrict the
    search. However, if the range is too restrictive, it could happen that
    no isolating threshold can be found between the user specified Lower
    and Upper values. Therefore, unless the user is sure of the bounds to
    set, it is recommended that the user set these values to the lowest
    and highest intensity values in the image, respectively.

    The user can specify more than one seed for both regions to separate.
    The algorithm will try find the threshold that ensures that all of the
    first seeds are contained in the resulting segmentation and all of the
    second seeds are not contained in the segmentation.

    It is possible that the algorithm may not be able to find the
    isolating threshold because no such threshold exists. The user can
    check for this by querying the GetThresholdingFailed() flag.
    See:
     itk::simple::IsolatedConnected for the procedural interface

     itk::IsolatedConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsolatedConnectedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsolatedConnectedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IsolatedConnectedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::IsolatedConnectedImageFilter self) -> IsolatedConnectedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_IsolatedConnectedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_IsolatedConnectedImageFilter
    __del__ = lambda self: None

    def SetSeed1(self, Seed1):
        """
        SetSeed1(IsolatedConnectedImageFilter self, VectorUInt32 Seed1)



        DeprecatedSet seed point 1. This seed will be isolated from Seed2 (if
        possible). All pixels connected to this seed will be replaced with
        ReplaceValue. This method is deprecated, please use AddSeed1() .


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetSeed1(self, Seed1)


    def GetSeed1(self):
        """
        GetSeed1(IsolatedConnectedImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetSeed1(self)


    def SetSeed2(self, Seed2):
        """
        SetSeed2(IsolatedConnectedImageFilter self, VectorUInt32 Seed2)



        DeprecatedSet seed point 2. This seed will be isolated from Seed1 (if
        possible). This method is deprecated, please use AddSeed2() .


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetSeed2(self, Seed2)


    def GetSeed2(self):
        """
        GetSeed2(IsolatedConnectedImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetSeed2(self)


    def SetLower(self, Lower):
        """
        SetLower(IsolatedConnectedImageFilter self, double Lower)



        Set/Get the limit on the lower threshold value. The default is the
        NonpositiveMin() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetLower(self, Lower)


    def GetLower(self):
        """
        GetLower(IsolatedConnectedImageFilter self) -> double



        Set/Get the limit on the lower threshold value. The default is the
        NonpositiveMin() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetLower(self)


    def SetUpper(self, Upper):
        """
        SetUpper(IsolatedConnectedImageFilter self, double Upper)



        Set/Get the limit on the upper threshold value. The default is the
        max() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetUpper(self, Upper)


    def GetUpper(self):
        """
        GetUpper(IsolatedConnectedImageFilter self) -> double



        Set/Get the limit on the upper threshold value. The default is the
        max() for the InputPixelType.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetUpper(self)


    def SetReplaceValue(self, ReplaceValue):
        """
        SetReplaceValue(IsolatedConnectedImageFilter self, uint8_t ReplaceValue)



        Set/Get value to replace thresholded pixels. Pixels that lie within
        the thresholds will be replaced with this value. The default is 1.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetReplaceValue(self, ReplaceValue)


    def GetReplaceValue(self):
        """
        GetReplaceValue(IsolatedConnectedImageFilter self) -> uint8_t



        Set/Get value to replace thresholded pixels. Pixels that lie within
        the thresholds will be replaced with this value. The default is 1.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetReplaceValue(self)


    def SetIsolatedValueTolerance(self, IsolatedValueTolerance):
        """
        SetIsolatedValueTolerance(IsolatedConnectedImageFilter self, double IsolatedValueTolerance)



        Set/Get the precision required for the intensity threshold value. The
        default is 1.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetIsolatedValueTolerance(self, IsolatedValueTolerance)


    def GetIsolatedValueTolerance(self):
        """
        GetIsolatedValueTolerance(IsolatedConnectedImageFilter self) -> double



        Set/Get the precision required for the intensity threshold value. The
        default is 1.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetIsolatedValueTolerance(self)


    def SetFindUpperThreshold(self, FindUpperThreshold):
        """
        SetFindUpperThreshold(IsolatedConnectedImageFilter self, bool FindUpperThreshold)



        Set/Get whether to find an upper threshold (separating two dark
        regions) or a lower threshold (separating two bright regions).


        """
        return _SimpleITK.IsolatedConnectedImageFilter_SetFindUpperThreshold(self, FindUpperThreshold)


    def FindUpperThresholdOn(self):
        """
        FindUpperThresholdOn(IsolatedConnectedImageFilter self)



        Set the value of FindUpperThreshold to true or false respectfully.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_FindUpperThresholdOn(self)


    def FindUpperThresholdOff(self):
        """
        FindUpperThresholdOff(IsolatedConnectedImageFilter self)



        """
        return _SimpleITK.IsolatedConnectedImageFilter_FindUpperThresholdOff(self)


    def GetFindUpperThreshold(self):
        """
        GetFindUpperThreshold(IsolatedConnectedImageFilter self) -> bool



        Set/Get whether to find an upper threshold (separating two dark
        regions) or a lower threshold (separating two bright regions).


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetFindUpperThreshold(self)


    def GetThresholdingFailed(self):
        """
        GetThresholdingFailed(IsolatedConnectedImageFilter self) -> bool



        Get the flag that tells whether the algorithm failed to find a
        threshold.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetThresholdingFailed(self)


    def GetIsolatedValue(self):
        """
        GetIsolatedValue(IsolatedConnectedImageFilter self) -> double



        Get value that isolates the two seeds.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetIsolatedValue(self)


    def GetName(self):
        """
        GetName(IsolatedConnectedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.IsolatedConnectedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(IsolatedConnectedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.IsolatedConnectedImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(IsolatedConnectedImageFilter self, Image image1) -> Image
        Execute(IsolatedConnectedImageFilter self, Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower, double upper, uint8_t replaceValue, double isolatedValueTolerance, bool findUpperThreshold) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.IsolatedConnectedImageFilter_Execute(self, *args)

IsolatedConnectedImageFilter_swigregister = _SimpleITK.IsolatedConnectedImageFilter_swigregister
IsolatedConnectedImageFilter_swigregister(IsolatedConnectedImageFilter)


def IsolatedConnected(*args, **kwargs):
    """
    IsolatedConnected(Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double lower=0, double upper=1, uint8_t replaceValue=1, double isolatedValueTolerance=1.0, bool findUpperThreshold=True) -> Image



    Label pixels that are connected to one set of seeds but not another.


    This function directly calls the execute method of IsolatedConnectedImageFilter in order to support a procedural API


    See:
     itk::simple::IsolatedConnectedImageFilter for the object oriented interface



    """
    return _SimpleITK.IsolatedConnected(*args, **kwargs)
class IsolatedWatershedImageFilter(ImageFilter_1):
    """


    Isolate watershed basins using two seeds.


    IsolatedWatershedImageFilter labels pixels with ReplaceValue1 that are in the same watershed basin
    as Seed1 AND NOT the same as Seed2. The filter adjusts the waterlevel
    until the two seeds are not in different basins. The user supplies a
    Watershed threshold. The algorithm uses a binary search to adjust the
    upper waterlevel, starting at UpperValueLimit. UpperValueLimit
    defaults to the 1.0.
    See:
     itk::simple::IsolatedWatershed for the procedural interface

     itk::IsolatedWatershedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkIsolatedWatershedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsolatedWatershedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IsolatedWatershedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::IsolatedWatershedImageFilter self) -> IsolatedWatershedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_IsolatedWatershedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_IsolatedWatershedImageFilter
    __del__ = lambda self: None

    def SetSeed1(self, Seed1):
        """
        SetSeed1(IsolatedWatershedImageFilter self, VectorUInt32 Seed1)



        Set seed point 1. This seed will be isolated from Seed2 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue1.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetSeed1(self, Seed1)


    def GetSeed1(self):
        """
        GetSeed1(IsolatedWatershedImageFilter self) -> VectorUInt32



        Set seed point 1. This seed will be isolated from Seed2 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue1.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetSeed1(self)


    def SetSeed2(self, Seed2):
        """
        SetSeed2(IsolatedWatershedImageFilter self, VectorUInt32 Seed2)



        Set seed point 2. This seed will be isolated from Seed1 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue2.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetSeed2(self, Seed2)


    def GetSeed2(self):
        """
        GetSeed2(IsolatedWatershedImageFilter self) -> VectorUInt32



        Set seed point 2. This seed will be isolated from Seed1 (if possible).
        All pixels connected to this seed will be replaced with ReplaceValue2.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetSeed2(self)


    def SetThreshold(self, Threshold):
        """
        SetThreshold(IsolatedWatershedImageFilter self, double Threshold)



        Set/Get the Watershed threshold. The default is 0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetThreshold(self, Threshold)


    def GetThreshold(self):
        """
        GetThreshold(IsolatedWatershedImageFilter self) -> double



        Set/Get the Watershed threshold. The default is 0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetThreshold(self)


    def SetUpperValueLimit(self, UpperValueLimit):
        """
        SetUpperValueLimit(IsolatedWatershedImageFilter self, double UpperValueLimit)



        Set/Get the limit on the upper waterlevel value. The default is 1.0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetUpperValueLimit(self, UpperValueLimit)


    def GetUpperValueLimit(self):
        """
        GetUpperValueLimit(IsolatedWatershedImageFilter self) -> double



        Set/Get the limit on the upper waterlevel value. The default is 1.0.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetUpperValueLimit(self)


    def SetIsolatedValueTolerance(self, IsolatedValueTolerance):
        """
        SetIsolatedValueTolerance(IsolatedWatershedImageFilter self, double IsolatedValueTolerance)



        Set/Get the precision required for the intensity threshold value. The
        default is .001.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetIsolatedValueTolerance(self, IsolatedValueTolerance)


    def GetIsolatedValueTolerance(self):
        """
        GetIsolatedValueTolerance(IsolatedWatershedImageFilter self) -> double



        Set/Get the precision required for the intensity threshold value. The
        default is .001.


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetIsolatedValueTolerance(self)


    def SetReplaceValue1(self, ReplaceValue1):
        """
        SetReplaceValue1(IsolatedWatershedImageFilter self, uint8_t ReplaceValue1)



        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetReplaceValue1(self, ReplaceValue1)


    def GetReplaceValue1(self):
        """
        GetReplaceValue1(IsolatedWatershedImageFilter self) -> uint8_t



        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetReplaceValue1(self)


    def SetReplaceValue2(self, ReplaceValue2):
        """
        SetReplaceValue2(IsolatedWatershedImageFilter self, uint8_t ReplaceValue2)



        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_SetReplaceValue2(self, ReplaceValue2)


    def GetReplaceValue2(self):
        """
        GetReplaceValue2(IsolatedWatershedImageFilter self) -> uint8_t



        Set/Get value to replace Seed1(Seed2) pixels, pixels that are within
        the basin that contains Seed1(Seed2) this value. The default is 1(0).


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetReplaceValue2(self)


    def GetName(self):
        """
        GetName(IsolatedWatershedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.IsolatedWatershedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(IsolatedWatershedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.IsolatedWatershedImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(IsolatedWatershedImageFilter self, Image image1) -> Image
        Execute(IsolatedWatershedImageFilter self, Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold, double upperValueLimit, double isolatedValueTolerance, uint8_t replaceValue1, uint8_t replaceValue2) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.IsolatedWatershedImageFilter_Execute(self, *args)

IsolatedWatershedImageFilter_swigregister = _SimpleITK.IsolatedWatershedImageFilter_swigregister
IsolatedWatershedImageFilter_swigregister(IsolatedWatershedImageFilter)


def IsolatedWatershed(*args, **kwargs):
    """
    IsolatedWatershed(Image image1, VectorUInt32 seed1, VectorUInt32 seed2, double threshold=0.0, double upperValueLimit=1.0, double isolatedValueTolerance=0.001, uint8_t replaceValue1=1, uint8_t replaceValue2=2) -> Image



    Isolate watershed basins using two seeds.


    This function directly calls the execute method of IsolatedWatershedImageFilter in order to support a procedural API


    See:
     itk::simple::IsolatedWatershedImageFilter for the object oriented interface



    """
    return _SimpleITK.IsolatedWatershed(*args, **kwargs)
class JoinSeriesImageFilter(ImageFilter_3):
    """


    Join N-D images into an (N+1)-D image.


    This filter is templated over the input image type and the output
    image type. The pixel type of them must be the same and the input
    dimension must be less than the output dimension. When the input
    images are N-dimensinal, they are joined in order and the size of the
    N+1'th dimension of the output is same as the number of the inputs.
    The spacing and the origin (where the first input is placed) for the
    N+1'th dimension is specified in this filter. The output image
    informations for the first N dimensions are taken from the first
    input. Note that all the inputs should have the same information.


    Hideaki Hiraki
     Contributed in the users list http://public.kitware.com/pipermail/insight-
    users/2004-February/006542.html


    See:
     itk::simple::JoinSeries for the procedural interface


    C++ includes: sitkJoinSeriesImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JoinSeriesImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JoinSeriesImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::JoinSeriesImageFilter self) -> JoinSeriesImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_JoinSeriesImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_JoinSeriesImageFilter
    __del__ = lambda self: None

    def SetOrigin(self, Origin):
        """
        SetOrigin(JoinSeriesImageFilter self, double Origin)



        Set/Get origin of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_SetOrigin(self, Origin)


    def GetOrigin(self):
        """
        GetOrigin(JoinSeriesImageFilter self) -> double



        Set/Get origin of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_GetOrigin(self)


    def SetSpacing(self, Spacing):
        """
        SetSpacing(JoinSeriesImageFilter self, double Spacing)



        Set/Get spacing of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_SetSpacing(self, Spacing)


    def GetSpacing(self):
        """
        GetSpacing(JoinSeriesImageFilter self) -> double



        Set/Get spacing of the new dimension


        """
        return _SimpleITK.JoinSeriesImageFilter_GetSpacing(self)


    def GetName(self):
        """
        GetName(JoinSeriesImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.JoinSeriesImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(JoinSeriesImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.JoinSeriesImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(JoinSeriesImageFilter self, VectorOfImage images) -> Image
        Execute(JoinSeriesImageFilter self, Image image1) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
        Execute(JoinSeriesImageFilter self, VectorOfImage images, double origin, double spacing) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, double origin, double spacing) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, double origin, double spacing) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, double origin, double spacing) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, Image image4, double origin, double spacing) -> Image
        Execute(JoinSeriesImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5, double origin, double spacing) -> Image



        """
        return _SimpleITK.JoinSeriesImageFilter_Execute(self, *args)

JoinSeriesImageFilter_swigregister = _SimpleITK.JoinSeriesImageFilter_swigregister
JoinSeriesImageFilter_swigregister(JoinSeriesImageFilter)


def JoinSeries(*args):
    """
    JoinSeries(VectorOfImage images, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, Image image3, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, Image image3, Image image4, double origin=0.0, double spacing=1.0) -> Image
    JoinSeries(Image image1, Image image2, Image image3, Image image4, Image image5, double origin=0.0, double spacing=1.0) -> Image
    """
    return _SimpleITK.JoinSeries(*args)
class KittlerIllingworthThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the KittlerIllingworth Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the KittlerIllingworthThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::KittlerIllingworthThreshold for the procedural interface

     itk::KittlerIllingworthThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkKittlerIllingworthThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KittlerIllingworthThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KittlerIllingworthThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::KittlerIllingworthThresholdImageFilter self) -> KittlerIllingworthThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_KittlerIllingworthThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_KittlerIllingworthThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(KittlerIllingworthThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(KittlerIllingworthThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(KittlerIllingworthThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(KittlerIllingworthThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(KittlerIllingworthThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(KittlerIllingworthThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(KittlerIllingworthThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(KittlerIllingworthThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(KittlerIllingworthThresholdImageFilter self)



        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(KittlerIllingworthThresholdImageFilter self) -> bool



        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(KittlerIllingworthThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(KittlerIllingworthThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(KittlerIllingworthThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(KittlerIllingworthThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(KittlerIllingworthThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(KittlerIllingworthThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(KittlerIllingworthThresholdImageFilter self, Image image) -> Image
        Execute(KittlerIllingworthThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(KittlerIllingworthThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.KittlerIllingworthThresholdImageFilter_Execute(self, *args)

KittlerIllingworthThresholdImageFilter_swigregister = _SimpleITK.KittlerIllingworthThresholdImageFilter_swigregister
KittlerIllingworthThresholdImageFilter_swigregister(KittlerIllingworthThresholdImageFilter)


def KittlerIllingworthThreshold(*args):
    """
    KittlerIllingworthThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    KittlerIllingworthThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.KittlerIllingworthThreshold(*args)
class LabelContourImageFilter(ImageFilter_1):
    """


    Labels the pixels on the border of the objects in a labeled image.


    LabelContourImageFilter takes a labeled image as input, where the pixels in the objects are
    the pixels with a value different of the BackgroundValue. Only the
    pixels on the contours of the objects are kept. The pixels not on the
    border are changed to BackgroundValue. The labels of the object are
    the same in the input and in the output image.

    The connectivity can be changed to minimum or maximum connectivity
    with SetFullyConnected() . Full connectivity produces thicker contours.

    https://hdl.handle.net/1926/1352


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     BinaryContourImageFilter
    Wiki Examples:

    All Examples

    Label the contours of connected components
    See:
     itk::simple::LabelContour for the procedural interface

     itk::LabelContourImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLabelContourImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelContourImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelContourImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelContourImageFilter self) -> LabelContourImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelContourImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelContourImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(LabelContourImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff.
        For objects that are 1 pixel wide, use FullyConnectedOn.



        """
        return _SimpleITK.LabelContourImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(LabelContourImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.LabelContourImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(LabelContourImageFilter self)



        """
        return _SimpleITK.LabelContourImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(LabelContourImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff.
        For objects that are 1 pixel wide, use FullyConnectedOn.



        """
        return _SimpleITK.LabelContourImageFilter_GetFullyConnected(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelContourImageFilter self, double BackgroundValue)



        Set/Get the background value used to identify the objects and mark the
        pixels not on the border of the objects.


        """
        return _SimpleITK.LabelContourImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelContourImageFilter self) -> double



        Set/Get the background value used to identify the objects and mark the
        pixels not on the border of the objects.


        """
        return _SimpleITK.LabelContourImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(LabelContourImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelContourImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelContourImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelContourImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelContourImageFilter self, Image image1) -> Image
        Execute(LabelContourImageFilter self, Image image1, bool fullyConnected, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelContourImageFilter_Execute(self, *args)

LabelContourImageFilter_swigregister = _SimpleITK.LabelContourImageFilter_swigregister
LabelContourImageFilter_swigregister(LabelContourImageFilter)


def LabelContour(image1, fullyConnected=False, backgroundValue=0):
    """
    LabelContour(Image image1, bool fullyConnected=False, double backgroundValue=0) -> Image



    Labels the pixels on the border of the objects in a labeled image.


    This function directly calls the execute method of LabelContourImageFilter in order to support a procedural API


    See:
     itk::simple::LabelContourImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelContour(image1, fullyConnected, backgroundValue)
class LabelImageToLabelMapFilter(ImageFilter_1):
    """


    convert a labeled image to a label collection image


    LabelImageToLabelMapFilter converts a label image to a label collection image. The labels are
    the same in the input and the output image.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     BinaryImageToLabelMapFilter , LabelMapToLabelImageFilter
    Wiki Examples:

    All Examples

    Convert an itk::Image consisting of labeled regions to a LabelMap
    See:
     itk::simple::LabelImageToLabelMapFilter for the procedural interface

     itk::LabelImageToLabelMapFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLabelImageToLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelImageToLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelImageToLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelImageToLabelMapFilter self) -> LabelImageToLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelImageToLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelImageToLabelMapFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelImageToLabelMapFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelImageToLabelMapFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelImageToLabelMapFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelImageToLabelMapFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(LabelImageToLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelImageToLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelImageToLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelImageToLabelMapFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelImageToLabelMapFilter self, Image image1) -> Image
        Execute(LabelImageToLabelMapFilter self, Image image1, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelImageToLabelMapFilter_Execute(self, *args)

LabelImageToLabelMapFilter_swigregister = _SimpleITK.LabelImageToLabelMapFilter_swigregister
LabelImageToLabelMapFilter_swigregister(LabelImageToLabelMapFilter)


def LabelImageToLabelMap(image1, backgroundValue=0):
    """
    LabelImageToLabelMap(Image image1, double backgroundValue=0) -> Image



    convert a labeled image to a label collection image


    This function directly calls the execute method of LabelImageToLabelMapFilter in order to support a procedural API


    See:
     itk::simple::LabelImageToLabelMapFilter for the object oriented interface



    """
    return _SimpleITK.LabelImageToLabelMap(image1, backgroundValue)
class LabelIntensityStatisticsImageFilter(ImageFilter_0):
    """


    a convenient class to convert a label image to a label map and valuate
    the statistics attributes at once



    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     StatisticsLabelObject , LabelStatisticsOpeningImageFilter , LabelStatisticsOpeningImageFilter

     itk::LabelImageToStatisticsLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelIntensityStatisticsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelIntensityStatisticsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelIntensityStatisticsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelIntensityStatisticsImageFilter self) -> LabelIntensityStatisticsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelIntensityStatisticsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelIntensityStatisticsImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelIntensityStatisticsImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelIntensityStatisticsImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetBackgroundValue(self)


    def SetComputeFeretDiameter(self, ComputeFeretDiameter):
        """
        SetComputeFeretDiameter(LabelIntensityStatisticsImageFilter self, bool ComputeFeretDiameter)



        Set/Get whether the maximum Feret diameter should be computed or not.
        The defaut value is false, because of the high computation time
        required.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_SetComputeFeretDiameter(self, ComputeFeretDiameter)


    def ComputeFeretDiameterOn(self):
        """
        ComputeFeretDiameterOn(LabelIntensityStatisticsImageFilter self)



        Set the value of ComputeFeretDiameter to true or false respectfully.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_ComputeFeretDiameterOn(self)


    def ComputeFeretDiameterOff(self):
        """
        ComputeFeretDiameterOff(LabelIntensityStatisticsImageFilter self)



        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_ComputeFeretDiameterOff(self)


    def GetComputeFeretDiameter(self):
        """
        GetComputeFeretDiameter(LabelIntensityStatisticsImageFilter self) -> bool



        Set/Get whether the maximum Feret diameter should be computed or not.
        The defaut value is false, because of the high computation time
        required.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetComputeFeretDiameter(self)


    def SetComputePerimeter(self, ComputePerimeter):
        """
        SetComputePerimeter(LabelIntensityStatisticsImageFilter self, bool ComputePerimeter)



        Set/Get whether the perimeter should be computed or not. The defaut
        value is false, because of the high computation time required.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_SetComputePerimeter(self, ComputePerimeter)


    def ComputePerimeterOn(self):
        """
        ComputePerimeterOn(LabelIntensityStatisticsImageFilter self)



        Set the value of ComputePerimeter to true or false respectfully.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_ComputePerimeterOn(self)


    def ComputePerimeterOff(self):
        """
        ComputePerimeterOff(LabelIntensityStatisticsImageFilter self)



        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_ComputePerimeterOff(self)


    def GetComputePerimeter(self):
        """
        GetComputePerimeter(LabelIntensityStatisticsImageFilter self) -> bool



        Set/Get whether the perimeter should be computed or not. The defaut
        value is false, because of the high computation time required.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetComputePerimeter(self)


    def SetNumberOfBins(self, NumberOfBins):
        """
        SetNumberOfBins(LabelIntensityStatisticsImageFilter self, uint32_t NumberOfBins)



        Set/Get the number of bins in the histogram. Note that the histogram
        is used to compute the median value, and that this option may have an
        effect on the value of the median.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_SetNumberOfBins(self, NumberOfBins)


    def GetNumberOfBins(self):
        """
        GetNumberOfBins(LabelIntensityStatisticsImageFilter self) -> uint32_t



        Set/Get the number of bins in the histogram. Note that the histogram
        is used to compute the median value, and that this option may have an
        effect on the value of the median.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfBins(self)


    def GetBoundingBox(self, label):
        """
        GetBoundingBox(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetBoundingBox(self, label)


    def GetCentroid(self, label):
        """
        GetCentroid(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetCentroid(self, label)


    def GetElongation(self, label):
        """
        GetElongation(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetElongation(self, label)


    def GetEquivalentEllipsoidDiameter(self, label):
        """
        GetEquivalentEllipsoidDiameter(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetEquivalentEllipsoidDiameter(self, label)


    def GetEquivalentSphericalPerimeter(self, label):
        """
        GetEquivalentSphericalPerimeter(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetEquivalentSphericalPerimeter(self, label)


    def GetEquivalentSphericalRadius(self, label):
        """
        GetEquivalentSphericalRadius(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetEquivalentSphericalRadius(self, label)


    def GetFeretDiameter(self, label):
        """
        GetFeretDiameter(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetFeretDiameter(self, label)


    def GetFlatness(self, label):
        """
        GetFlatness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetFlatness(self, label)


    def GetLabels(self):
        """
        GetLabels(LabelIntensityStatisticsImageFilter self) -> VectorInt64



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetLabels(self)


    def GetNumberOfPixels(self, label):
        """
        GetNumberOfPixels(LabelIntensityStatisticsImageFilter self, int64_t label) -> uint64_t



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfPixels(self, label)


    def GetNumberOfPixelsOnBorder(self, label):
        """
        GetNumberOfPixelsOnBorder(LabelIntensityStatisticsImageFilter self, int64_t label) -> uint64_t



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfPixelsOnBorder(self, label)


    def GetPerimeter(self, label):
        """
        GetPerimeter(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPerimeter(self, label)


    def GetPerimeterOnBorder(self, label):
        """
        GetPerimeterOnBorder(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPerimeterOnBorder(self, label)


    def GetPerimeterOnBorderRatio(self, label):
        """
        GetPerimeterOnBorderRatio(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPerimeterOnBorderRatio(self, label)


    def GetPhysicalSize(self, label):
        """
        GetPhysicalSize(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPhysicalSize(self, label)


    def GetPrincipalAxes(self, label):
        """
        GetPrincipalAxes(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPrincipalAxes(self, label)


    def GetPrincipalMoments(self, label):
        """
        GetPrincipalMoments(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetPrincipalMoments(self, label)


    def GetRoundness(self, label):
        """
        GetRoundness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetRoundness(self, label)


    def GetCenterOfGravity(self, label):
        """
        GetCenterOfGravity(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetCenterOfGravity(self, label)


    def GetKurtosis(self, label):
        """
        GetKurtosis(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetKurtosis(self, label)


    def GetMaximum(self, label):
        """
        GetMaximum(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMaximum(self, label)


    def GetMaximumIndex(self, label):
        """
        GetMaximumIndex(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMaximumIndex(self, label)


    def GetMean(self, label):
        """
        GetMean(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMean(self, label)


    def GetMedian(self, label):
        """
        GetMedian(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMedian(self, label)


    def GetMinimum(self, label):
        """
        GetMinimum(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMinimum(self, label)


    def GetMinimumIndex(self, label):
        """
        GetMinimumIndex(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorUInt32



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetMinimumIndex(self, label)


    def GetSkewness(self, label):
        """
        GetSkewness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetSkewness(self, label)


    def GetStandardDeviation(self, label):
        """
        GetStandardDeviation(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetStandardDeviation(self, label)


    def GetSum(self, label):
        """
        GetSum(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetSum(self, label)


    def GetVariance(self, label):
        """
        GetVariance(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetVariance(self, label)


    def GetWeightedElongation(self, label):
        """
        GetWeightedElongation(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedElongation(self, label)


    def GetWeightedFlatness(self, label):
        """
        GetWeightedFlatness(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedFlatness(self, label)


    def GetWeightedPrincipalAxes(self, label):
        """
        GetWeightedPrincipalAxes(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedPrincipalAxes(self, label)


    def GetWeightedPrincipalMoments(self, label):
        """
        GetWeightedPrincipalMoments(LabelIntensityStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetWeightedPrincipalMoments(self, label)


    def GetName(self):
        """
        GetName(LabelIntensityStatisticsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelIntensityStatisticsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelIntensityStatisticsImageFilter self, Image image, Image featureImage)
        Execute(LabelIntensityStatisticsImageFilter self, Image image, Image featureImage, double backgroundValue, bool computeFeretDiameter, bool computePerimeter, uint32_t numberOfBins)



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_Execute(self, *args)


    def HasLabel(self, label):
        """
        HasLabel(LabelIntensityStatisticsImageFilter self, int64_t label) -> double



        Does the specified label exist? Can only be called after a call a call
        to Update().


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_HasLabel(self, label)


    def GetNumberOfLabels(self):
        """
        GetNumberOfLabels(LabelIntensityStatisticsImageFilter self) -> uint64_t



        Return the number of labels after execution.


        """
        return _SimpleITK.LabelIntensityStatisticsImageFilter_GetNumberOfLabels(self)

LabelIntensityStatisticsImageFilter_swigregister = _SimpleITK.LabelIntensityStatisticsImageFilter_swigregister
LabelIntensityStatisticsImageFilter_swigregister(LabelIntensityStatisticsImageFilter)

class LabelMapContourOverlayImageFilter(ImageFilter_0):
    """


    Apply a colormap to the contours (outlines) of each object in a label
    map and superimpose it on top of the feature image.


    The feature image is typically the image from which the labeling was
    produced. Use the SetInput function to set the LabelMap , and the SetFeatureImage function to set the feature image.

    Apply a colormap to a label map and put it on top of the input image.
    The set of colors is a good selection of distinct colors. The opacity
    of the label map can be defined by the user. A background label
    produce a gray pixel with the same intensity than the input one.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     LabelMapOverlayImageFilter , LabelOverlayImageFilter , LabelOverlayFunctor

     LabelMapToBinaryImageFilter , LabelMapToLabelImageFilter ,
    Wiki Examples:

    All Examples

    Color the boundaries of labeled regions in an image
    See:
     itk::simple::LabelMapContourOverlay for the procedural interface

     itk::LabelMapContourOverlayImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLabelMapContourOverlayImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelMapContourOverlayImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelMapContourOverlayImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelMapContourOverlayImageFilter self) -> LabelMapContourOverlayImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelMapContourOverlayImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelMapContourOverlayImageFilter
    __del__ = lambda self: None

    def SetOpacity(self, Opacity):
        """
        SetOpacity(LabelMapContourOverlayImageFilter self, double Opacity)



        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetOpacity(self, Opacity)


    def GetOpacity(self):
        """
        GetOpacity(LabelMapContourOverlayImageFilter self) -> double



        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetOpacity(self)


    def SetDilationRadius(self, *args):
        """
        SetDilationRadius(LabelMapContourOverlayImageFilter self, VectorUInt32 DilationRadius)
        SetDilationRadius(LabelMapContourOverlayImageFilter self, unsigned int value)



        Set the values of the DilationRadius vector all to value


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetDilationRadius(self, *args)


    def GetDilationRadius(self):
        """
        GetDilationRadius(LabelMapContourOverlayImageFilter self) -> VectorUInt32



        Set/Get the object dilation radius - 0 by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetDilationRadius(self)


    def SetContourThickness(self, ContourThickness):
        """
        SetContourThickness(LabelMapContourOverlayImageFilter self, VectorUInt32 ContourThickness)



        Set/Get the contour thickness - 1 by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetContourThickness(self, ContourThickness)


    def GetContourThickness(self):
        """
        GetContourThickness(LabelMapContourOverlayImageFilter self) -> VectorUInt32



        Set/Get the contour thickness - 1 by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetContourThickness(self)


    def SetSliceDimension(self, SliceDimension):
        """
        SetSliceDimension(LabelMapContourOverlayImageFilter self, unsigned int SliceDimension)



        Set/Get the slice dimension - defaults to image dimension - 1.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetSliceDimension(self, SliceDimension)


    def GetSliceDimension(self):
        """
        GetSliceDimension(LabelMapContourOverlayImageFilter self) -> unsigned int



        Set/Get the slice dimension - defaults to image dimension - 1.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetSliceDimension(self)

    PLAIN = _SimpleITK.LabelMapContourOverlayImageFilter_PLAIN
    CONTOUR = _SimpleITK.LabelMapContourOverlayImageFilter_CONTOUR
    SLICE_CONTOUR = _SimpleITK.LabelMapContourOverlayImageFilter_SLICE_CONTOUR

    def SetContourType(self, ContourType):
        """
        SetContourType(LabelMapContourOverlayImageFilter self, itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType ContourType)



        Set/Get the overlay type - CONTOUR is used by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetContourType(self, ContourType)


    def GetContourType(self):
        """
        GetContourType(LabelMapContourOverlayImageFilter self) -> itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType



        Set/Get the overlay type - CONTOUR is used by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetContourType(self)

    HIGH_LABEL_ON_TOP = _SimpleITK.LabelMapContourOverlayImageFilter_HIGH_LABEL_ON_TOP
    LOW_LABEL_ON_TOP = _SimpleITK.LabelMapContourOverlayImageFilter_LOW_LABEL_ON_TOP

    def SetPriority(self, Priority):
        """
        SetPriority(LabelMapContourOverlayImageFilter self, itk::simple::LabelMapContourOverlayImageFilter::PriorityType Priority)



        Set/Get the object priority - HIGH_LABEL_ON_TOP by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetPriority(self, Priority)


    def GetPriority(self):
        """
        GetPriority(LabelMapContourOverlayImageFilter self) -> itk::simple::LabelMapContourOverlayImageFilter::PriorityType



        Set/Get the object priority - HIGH_LABEL_ON_TOP by default.


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetPriority(self)


    def SetColormap(self, Colormap):
        """
        SetColormap(LabelMapContourOverlayImageFilter self, VectorUInt8 Colormap)



        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_SetColormap(self, Colormap)


    def GetColormap(self):
        """
        GetColormap(LabelMapContourOverlayImageFilter self) -> VectorUInt8



        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetColormap(self)


    def GetName(self):
        """
        GetName(LabelMapContourOverlayImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelMapContourOverlayImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelMapContourOverlayImageFilter self, Image labelMapImage, Image featureImage) -> Image
        Execute(LabelMapContourOverlayImageFilter self, Image labelMapImage, Image featureImage, double opacity, VectorUInt32 dilationRadius, VectorUInt32 contourThickness, unsigned int sliceDimension, itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType contourType, itk::simple::LabelMapContourOverlayImageFilter::PriorityType priority, VectorUInt8 colormap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelMapContourOverlayImageFilter_Execute(self, *args)

LabelMapContourOverlayImageFilter_swigregister = _SimpleITK.LabelMapContourOverlayImageFilter_swigregister
LabelMapContourOverlayImageFilter_swigregister(LabelMapContourOverlayImageFilter)


def LabelMapContourOverlay(*args, **kwargs):
    """
    LabelMapContourOverlay(Image labelMapImage, Image featureImage, double opacity=0.5, VectorUInt32 dilationRadius, VectorUInt32 contourThickness, unsigned int sliceDimension=0, itk::simple::LabelMapContourOverlayImageFilter::ContourTypeType contourType, itk::simple::LabelMapContourOverlayImageFilter::PriorityType priority, VectorUInt8 colormap) -> Image



    Apply a colormap to the contours (outlines) of each object in a label
    map and superimpose it on top of the feature image.


    This function directly calls the execute method of LabelMapContourOverlayImageFilter in order to support a procedural API


    See:
     itk::simple::LabelMapContourOverlayImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelMapContourOverlay(*args, **kwargs)
class LabelMapMaskImageFilter(ImageFilter_0):
    """


    Mask and image with a LabelMap .


    LabelMapMaskImageFilter mask the content of an input image according to the content of the
    input LabelMap . The masked pixel of the input image are set to the BackgroundValue. LabelMapMaskImageFilter can keep the input image for one label only, with Negated = false
    (the default) or it can mask the input image for a single label, when
    Negated equals true. In Both cases, the label is set with SetLabel() .


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     LabelMapToBinaryImageFilter , LabelMapToLabelImageFilter

     itk::simple::LabelMapMask for the procedural interface

     itk::LabelMapMaskImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapMaskImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelMapMaskImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelMapMaskImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelMapMaskImageFilter self) -> LabelMapMaskImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelMapMaskImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelMapMaskImageFilter
    __del__ = lambda self: None

    def SetLabel(self, Label):
        """
        SetLabel(LabelMapMaskImageFilter self, uint64_t Label)



        The label to mask or to not mask, depending on the value of the
        Negated ivar.


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetLabel(self, Label)


    def GetLabel(self):
        """
        GetLabel(LabelMapMaskImageFilter self) -> uint64_t



        The label to mask or to not mask, depending on the value of the
        Negated ivar.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetLabel(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelMapMaskImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::ZeroValue() .


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelMapMaskImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::ZeroValue() .


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetBackgroundValue(self)


    def SetNegated(self, Negated):
        """
        SetNegated(LabelMapMaskImageFilter self, bool Negated)



        Set/Get whether the Label should be masked or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetNegated(self, Negated)


    def NegatedOn(self):
        """
        NegatedOn(LabelMapMaskImageFilter self)



        Set the value of Negated to true or false respectfully.


        """
        return _SimpleITK.LabelMapMaskImageFilter_NegatedOn(self)


    def NegatedOff(self):
        """
        NegatedOff(LabelMapMaskImageFilter self)



        """
        return _SimpleITK.LabelMapMaskImageFilter_NegatedOff(self)


    def GetNegated(self):
        """
        GetNegated(LabelMapMaskImageFilter self) -> bool



        Set/Get whether the Label should be masked or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetNegated(self)


    def SetCrop(self, Crop):
        """
        SetCrop(LabelMapMaskImageFilter self, bool Crop)



        Set/Get whether the image size should be adjusted to the masked image
        or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetCrop(self, Crop)


    def CropOn(self):
        """
        CropOn(LabelMapMaskImageFilter self)



        Set the value of Crop to true or false respectfully.


        """
        return _SimpleITK.LabelMapMaskImageFilter_CropOn(self)


    def CropOff(self):
        """
        CropOff(LabelMapMaskImageFilter self)



        """
        return _SimpleITK.LabelMapMaskImageFilter_CropOff(self)


    def GetCrop(self):
        """
        GetCrop(LabelMapMaskImageFilter self) -> bool



        Set/Get whether the image size should be adjusted to the masked image
        or not.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetCrop(self)


    def SetCropBorder(self, *args):
        """
        SetCropBorder(LabelMapMaskImageFilter self, VectorUInt32 CropBorder)
        SetCropBorder(LabelMapMaskImageFilter self, unsigned int value)



        Set the values of the CropBorder vector all to value


        """
        return _SimpleITK.LabelMapMaskImageFilter_SetCropBorder(self, *args)


    def GetCropBorder(self):
        """
        GetCropBorder(LabelMapMaskImageFilter self) -> VectorUInt32



        Set/Get the boder added to the mask before the crop. The default is 0
        on all the axes.


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetCropBorder(self)


    def GetName(self):
        """
        GetName(LabelMapMaskImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelMapMaskImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelMapMaskImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelMapMaskImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelMapMaskImageFilter self, Image labelMapImage, Image featureImage) -> Image
        Execute(LabelMapMaskImageFilter self, Image labelMapImage, Image featureImage, uint64_t label, double backgroundValue, bool negated, bool crop, VectorUInt32 cropBorder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelMapMaskImageFilter_Execute(self, *args)

LabelMapMaskImageFilter_swigregister = _SimpleITK.LabelMapMaskImageFilter_swigregister
LabelMapMaskImageFilter_swigregister(LabelMapMaskImageFilter)


def LabelMapMask(*args, **kwargs):
    """
    LabelMapMask(Image labelMapImage, Image featureImage, uint64_t label=1, double backgroundValue=0, bool negated=False, bool crop=False, VectorUInt32 cropBorder) -> Image



    Mask and image with a LabelMap .


    This function directly calls the execute method of LabelMapMaskImageFilter in order to support a procedural API


    See:
     itk::simple::LabelMapMaskImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelMapMask(*args, **kwargs)
class LabelMapOverlayImageFilter(ImageFilter_0):
    """


    Apply a colormap to a label map and superimpose it on an image.


    Apply a colormap to a label map and put it on top of the feature
    image. The feature image is typically the image from which the
    labeling was produced. Use the SetInput function to set the LabelMap , and the SetFeatureImage function to set the feature image.

    The set of colors is a good selection of distinct colors. The opacity
    of the label map can be defined by the user. A background label
    produce a gray pixel with the same intensity than the input one.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     LabelOverlayImageFilter , LabelOverlayFunctor

     LabelMapToRGBImageFilter , LabelMapToBinaryImageFilter , LabelMapToLabelImageFilter

     itk::simple::LabelMapOverlay for the procedural interface

     itk::LabelMapOverlayImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapOverlayImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelMapOverlayImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelMapOverlayImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelMapOverlayImageFilter self) -> LabelMapOverlayImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelMapOverlayImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelMapOverlayImageFilter
    __del__ = lambda self: None

    def SetOpacity(self, Opacity):
        """
        SetOpacity(LabelMapOverlayImageFilter self, double Opacity)



        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapOverlayImageFilter_SetOpacity(self, Opacity)


    def GetOpacity(self):
        """
        GetOpacity(LabelMapOverlayImageFilter self) -> double



        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelMapOverlayImageFilter_GetOpacity(self)


    def SetColormap(self, Colormap):
        """
        SetColormap(LabelMapOverlayImageFilter self, VectorUInt8 Colormap)



        """
        return _SimpleITK.LabelMapOverlayImageFilter_SetColormap(self, Colormap)


    def GetColormap(self):
        """
        GetColormap(LabelMapOverlayImageFilter self) -> VectorUInt8



        """
        return _SimpleITK.LabelMapOverlayImageFilter_GetColormap(self)


    def GetName(self):
        """
        GetName(LabelMapOverlayImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelMapOverlayImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelMapOverlayImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelMapOverlayImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelMapOverlayImageFilter self, Image labelMapImage, Image featureImage) -> Image
        Execute(LabelMapOverlayImageFilter self, Image labelMapImage, Image featureImage, double opacity, VectorUInt8 colormap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelMapOverlayImageFilter_Execute(self, *args)

LabelMapOverlayImageFilter_swigregister = _SimpleITK.LabelMapOverlayImageFilter_swigregister
LabelMapOverlayImageFilter_swigregister(LabelMapOverlayImageFilter)


def LabelMapOverlay(*args, **kwargs):
    """
    LabelMapOverlay(Image labelMapImage, Image featureImage, double opacity=0.5, VectorUInt8 colormap) -> Image



    Apply a colormap to a label map and superimpose it on an image.


    This function directly calls the execute method of LabelMapOverlayImageFilter in order to support a procedural API


    See:
     itk::simple::LabelMapOverlayImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelMapOverlay(*args, **kwargs)
class LabelMapToBinaryImageFilter(ImageFilter_1):
    """


    Convert a LabelMap to a binary image.


    LabelMapToBinaryImageFilter to a binary image. All the objects in the image are used as
    foreground. The background values of the original binary image can be
    restored by passing this image to the filter with the
    SetBackgroundImage() method.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     LabelMapToLabelImageFilter , LabelMapMaskImageFilter

     itk::simple::LabelMapToBinary for the procedural interface

     itk::LabelMapToBinaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapToBinaryImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelMapToBinaryImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelMapToBinaryImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelMapToBinaryImageFilter self) -> LabelMapToBinaryImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelMapToBinaryImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelMapToBinaryImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelMapToBinaryImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelMapToBinaryImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(LabelMapToBinaryImageFilter self, double ForegroundValue)



        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(LabelMapToBinaryImageFilter self) -> double



        Set/Get the value used as "foreground" in the output image. Defaults
        to NumericTraits<PixelType>::max() .


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(LabelMapToBinaryImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelMapToBinaryImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelMapToBinaryImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelMapToBinaryImageFilter self, Image image1) -> Image
        Execute(LabelMapToBinaryImageFilter self, Image image1, double backgroundValue, double foregroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelMapToBinaryImageFilter_Execute(self, *args)

LabelMapToBinaryImageFilter_swigregister = _SimpleITK.LabelMapToBinaryImageFilter_swigregister
LabelMapToBinaryImageFilter_swigregister(LabelMapToBinaryImageFilter)


def LabelMapToBinary(image1, backgroundValue=0, foregroundValue=1.0):
    """
    LabelMapToBinary(Image image1, double backgroundValue=0, double foregroundValue=1.0) -> Image



    Convert a LabelMap to a binary image.


    This function directly calls the execute method of LabelMapToBinaryImageFilter in order to support a procedural API


    See:
     itk::simple::LabelMapToBinaryImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelMapToBinary(image1, backgroundValue, foregroundValue)
class LabelMapToLabelImageFilter(ImageFilter_1):
    """


    Converts a LabelMap to a labeled image.


    LabelMapToBinaryImageFilter to a label image.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     LabelMapToBinaryImageFilter , LabelMapMaskImageFilter
    Wiki Examples:

    All Examples

    Convert a LabelMap to a normal image with different values representing each region
    See:
     itk::simple::LabelMapToLabel for the procedural interface

     itk::LabelMapToLabelImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLabelMapToLabelImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelMapToLabelImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelMapToLabelImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelMapToLabelImageFilter self) -> LabelMapToLabelImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelMapToLabelImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelMapToLabelImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(LabelMapToLabelImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelMapToLabelImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelMapToLabelImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelMapToLabelImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(LabelMapToLabelImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.LabelMapToLabelImageFilter_Execute(self, image1)

LabelMapToLabelImageFilter_swigregister = _SimpleITK.LabelMapToLabelImageFilter_swigregister
LabelMapToLabelImageFilter_swigregister(LabelMapToLabelImageFilter)


def LabelMapToLabel(image1):
    """
    LabelMapToLabel(Image image1) -> Image



    Converts a LabelMap to a labeled image.


    This function directly calls the execute method of LabelMapToLabelImageFilter in order to support a procedural API


    See:
     itk::simple::LabelMapToLabelImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelMapToLabel(image1)
class LabelMapToRGBImageFilter(ImageFilter_1):
    """


    Convert a LabelMap to a colored image.



    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     LabelToRGBImageFilter , LabelToRGBFunctor

     LabelMapOverlayImageFilter , LabelMapToBinaryImageFilter , LabelMapMaskImageFilter

     itk::simple::LabelMapToRGB for the procedural interface

     itk::LabelMapToRGBImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelMapToRGBImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelMapToRGBImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelMapToRGBImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelMapToRGBImageFilter self) -> LabelMapToRGBImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelMapToRGBImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelMapToRGBImageFilter
    __del__ = lambda self: None

    def SetColormap(self, Colormap):
        """
        SetColormap(LabelMapToRGBImageFilter self, VectorUInt8 Colormap)



        """
        return _SimpleITK.LabelMapToRGBImageFilter_SetColormap(self, Colormap)


    def GetColormap(self):
        """
        GetColormap(LabelMapToRGBImageFilter self) -> VectorUInt8



        """
        return _SimpleITK.LabelMapToRGBImageFilter_GetColormap(self)


    def GetName(self):
        """
        GetName(LabelMapToRGBImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelMapToRGBImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelMapToRGBImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelMapToRGBImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelMapToRGBImageFilter self, Image image1) -> Image
        Execute(LabelMapToRGBImageFilter self, Image image1, VectorUInt8 colormap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelMapToRGBImageFilter_Execute(self, *args)

LabelMapToRGBImageFilter_swigregister = _SimpleITK.LabelMapToRGBImageFilter_swigregister
LabelMapToRGBImageFilter_swigregister(LabelMapToRGBImageFilter)


def LabelMapToRGB(*args, **kwargs):
    """
    LabelMapToRGB(Image image1, VectorUInt8 colormap) -> Image



    Convert a LabelMap to a colored image.


    This function directly calls the execute method of LabelMapToRGBImageFilter in order to support a procedural API


    See:
     itk::simple::LabelMapToRGBImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelMapToRGB(*args, **kwargs)
class LabelOverlapMeasuresImageFilter(ImageFilter_2):
    """


    Computes overlap measures between the set same set of labels of pixels
    of two images. Background is assumed to be 0.


    This code was contributed in the Insight Journal paper: "Introducing
    Dice, Jaccard, and Other Label Overlap Measures To ITK" by Nicholas
    J. Tustison, James C. Gee https://hdl.handle.net/10380/3141 http://www.insight-journal.org/browse/publication/707


    Nicholas J. Tustison

    See:
     LabelOverlapMeasuresImageFilter

     itk::LabelOverlapMeasuresImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelOverlapMeasuresImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelOverlapMeasuresImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelOverlapMeasuresImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelOverlapMeasuresImageFilter self) -> LabelOverlapMeasuresImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelOverlapMeasuresImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelOverlapMeasuresImageFilter
    __del__ = lambda self: None

    def GetFalseNegativeError(self):
        """
        GetFalseNegativeError(LabelOverlapMeasuresImageFilter self) -> double



        Get the false negative error for the specified individual label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetFalseNegativeError(self)


    def GetFalsePositiveError(self):
        """
        GetFalsePositiveError(LabelOverlapMeasuresImageFilter self) -> double



        Get the false positive error for the specified individual label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetFalsePositiveError(self)


    def GetMeanOverlap(self):
        """
        GetMeanOverlap(LabelOverlapMeasuresImageFilter self) -> double



        Get the mean overlap (Dice coefficient) for the specified individual
        label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetMeanOverlap(self)


    def GetUnionOverlap(self):
        """
        GetUnionOverlap(LabelOverlapMeasuresImageFilter self) -> double



        Get the union overlap (Jaccard coefficient) for the specified
        individual label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetUnionOverlap(self)


    def GetVolumeSimilarity(self):
        """
        GetVolumeSimilarity(LabelOverlapMeasuresImageFilter self) -> double



        Get the volume similarity for the specified individual label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetVolumeSimilarity(self)


    def GetJaccardCoefficient(self):
        """
        GetJaccardCoefficient(LabelOverlapMeasuresImageFilter self) -> double



        Get the union overlap (Jaccard coefficient) for the specified
        individual label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetJaccardCoefficient(self)


    def GetDiceCoefficient(self):
        """
        GetDiceCoefficient(LabelOverlapMeasuresImageFilter self) -> double



        Get the mean overlap (Dice coefficient) for the specified individual
        label.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetDiceCoefficient(self)


    def GetName(self):
        """
        GetName(LabelOverlapMeasuresImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelOverlapMeasuresImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter___str__(self)


    def Execute(self, image1, image2):
        """
        Execute(LabelOverlapMeasuresImageFilter self, Image image1, Image image2)



        Execute the filter on the input images


        """
        return _SimpleITK.LabelOverlapMeasuresImageFilter_Execute(self, image1, image2)

LabelOverlapMeasuresImageFilter_swigregister = _SimpleITK.LabelOverlapMeasuresImageFilter_swigregister
LabelOverlapMeasuresImageFilter_swigregister(LabelOverlapMeasuresImageFilter)

class LabelOverlayImageFilter(ImageFilter_0):
    """


    Apply a colormap to a label image and put it on top of the input
    image.


    Apply a colormap to a label image and put it on top of the input
    image. The set of colors is a good selection of distinct colors. The
    opacity of the label image can be defined by the user. The user can
    also choose if the want to use a background and which label value is
    the background. A background label produce a gray pixel with the same
    intensity than the input one.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This class was contributed to the Insight Journal https://hdl.handle.net/1926/172


    See:
     LabelToRGBImageFilter

     LabelMapOverlayImageFilter , LabelOverlayFunctor
    Wiki Examples:

    All Examples

    Overlay a LabelMap on an image
    See:
     itk::simple::LabelOverlay for the procedural interface

     itk::LabelOverlayImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLabelOverlayImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelOverlayImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelOverlayImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelOverlayImageFilter self) -> LabelOverlayImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelOverlayImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelOverlayImageFilter
    __del__ = lambda self: None

    def SetOpacity(self, Opacity):
        """
        SetOpacity(LabelOverlayImageFilter self, double Opacity)



        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelOverlayImageFilter_SetOpacity(self, Opacity)


    def GetOpacity(self):
        """
        GetOpacity(LabelOverlayImageFilter self) -> double



        Set/Get the opacity of the colored label image. The value must be
        between 0 and 1


        """
        return _SimpleITK.LabelOverlayImageFilter_GetOpacity(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelOverlayImageFilter self, double BackgroundValue)



        Set/Get the background value


        """
        return _SimpleITK.LabelOverlayImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelOverlayImageFilter self) -> double



        Set/Get the background value


        """
        return _SimpleITK.LabelOverlayImageFilter_GetBackgroundValue(self)


    def SetColormap(self, Colormap):
        """
        SetColormap(LabelOverlayImageFilter self, VectorUInt8 Colormap)



        """
        return _SimpleITK.LabelOverlayImageFilter_SetColormap(self, Colormap)


    def GetColormap(self):
        """
        GetColormap(LabelOverlayImageFilter self) -> VectorUInt8



        """
        return _SimpleITK.LabelOverlayImageFilter_GetColormap(self)


    def GetName(self):
        """
        GetName(LabelOverlayImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelOverlayImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelOverlayImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelOverlayImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelOverlayImageFilter self, Image image, Image labelImage) -> Image
        Execute(LabelOverlayImageFilter self, Image image, Image labelImage, double opacity, double backgroundValue, VectorUInt8 colormap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelOverlayImageFilter_Execute(self, *args)

LabelOverlayImageFilter_swigregister = _SimpleITK.LabelOverlayImageFilter_swigregister
LabelOverlayImageFilter_swigregister(LabelOverlayImageFilter)


def LabelOverlay(*args, **kwargs):
    """
    LabelOverlay(Image image, Image labelImage, double opacity=0.5, double backgroundValue=0.0, VectorUInt8 colormap) -> Image



    Apply a colormap to a label image and put it on top of the input
    image.


    This function directly calls the execute method of LabelOverlayImageFilter in order to support a procedural API


    See:
     itk::simple::LabelOverlayImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelOverlay(*args, **kwargs)
class LabelShapeStatisticsImageFilter(ImageFilter_1):
    """


    Converts a label image to a label map and valuates the shape
    attributes.


    A convenient class that converts a label image to a label map and
    valuates the shape attribute at once.

    This implementation was taken from the Insight Journal paper:

    https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , LabelShapeOpeningImageFilter , LabelStatisticsOpeningImageFilter
    Wiki Examples:

    All Examples

    Convert an itk::Image consisting of labeled regions to a ShapeLabelMap

    See:
     itk::LabelImageToShapeLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelShapeStatisticsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelShapeStatisticsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelShapeStatisticsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelShapeStatisticsImageFilter self) -> LabelShapeStatisticsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelShapeStatisticsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelShapeStatisticsImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelShapeStatisticsImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelShapeStatisticsImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetBackgroundValue(self)


    def SetComputeFeretDiameter(self, ComputeFeretDiameter):
        """
        SetComputeFeretDiameter(LabelShapeStatisticsImageFilter self, bool ComputeFeretDiameter)



        Set/Get whether the maximum Feret diameter should be computed or not.
        Default value is false, because of the high computation time required.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_SetComputeFeretDiameter(self, ComputeFeretDiameter)


    def ComputeFeretDiameterOn(self):
        """
        ComputeFeretDiameterOn(LabelShapeStatisticsImageFilter self)



        Set the value of ComputeFeretDiameter to true or false respectfully.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputeFeretDiameterOn(self)


    def ComputeFeretDiameterOff(self):
        """
        ComputeFeretDiameterOff(LabelShapeStatisticsImageFilter self)



        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputeFeretDiameterOff(self)


    def GetComputeFeretDiameter(self):
        """
        GetComputeFeretDiameter(LabelShapeStatisticsImageFilter self) -> bool



        Set/Get whether the maximum Feret diameter should be computed or not.
        Default value is false, because of the high computation time required.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetComputeFeretDiameter(self)


    def SetComputePerimeter(self, ComputePerimeter):
        """
        SetComputePerimeter(LabelShapeStatisticsImageFilter self, bool ComputePerimeter)



        Set/Get whether the perimeter should be computed or not. Default value
        is false, because of the high computation time required.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_SetComputePerimeter(self, ComputePerimeter)


    def ComputePerimeterOn(self):
        """
        ComputePerimeterOn(LabelShapeStatisticsImageFilter self)



        Set the value of ComputePerimeter to true or false respectfully.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputePerimeterOn(self)


    def ComputePerimeterOff(self):
        """
        ComputePerimeterOff(LabelShapeStatisticsImageFilter self)



        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_ComputePerimeterOff(self)


    def GetComputePerimeter(self):
        """
        GetComputePerimeter(LabelShapeStatisticsImageFilter self) -> bool



        Set/Get whether the perimeter should be computed or not. Default value
        is false, because of the high computation time required.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetComputePerimeter(self)


    def GetBoundingBox(self, label):
        """
        GetBoundingBox(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorUInt32



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetBoundingBox(self, label)


    def GetCentroid(self, label):
        """
        GetCentroid(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetCentroid(self, label)


    def GetElongation(self, label):
        """
        GetElongation(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetElongation(self, label)


    def GetEquivalentEllipsoidDiameter(self, label):
        """
        GetEquivalentEllipsoidDiameter(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetEquivalentEllipsoidDiameter(self, label)


    def GetEquivalentSphericalPerimeter(self, label):
        """
        GetEquivalentSphericalPerimeter(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetEquivalentSphericalPerimeter(self, label)


    def GetEquivalentSphericalRadius(self, label):
        """
        GetEquivalentSphericalRadius(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetEquivalentSphericalRadius(self, label)


    def GetFeretDiameter(self, label):
        """
        GetFeretDiameter(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetFeretDiameter(self, label)


    def GetFlatness(self, label):
        """
        GetFlatness(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetFlatness(self, label)


    def GetLabels(self):
        """
        GetLabels(LabelShapeStatisticsImageFilter self) -> VectorInt64



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetLabels(self)


    def GetNumberOfPixels(self, label):
        """
        GetNumberOfPixels(LabelShapeStatisticsImageFilter self, int64_t label) -> uint64_t



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetNumberOfPixels(self, label)


    def GetNumberOfPixelsOnBorder(self, label):
        """
        GetNumberOfPixelsOnBorder(LabelShapeStatisticsImageFilter self, int64_t label) -> uint64_t



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetNumberOfPixelsOnBorder(self, label)


    def GetPerimeter(self, label):
        """
        GetPerimeter(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPerimeter(self, label)


    def GetPerimeterOnBorder(self, label):
        """
        GetPerimeterOnBorder(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPerimeterOnBorder(self, label)


    def GetPerimeterOnBorderRatio(self, label):
        """
        GetPerimeterOnBorderRatio(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPerimeterOnBorderRatio(self, label)


    def GetPhysicalSize(self, label):
        """
        GetPhysicalSize(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPhysicalSize(self, label)


    def GetPrincipalAxes(self, label):
        """
        GetPrincipalAxes(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPrincipalAxes(self, label)


    def GetPrincipalMoments(self, label):
        """
        GetPrincipalMoments(LabelShapeStatisticsImageFilter self, int64_t label) -> VectorDouble



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetPrincipalMoments(self, label)


    def GetRoundness(self, label):
        """
        GetRoundness(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetRoundness(self, label)


    def GetName(self):
        """
        GetName(LabelShapeStatisticsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelShapeStatisticsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelShapeStatisticsImageFilter self, Image image1)
        Execute(LabelShapeStatisticsImageFilter self, Image image1, double backgroundValue, bool computeFeretDiameter, bool computePerimeter)



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_Execute(self, *args)


    def HasLabel(self, label):
        """
        HasLabel(LabelShapeStatisticsImageFilter self, int64_t label) -> double



        Does the specified label exist? Can only be called after a call a call
        to Update().


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_HasLabel(self, label)


    def GetNumberOfLabels(self):
        """
        GetNumberOfLabels(LabelShapeStatisticsImageFilter self) -> uint64_t



        Return the number of labels after execution.


        """
        return _SimpleITK.LabelShapeStatisticsImageFilter_GetNumberOfLabels(self)

LabelShapeStatisticsImageFilter_swigregister = _SimpleITK.LabelShapeStatisticsImageFilter_swigregister
LabelShapeStatisticsImageFilter_swigregister(LabelShapeStatisticsImageFilter)

class LabelStatisticsImageFilter(ImageFilter_0):
    """


    Given an intensity image and a label map, compute min, max, variance
    and mean of the pixels associated with each label or segment.


    LabelStatisticsImageFilter computes the minimum, maximum, sum, mean, median, variance and sigma
    of regions of an intensity image, where the regions are defined via a
    label map (a second input). The label image should be integral type.
    The filter needs all of its input image. It behaves as a filter with
    an input and output. Thus it can be inserted in a pipline with other
    filters and the statistics will only be recomputed if a downstream
    filter changes.

    Optionally, the filter also computes intensity histograms on each
    object. If histograms are enabled, a median intensity value can also
    be computed, although its accuracy is limited to the bin width of the
    histogram. If histograms are not enabled, the median returns zero.

    The filter passes its intensity input through unmodified. The filter
    is threaded. It computes statistics in each thread then combines them
    in its AfterThreadedGenerate method.

    Wiki Examples:

    All Examples

    Get statistical properties of labeled regions in an image

    See:
     itk::LabelStatisticsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelStatisticsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelStatisticsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelStatisticsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelStatisticsImageFilter self) -> LabelStatisticsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelStatisticsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelStatisticsImageFilter
    __del__ = lambda self: None

    def SetUseHistograms(self, UseHistograms):
        """
        SetUseHistograms(LabelStatisticsImageFilter self, bool UseHistograms)



        """
        return _SimpleITK.LabelStatisticsImageFilter_SetUseHistograms(self, UseHistograms)


    def UseHistogramsOn(self):
        """
        UseHistogramsOn(LabelStatisticsImageFilter self)



        Set the value of UseHistograms to true or false respectfully.


        """
        return _SimpleITK.LabelStatisticsImageFilter_UseHistogramsOn(self)


    def UseHistogramsOff(self):
        """
        UseHistogramsOff(LabelStatisticsImageFilter self)



        """
        return _SimpleITK.LabelStatisticsImageFilter_UseHistogramsOff(self)


    def GetUseHistograms(self):
        """
        GetUseHistograms(LabelStatisticsImageFilter self) -> bool



        """
        return _SimpleITK.LabelStatisticsImageFilter_GetUseHistograms(self)


    def GetMinimum(self, label):
        """
        GetMinimum(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the computed Minimum for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMinimum(self, label)


    def GetMaximum(self, label):
        """
        GetMaximum(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the computed Maximum for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMaximum(self, label)


    def GetMean(self, label):
        """
        GetMean(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the computed Mean for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMean(self, label)


    def GetMedian(self, label):
        """
        GetMedian(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the computed Median for a label. Requires histograms to be
        enabled!

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetMedian(self, label)


    def GetSigma(self, label):
        """
        GetSigma(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the computed Standard Deviation for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetSigma(self, label)


    def GetVariance(self, label):
        """
        GetVariance(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the computed Variance for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetVariance(self, label)


    def GetSum(self, label):
        """
        GetSum(LabelStatisticsImageFilter self, int64_t label) -> double



        Return the compute Sum for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetSum(self, label)


    def GetCount(self, label):
        """
        GetCount(LabelStatisticsImageFilter self, int64_t label) -> uint64_t



        Return the number of pixels for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetCount(self, label)


    def GetBoundingBox(self, label):
        """
        GetBoundingBox(LabelStatisticsImageFilter self, int64_t label) -> VectorInt32



        Return the computed bounding box for a label.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetBoundingBox(self, label)


    def GetLabels(self):
        """
        GetLabels(LabelStatisticsImageFilter self) -> VectorInt64



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetLabels(self)


    def GetName(self):
        """
        GetName(LabelStatisticsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelStatisticsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelStatisticsImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelStatisticsImageFilter self, Image image, Image labelImage)
        Execute(LabelStatisticsImageFilter self, Image image, Image labelImage, bool useHistograms)



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelStatisticsImageFilter_Execute(self, *args)


    def HasLabel(self, label):
        """
        HasLabel(LabelStatisticsImageFilter self, int64_t label) -> double



        Does the specified label exist? Can only be called after a call a call
        to Update().


        """
        return _SimpleITK.LabelStatisticsImageFilter_HasLabel(self, label)


    def GetNumberOfLabels(self):
        """
        GetNumberOfLabels(LabelStatisticsImageFilter self) -> uint64_t



        Return the number of labels after execution .


        """
        return _SimpleITK.LabelStatisticsImageFilter_GetNumberOfLabels(self)

LabelStatisticsImageFilter_swigregister = _SimpleITK.LabelStatisticsImageFilter_swigregister
LabelStatisticsImageFilter_swigregister(LabelStatisticsImageFilter)

class LabelToRGBImageFilter(ImageFilter_1):
    """


    Apply a colormap to a label image.


    Apply a colormap to a label image. The set of colors is a good
    selection of distinct colors. The user can choose to use a background
    value. In that case, a gray pixel with the same intensity than the
    background label is produced.

    This code was contributed in the Insight Journal paper: "The
    watershed transform in ITK - discussion and new developments" by
    Beare R., Lehmann G. https://hdl.handle.net/1926/202 http://www.insight-journal.org/browse/publication/92


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.


    See:
     LabelOverlayImageFilter

     LabelMapToRGBImageFilter , LabelToRGBFunctor, ScalarToRGBPixelFunctor

     itk::simple::LabelToRGB for the procedural interface

     itk::LabelToRGBImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelToRGBImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelToRGBImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelToRGBImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelToRGBImageFilter self) -> LabelToRGBImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelToRGBImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelToRGBImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LabelToRGBImageFilter self, double BackgroundValue)



        Set/Get the background value


        """
        return _SimpleITK.LabelToRGBImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LabelToRGBImageFilter self) -> double



        Set/Get the background value


        """
        return _SimpleITK.LabelToRGBImageFilter_GetBackgroundValue(self)


    def SetColormap(self, Colormap):
        """
        SetColormap(LabelToRGBImageFilter self, VectorUInt8 Colormap)



        """
        return _SimpleITK.LabelToRGBImageFilter_SetColormap(self, Colormap)


    def GetColormap(self):
        """
        GetColormap(LabelToRGBImageFilter self) -> VectorUInt8



        """
        return _SimpleITK.LabelToRGBImageFilter_GetColormap(self)


    def GetName(self):
        """
        GetName(LabelToRGBImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelToRGBImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelToRGBImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelToRGBImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelToRGBImageFilter self, Image image1) -> Image
        Execute(LabelToRGBImageFilter self, Image image1, double backgroundValue, VectorUInt8 colormap) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelToRGBImageFilter_Execute(self, *args)

LabelToRGBImageFilter_swigregister = _SimpleITK.LabelToRGBImageFilter_swigregister
LabelToRGBImageFilter_swigregister(LabelToRGBImageFilter)


def LabelToRGB(*args, **kwargs):
    """
    LabelToRGB(Image image1, double backgroundValue=0.0, VectorUInt8 colormap) -> Image



    Apply a colormap to a label image.


    This function directly calls the execute method of LabelToRGBImageFilter in order to support a procedural API


    See:
     itk::simple::LabelToRGBImageFilter for the object oriented interface



    """
    return _SimpleITK.LabelToRGB(*args, **kwargs)
class LabelUniqueLabelMapFilter(ImageFilter_1):
    """


    Make sure that the objects are not overlapping.


    AttributeUniqueLabelMapFilter search the overlapping zones in the overlapping objects and keeps
    only a single object on all the pixels of the image. The object to
    keep is selected according to their label.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    See:
     AttributeLabelObject

     itk::simple::LabelUniqueLabelMapFilter for the procedural interface

     itk::LabelUniqueLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLabelUniqueLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelUniqueLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelUniqueLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelUniqueLabelMapFilter self) -> LabelUniqueLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelUniqueLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelUniqueLabelMapFilter
    __del__ = lambda self: None

    def SetReverseOrdering(self, ReverseOrdering):
        """
        SetReverseOrdering(LabelUniqueLabelMapFilter self, bool ReverseOrdering)



        """
        return _SimpleITK.LabelUniqueLabelMapFilter_SetReverseOrdering(self, ReverseOrdering)


    def ReverseOrderingOn(self):
        """
        ReverseOrderingOn(LabelUniqueLabelMapFilter self)



        Set the value of ReverseOrdering to true or false respectfully.


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_ReverseOrderingOn(self)


    def ReverseOrderingOff(self):
        """
        ReverseOrderingOff(LabelUniqueLabelMapFilter self)



        """
        return _SimpleITK.LabelUniqueLabelMapFilter_ReverseOrderingOff(self)


    def GetReverseOrdering(self):
        """
        GetReverseOrdering(LabelUniqueLabelMapFilter self) -> bool



        """
        return _SimpleITK.LabelUniqueLabelMapFilter_GetReverseOrdering(self)


    def GetName(self):
        """
        GetName(LabelUniqueLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelUniqueLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelUniqueLabelMapFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelUniqueLabelMapFilter self, Image image1) -> Image
        Execute(LabelUniqueLabelMapFilter self, Image image1, bool reverseOrdering) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LabelUniqueLabelMapFilter_Execute(self, *args)

LabelUniqueLabelMapFilter_swigregister = _SimpleITK.LabelUniqueLabelMapFilter_swigregister
LabelUniqueLabelMapFilter_swigregister(LabelUniqueLabelMapFilter)


def LabelUniqueLabelMap(image1, reverseOrdering=False):
    """
    LabelUniqueLabelMap(Image image1, bool reverseOrdering=False) -> Image



    Make sure that the objects are not overlapping.


    This function directly calls the execute method of LabelUniqueLabelMapFilter in order to support a procedural API


    See:
     itk::simple::LabelUniqueLabelMapFilter for the object oriented interface



    """
    return _SimpleITK.LabelUniqueLabelMap(image1, reverseOrdering)
class LabelVotingImageFilter(ImageFilter_3):
    """


    This filter performs pixelwise voting among an arbitrary number of
    input images, where each of them represents a segmentation of the same
    scene (i.e., image).


    Label voting is a simple method of classifier combination applied to
    image segmentation. Typically, the accuracy of the combined
    segmentation exceeds the accuracy of any of the input segmentations.
    Voting is therefore commonly used as a way of boosting segmentation
    performance.

    The use of label voting for combination of multiple segmentations is
    described in

    T. Rohlfing and C. R. Maurer, Jr., "Multi-classifier framework for
    atlas-based image segmentation," Pattern Recognition Letters, 2005.

    INPUTS
    All input volumes to this filter must be segmentations of an image,
    that is, they must have discrete pixel values where each value
    represents a different segmented object.
     Input volumes must all contain the same size RequestedRegions. Not all input images must contain all possible labels, but all label
    values must have the same meaning in all images.

    OUTPUTS
    The voting filter produces a single output volume. Each output pixel
    contains the label that occurred most often among the labels assigned
    to this pixel in all the input volumes, that is, the label that
    received the maximum number of "votes" from the input pixels.. If
    the maximum number of votes is not unique, i.e., if more than one
    label have a maximum number of votes, an "undecided" label is
    assigned to that output pixel.
     By default, the label used for undecided pixels is the maximum label
    value used in the input images plus one. Since it is possible for an
    image with 8 bit pixel values to use all 256 possible label values, it
    is permissible to combine 8 bit (i.e., byte) images into a 16 bit
    (i.e., short) output image.

    PARAMETERS
    The label used for "undecided" labels can be set using
    SetLabelForUndecidedPixels. This functionality can be unset by calling
    UnsetLabelForUndecidedPixels.

    Torsten Rohlfing, SRI International, Neuroscience Program

    See:
     itk::simple::LabelVoting for the procedural interface


    C++ includes: sitkLabelVotingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LabelVotingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LabelVotingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LabelVotingImageFilter self) -> LabelVotingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LabelVotingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LabelVotingImageFilter
    __del__ = lambda self: None

    def SetLabelForUndecidedPixels(self, LabelForUndecidedPixels):
        """
        SetLabelForUndecidedPixels(LabelVotingImageFilter self, uint64_t LabelForUndecidedPixels)



        Set label value for undecided pixels.


        """
        return _SimpleITK.LabelVotingImageFilter_SetLabelForUndecidedPixels(self, LabelForUndecidedPixels)


    def GetLabelForUndecidedPixels(self):
        """
        GetLabelForUndecidedPixels(LabelVotingImageFilter self) -> uint64_t



        Get label value used for undecided pixels. After updating the filter,
        this function returns the actual label value used for undecided pixels
        in the current output. Note that this value is overwritten when
        SetLabelForUndecidedPixels is called and the new value only becomes
        effective upon the next filter update.


        """
        return _SimpleITK.LabelVotingImageFilter_GetLabelForUndecidedPixels(self)


    def GetName(self):
        """
        GetName(LabelVotingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LabelVotingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LabelVotingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LabelVotingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LabelVotingImageFilter self, VectorOfImage images) -> Image
        Execute(LabelVotingImageFilter self, Image image1) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
        Execute(LabelVotingImageFilter self, VectorOfImage images, uint64_t labelForUndecidedPixels) -> Image
        Execute(LabelVotingImageFilter self, Image image1, uint64_t labelForUndecidedPixels) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, uint64_t labelForUndecidedPixels) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, uint64_t labelForUndecidedPixels) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, Image image4, uint64_t labelForUndecidedPixels) -> Image
        Execute(LabelVotingImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5, uint64_t labelForUndecidedPixels) -> Image



        """
        return _SimpleITK.LabelVotingImageFilter_Execute(self, *args)

LabelVotingImageFilter_swigregister = _SimpleITK.LabelVotingImageFilter_swigregister
LabelVotingImageFilter_swigregister(LabelVotingImageFilter)


def LabelVoting(*args):
    """
    LabelVoting(VectorOfImage images, uint64_t labelForUndecidedPixels) -> Image
    LabelVoting(Image image1, uint64_t labelForUndecidedPixels) -> Image
    LabelVoting(Image image1, Image image2, uint64_t labelForUndecidedPixels) -> Image
    LabelVoting(Image image1, Image image2, Image image3, uint64_t labelForUndecidedPixels) -> Image
    LabelVoting(Image image1, Image image2, Image image3, Image image4, uint64_t labelForUndecidedPixels) -> Image
    LabelVoting(Image image1, Image image2, Image image3, Image image4, Image image5, uint64_t labelForUndecidedPixels) -> Image
    """
    return _SimpleITK.LabelVoting(*args)
class LandweberDeconvolutionImageFilter(ImageFilter_2):
    """


    Deconvolve an image using the Landweber deconvolution algorithm.


    This filter implements the Landweber deconvolution algorthm as defined
    in Bertero M and Boccacci P, "Introduction to Inverse Problems in
    Imaging", 1998. The algorithm assumes that the input image has been
    formed by a linear shift-invariant system with a known kernel.

    The Landweber algorithm converges to a solution that minimizes the sum
    of squared errors $||f \\otimes h - g||$ where $f$ is the estimate of the unblurred image, $\\otimes$ is the convolution operator, $h$ is the blurring kernel, and $g$ is the blurred input image. As such, it is best suited for images
    that have zero-mean Gaussian white noise.

    This is the base implementation of the Landweber algorithm. It may
    produce results with negative values. For a version of this algorithm
    that enforces a positivity constraint on each intermediate solution,
    see ProjectedLandweberDeconvolutionImageFilter .

    This code was adapted from the Insight Journal contribution:

    "Deconvolution: infrastructure and reference algorithms" by Gaetan
    Lehmann https://hdl.handle.net/10380/3207


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France
     Cory Quammen, The University of North Carolina at Chapel Hill


    See:
     IterativeDeconvolutionImageFilter

     RichardsonLucyDeconvolutionImageFilter

     ProjectedLandweberDeconvolutionImageFilter

     itk::simple::LandweberDeconvolution for the procedural interface

     itk::LandweberDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLandweberDeconvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LandweberDeconvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LandweberDeconvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LandweberDeconvolutionImageFilter self) -> LandweberDeconvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LandweberDeconvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LandweberDeconvolutionImageFilter
    __del__ = lambda self: None

    def SetAlpha(self, Alpha):
        """
        SetAlpha(LandweberDeconvolutionImageFilter self, double Alpha)



        Set/get relaxation factor.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetAlpha(self, Alpha)


    def GetAlpha(self):
        """
        GetAlpha(LandweberDeconvolutionImageFilter self) -> double



        Set/get relaxation factor.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetAlpha(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(LandweberDeconvolutionImageFilter self, int NumberOfIterations)



        Set the number of iterations.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(LandweberDeconvolutionImageFilter self) -> int



        Get the number of iterations.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetNumberOfIterations(self)


    def SetNormalize(self, Normalize):
        """
        SetNormalize(LandweberDeconvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(LandweberDeconvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(LandweberDeconvolutionImageFilter self)



        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(LandweberDeconvolutionImageFilter self) -> bool



        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.LandweberDeconvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.LandweberDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.LandweberDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(LandweberDeconvolutionImageFilter self, itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(LandweberDeconvolutionImageFilter self) -> itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.LandweberDeconvolutionImageFilter_SAME
    VALID = _SimpleITK.LandweberDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(LandweberDeconvolutionImageFilter self, itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(LandweberDeconvolutionImageFilter self) -> itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(LandweberDeconvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LandweberDeconvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LandweberDeconvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(LandweberDeconvolutionImageFilter self, Image image1, Image image2, double alpha, int numberOfIterations, bool normalize, itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.LandweberDeconvolutionImageFilter_Execute(self, *args)

LandweberDeconvolutionImageFilter_swigregister = _SimpleITK.LandweberDeconvolutionImageFilter_swigregister
LandweberDeconvolutionImageFilter_swigregister(LandweberDeconvolutionImageFilter)


def LandweberDeconvolution(*args, **kwargs):
    """
    LandweberDeconvolution(Image image1, Image image2, double alpha=0.1, int numberOfIterations=1, bool normalize=False, itk::simple::LandweberDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::LandweberDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    Deconvolve an image using the Landweber deconvolution algorithm.


    This function directly calls the execute method of LandweberDeconvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::LandweberDeconvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.LandweberDeconvolution(*args, **kwargs)
class LaplacianImageFilter(ImageFilter_1):
    """


    This filter computes the Laplacian of a scalar-valued image. The
    Laplacian is an isotropic measure of the 2nd spatial derivative of an
    image. The Laplacian of an image highlights regions of rapid intensity
    change and is therefore often used for edge detection. Often, the
    Laplacian is applied to an image that has first been smoothed with a
    Gaussian filter in order to reduce its sensitivity to noise.


    The Laplacian at each pixel location is computed by convolution with
    the itk::LaplacianOperator .
    Inputs and Outputs
    The input to this filter is a scalar-valued itk::Image of arbitrary dimension. The output is a scalar-valued itk::Image .

    WARNING:
    The pixel type of the input and output images must be of real type
    (float or double). ConceptChecking is used here to enforce the input
    pixel type. You will get a compilation error if the pixel type of the
    input and output images is not float or double.

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     LaplacianOperator
    Wiki Examples:

    All Examples

    Compute the Laplacian of an image
    See:
     itk::simple::Laplacian for the procedural interface

     itk::LaplacianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLaplacianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LaplacianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LaplacianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LaplacianImageFilter self) -> LaplacianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LaplacianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LaplacianImageFilter
    __del__ = lambda self: None

    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(LaplacianImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.LaplacianImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(LaplacianImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.LaplacianImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(LaplacianImageFilter self)



        """
        return _SimpleITK.LaplacianImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(LaplacianImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.LaplacianImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(LaplacianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LaplacianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LaplacianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LaplacianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LaplacianImageFilter self, Image image1) -> Image
        Execute(LaplacianImageFilter self, Image image1, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LaplacianImageFilter_Execute(self, *args)

LaplacianImageFilter_swigregister = _SimpleITK.LaplacianImageFilter_swigregister
LaplacianImageFilter_swigregister(LaplacianImageFilter)


def Laplacian(image1, useImageSpacing=True):
    """
    Laplacian(Image image1, bool useImageSpacing=True) -> Image



    itk::simple::LaplacianImageFilter Procedural Interface


    This function directly calls the execute method of LaplacianImageFilter in order to support a procedural API


    See:
     itk::simple::LaplacianImageFilter for the object oriented interface



    """
    return _SimpleITK.Laplacian(image1, useImageSpacing)
class LaplacianRecursiveGaussianImageFilter(ImageFilter_1):
    """


    Computes the Laplacian of Gaussian (LoG) of an image.


    Computes the Laplacian of Gaussian (LoG) of an image by convolution
    with the second derivative of a Gaussian. This filter is implemented
    using the recursive gaussian filters.

    Wiki Examples:

    All Examples

    Compute the Laplacian of Gaussian (LoG) of an image
    See:
     itk::simple::LaplacianRecursiveGaussian for the procedural interface

     itk::LaplacianRecursiveGaussianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLaplacianRecursiveGaussianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LaplacianRecursiveGaussianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LaplacianRecursiveGaussianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LaplacianRecursiveGaussianImageFilter self) -> LaplacianRecursiveGaussianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LaplacianRecursiveGaussianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LaplacianRecursiveGaussianImageFilter
    __del__ = lambda self: None

    def SetSigma(self, Sigma):
        """
        SetSigma(LaplacianRecursiveGaussianImageFilter self, double Sigma)



        Set Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_SetSigma(self, Sigma)


    def GetSigma(self):
        """
        GetSigma(LaplacianRecursiveGaussianImageFilter self) -> double



        Set Sigma value. Sigma is measured in the units of image spacing.


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_GetSigma(self)


    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        """
        SetNormalizeAcrossScale(LaplacianRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)



        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_SetNormalizeAcrossScale(self, NormalizeAcrossScale)


    def NormalizeAcrossScaleOn(self):
        """
        NormalizeAcrossScaleOn(LaplacianRecursiveGaussianImageFilter self)



        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(self)


    def NormalizeAcrossScaleOff(self):
        """
        NormalizeAcrossScaleOff(LaplacianRecursiveGaussianImageFilter self)



        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(self)


    def GetNormalizeAcrossScale(self):
        """
        GetNormalizeAcrossScale(LaplacianRecursiveGaussianImageFilter self) -> bool



        Define which normalization factor will be used for the Gaussian
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_GetNormalizeAcrossScale(self)


    def GetName(self):
        """
        GetName(LaplacianRecursiveGaussianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LaplacianRecursiveGaussianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LaplacianRecursiveGaussianImageFilter self, Image image1) -> Image
        Execute(LaplacianRecursiveGaussianImageFilter self, Image image1, double sigma, bool normalizeAcrossScale) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LaplacianRecursiveGaussianImageFilter_Execute(self, *args)

LaplacianRecursiveGaussianImageFilter_swigregister = _SimpleITK.LaplacianRecursiveGaussianImageFilter_swigregister
LaplacianRecursiveGaussianImageFilter_swigregister(LaplacianRecursiveGaussianImageFilter)


def LaplacianRecursiveGaussian(image1, sigma=1.0, normalizeAcrossScale=False):
    """
    LaplacianRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False) -> Image



    Computes the Laplacian of Gaussian (LoG) of an image.


    This function directly calls the execute method of LaplacianRecursiveGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::LaplacianRecursiveGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.LaplacianRecursiveGaussian(image1, sigma, normalizeAcrossScale)
class LaplacianSegmentationLevelSetImageFilter(ImageFilter_2):
    """


    Segments structures in images based on a second derivative image
    features.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the LaplacianSegmentationLevelSetFunction class contain additional information necessary to the full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. It constructs a
    speed function which is zero at image edges as detected by a Laplacian
    filter. The evolving level set front will therefore tend to lock onto
    zero crossings in the image. The level set front moves fastest near
    edges.

    The Laplacian segmentation filter is intended primarily as a tool for
    refining existing segmentations. The initial isosurface (as given in
    the seed input image) should ideally be very close to the segmentation
    boundary of interest. The idea is that a rough segmentation can be
    refined by allowing the isosurface to deform slightly to achieve a
    better fit to the edge features of an image. One example of such an
    application is to refine the output of a hand segmented image.

    Because values in the Laplacian feature image will tend to be low
    except near edge features, this filter is not effective for segmenting
    large image regions from small seed surfaces.
    INPUTS
    This filter requires two inputs. The first input is a seed image. This
    seed image must contain an isosurface that you want to use as the seed
    for your segmentation. It can be a binary, graylevel, or floating
    point image. The only requirement is that it contain a closed
    isosurface that you will identify as the seed by setting the
    IsosurfaceValue parameter of the filter. For a binary image you will
    want to set your isosurface value halfway between your on and off
    values (i.e. for 0's and 1's, use an isosurface value of 0.5).

    The second input is the feature image. This is the image from which
    the speed function will be calculated. For most applications, this is
    the image that you want to segment. The desired isosurface in your
    seed image should lie within the region of your feature image that you
    are trying to segment.
     Note that this filter does no preprocessing of the feature image
    before thresholding. Because second derivative calculations are highly
    sensitive to noise, isotropic or anisotropic smoothing of the feature
    image can dramatically improve the results.


    See SegmentationLevelSetImageFilter for more information on Inputs.
    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Positive
    *values in the output image are inside the segmentated region and
    negative *values in the image are outside of the inside region. The
    zero crossings of *the image correspond to the position of the level
    set front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    PARAMETERS
    This filter has no parameters other than those described in SegmentationLevelSetImageFilter .

    See:
     SegmentationLevelSetImageFilter

     LaplacianSegmentationLevelSetFunction ,

     SparseFieldLevelSetImageFilter

     itk::simple::LaplacianSegmentationLevelSet for the procedural interface

     itk::LaplacianSegmentationLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLaplacianSegmentationLevelSetImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LaplacianSegmentationLevelSetImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LaplacianSegmentationLevelSetImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LaplacianSegmentationLevelSetImageFilter self) -> LaplacianSegmentationLevelSetImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LaplacianSegmentationLevelSetImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LaplacianSegmentationLevelSetImageFilter
    __del__ = lambda self: None

    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(LaplacianSegmentationLevelSetImageFilter self, double MaximumRMSError)



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(LaplacianSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetMaximumRMSError(self)


    def SetPropagationScaling(self, PropagationScaling):
        """
        SetPropagationScaling(LaplacianSegmentationLevelSetImageFilter self, double PropagationScaling)



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetPropagationScaling(self, PropagationScaling)


    def GetPropagationScaling(self):
        """
        GetPropagationScaling(LaplacianSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetPropagationScaling(self)


    def SetCurvatureScaling(self, CurvatureScaling):
        """
        SetCurvatureScaling(LaplacianSegmentationLevelSetImageFilter self, double CurvatureScaling)



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetCurvatureScaling(self, CurvatureScaling)


    def GetCurvatureScaling(self):
        """
        GetCurvatureScaling(LaplacianSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetCurvatureScaling(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(LaplacianSegmentationLevelSetImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(LaplacianSegmentationLevelSetImageFilter self) -> uint32_t



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetNumberOfIterations(self)


    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        """
        SetReverseExpansionDirection(LaplacianSegmentationLevelSetImageFilter self, bool ReverseExpansionDirection)



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_SetReverseExpansionDirection(self, ReverseExpansionDirection)


    def ReverseExpansionDirectionOn(self):
        """
        ReverseExpansionDirectionOn(LaplacianSegmentationLevelSetImageFilter self)



        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_ReverseExpansionDirectionOn(self)


    def ReverseExpansionDirectionOff(self):
        """
        ReverseExpansionDirectionOff(LaplacianSegmentationLevelSetImageFilter self)



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_ReverseExpansionDirectionOff(self)


    def GetReverseExpansionDirection(self):
        """
        GetReverseExpansionDirection(LaplacianSegmentationLevelSetImageFilter self) -> bool



        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetReverseExpansionDirection(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(LaplacianSegmentationLevelSetImageFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(LaplacianSegmentationLevelSetImageFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetRMSChange(self)


    def GetName(self):
        """
        GetName(LaplacianSegmentationLevelSetImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LaplacianSegmentationLevelSetImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LaplacianSegmentationLevelSetImageFilter self, Image image1, Image image2) -> Image
        Execute(LaplacianSegmentationLevelSetImageFilter self, Image image1, Image image2, double maximumRMSError, double propagationScaling, double curvatureScaling, uint32_t numberOfIterations, bool reverseExpansionDirection) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.LaplacianSegmentationLevelSetImageFilter_Execute(self, *args)

LaplacianSegmentationLevelSetImageFilter_swigregister = _SimpleITK.LaplacianSegmentationLevelSetImageFilter_swigregister
LaplacianSegmentationLevelSetImageFilter_swigregister(LaplacianSegmentationLevelSetImageFilter)


def LaplacianSegmentationLevelSet(image1, image2, maximumRMSError=0.02, propagationScaling=1.0, curvatureScaling=1.0, numberOfIterations=1000, reverseExpansionDirection=False):
    """
    LaplacianSegmentationLevelSet(Image image1, Image image2, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image



    Segments structures in images based on a second derivative image
    features.


    This function directly calls the execute method of LaplacianSegmentationLevelSetImageFilter in order to support a procedural API


    See:
     itk::simple::LaplacianSegmentationLevelSetImageFilter for the object oriented interface



    """
    return _SimpleITK.LaplacianSegmentationLevelSet(image1, image2, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations, reverseExpansionDirection)
class LaplacianSharpeningImageFilter(ImageFilter_1):
    """


    This filter sharpens an image using a Laplacian. LaplacianSharpening
    highlights regions of rapid intensity change and therefore highlights
    or enhances the edges. The result is an image that appears more in
    focus.


    The LaplacianSharpening at each pixel location is computed by
    convolution with the itk::LaplacianOperator .
    Inputs and Outputs
    The input to this filter is a scalar-valued itk::Image of arbitrary dimension. The output is a scalar-valued itk::Image .

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     LaplacianOperator
    Wiki Examples:

    All Examples

    Sharpen an image
    See:
     itk::simple::LaplacianSharpening for the procedural interface

     itk::LaplacianSharpeningImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLaplacianSharpeningImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LaplacianSharpeningImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LaplacianSharpeningImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LaplacianSharpeningImageFilter self) -> LaplacianSharpeningImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LaplacianSharpeningImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LaplacianSharpeningImageFilter
    __del__ = lambda self: None

    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(LaplacianSharpeningImageFilter self, bool UseImageSpacing)



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(LaplacianSharpeningImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(LaplacianSharpeningImageFilter self)



        """
        return _SimpleITK.LaplacianSharpeningImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(LaplacianSharpeningImageFilter self) -> bool



        Set/Get whether or not the filter will use the spacing of the input
        image in its calculations


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(LaplacianSharpeningImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LaplacianSharpeningImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LaplacianSharpeningImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LaplacianSharpeningImageFilter self, Image image1) -> Image
        Execute(LaplacianSharpeningImageFilter self, Image image1, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LaplacianSharpeningImageFilter_Execute(self, *args)

LaplacianSharpeningImageFilter_swigregister = _SimpleITK.LaplacianSharpeningImageFilter_swigregister
LaplacianSharpeningImageFilter_swigregister(LaplacianSharpeningImageFilter)


def LaplacianSharpening(image1, useImageSpacing=True):
    """
    LaplacianSharpening(Image image1, bool useImageSpacing=True) -> Image



    This filter sharpens an image using a Laplacian. LaplacianSharpening
    highlights regions of rapid intensity change and therefore highlights
    or enhances the edges. The result is an image that appears more in
    focus.


    This function directly calls the execute method of LaplacianSharpeningImageFilter in order to support a procedural API


    See:
     itk::simple::LaplacianSharpeningImageFilter for the object oriented interface



    """
    return _SimpleITK.LaplacianSharpening(image1, useImageSpacing)
class LessEqualImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::LessEqual for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLessEqualImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LessEqualImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LessEqualImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LessEqualImageFilter self) -> LessEqualImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LessEqualImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LessEqualImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LessEqualImageFilter self, uint8_t BackgroundValue)



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LessEqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(LessEqualImageFilter self, uint8_t ForegroundValue)



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(LessEqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessEqualImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(LessEqualImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LessEqualImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LessEqualImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LessEqualImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LessEqualImageFilter self, Image image1, Image image2) -> Image
        Execute(LessEqualImageFilter self, Image image1, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(LessEqualImageFilter self, Image image1, double constant) -> Image
        Execute(LessEqualImageFilter self, double constant, Image image2) -> Image
        Execute(LessEqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(LessEqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image



        """
        return _SimpleITK.LessEqualImageFilter_Execute(self, *args)

LessEqualImageFilter_swigregister = _SimpleITK.LessEqualImageFilter_swigregister
LessEqualImageFilter_swigregister(LessEqualImageFilter)


def LessEqual(*args):
    """
    LessEqual(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    LessEqual(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    LessEqual(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image



    """
    return _SimpleITK.LessEqual(*args)
class LessImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::Less for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkLessImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LessImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LessImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LessImageFilter self) -> LessImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LessImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LessImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(LessImageFilter self, uint8_t BackgroundValue)



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(LessImageFilter self) -> uint8_t



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(LessImageFilter self, uint8_t ForegroundValue)



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(LessImageFilter self) -> uint8_t



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.LessImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(LessImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LessImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LessImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LessImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LessImageFilter self, Image image1, Image image2) -> Image
        Execute(LessImageFilter self, Image image1, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(LessImageFilter self, Image image1, double constant) -> Image
        Execute(LessImageFilter self, double constant, Image image2) -> Image
        Execute(LessImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(LessImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image



        """
        return _SimpleITK.LessImageFilter_Execute(self, *args)

LessImageFilter_swigregister = _SimpleITK.LessImageFilter_swigregister
LessImageFilter_swigregister(LessImageFilter)


def Less(*args):
    """
    Less(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Less(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    Less(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image



    """
    return _SimpleITK.Less(*args)
class LevelSetMotionRegistrationFilter(ImageFilter_0):
    """


    Deformably register two images using level set motion.


    LevelSetMotionFilter implements a deformable registration algorithm
    that aligns a fixed and a moving image under level set motion. The
    equations of motion are similar to those of the DemonsRegistrationFilter . The main differences are: (1) Gradients of the moving image are
    calculated on a smoothed image while intensity difference are measured
    on the original images (2) Magnitude of the motion vector is a
    function of the differences in intensity between the fixed and moving
    pixel. An adaptive timestep is calculated based on the maximum motion
    vector over the entire field to ensure stability. The timestep also
    implictly converts the motion vector measured in units of intensity to
    a vector measured in physical units. Demons, on the other hand,
    defines its motion vectors as function of both the intensity
    differences and gradient magnitude at each respective pixel. Consider
    two separate pixels with the same intensity differences between the
    corresponding fixed and moving pixel pairs. In demons, the motion
    vector of the pixel over a low gradient region will be larger than the
    motion vector of the pixel over a large gradient region. This leads to
    an unstable vector field. In the levelset approach, the motion vectors
    will be proportional to the gradients, scaled by the maximum gradient
    over the entire field. The pixel with at the lower gradient position
    will more less than the pixel at the higher gradient position. (3)
    Gradients are calculated using minmod finite difference instead of
    using central differences.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The algorithm has one parameters: the number of iteration to be
    performed.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in LevelSetMotionFunction.


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.
     Ref: B.C. Vemuri, J. Ye, Y. Chen, C.M. Leonard. "Image registration
    via level-set motion: applications to atlas-based segmentation".
    Medical Image Analysis. Vol. 7. pp. 1-20. 2003.


    See:
     LevelSetMotionRegistrationFunction

     DemonsRegistrationFilter

     itk::LevelSetMotionRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLevelSetMotionRegistrationFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LevelSetMotionRegistrationFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LevelSetMotionRegistrationFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LevelSetMotionRegistrationFilter self) -> LevelSetMotionRegistrationFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LevelSetMotionRegistrationFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LevelSetMotionRegistrationFilter
    __del__ = lambda self: None

    def SetGradientSmoothingStandardDeviations(self, GradientSmoothingStandardDeviations):
        """
        SetGradientSmoothingStandardDeviations(LevelSetMotionRegistrationFilter self, double GradientSmoothingStandardDeviations)



        Set/Get the standard deviation used for smoothing the moving image
        prior to calculating gradients. The standard deviation is measured in
        physical units (for instance mm). Note that this smoothing value is
        not to be confused with the
        PDEDeformableRegistrationFilter::SetStandardDeviations() method. The
        method in PDEDeformableRegistrationFilter is for setting the smoothing parameters for regularizing the
        deformation field between interations. Those smoothing parameters are
        set in pixel units not physical units. Deformation field smoothing is
        not done by default in LevelSetMotionRegistration. This smoothing
        parameter is to condition the gradient calculation and parameter is
        specified in physical units.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetGradientSmoothingStandardDeviations(self, GradientSmoothingStandardDeviations)


    def GetGradientSmoothingStandardDeviations(self):
        """
        GetGradientSmoothingStandardDeviations(LevelSetMotionRegistrationFilter self) -> double



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetGradientSmoothingStandardDeviations(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(LevelSetMotionRegistrationFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(LevelSetMotionRegistrationFilter self) -> uint32_t



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetNumberOfIterations(self)


    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(LevelSetMotionRegistrationFilter self, double MaximumRMSError)



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(LevelSetMotionRegistrationFilter self) -> double



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMaximumRMSError(self)


    def SetStandardDeviations(self, *args):
        """
        SetStandardDeviations(LevelSetMotionRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(LevelSetMotionRegistrationFilter self, double value)



        Set the values of the StandardDeviations vector all to value


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetStandardDeviations(self, *args)


    def GetStandardDeviations(self):
        """
        GetStandardDeviations(LevelSetMotionRegistrationFilter self) -> VectorDouble



        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetStandardDeviations(self)


    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        """
        SetSmoothDisplacementField(LevelSetMotionRegistrationFilter self, bool SmoothDisplacementField)



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetSmoothDisplacementField(self, SmoothDisplacementField)


    def SmoothDisplacementFieldOn(self):
        """
        SmoothDisplacementFieldOn(LevelSetMotionRegistrationFilter self)



        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothDisplacementFieldOn(self)


    def SmoothDisplacementFieldOff(self):
        """
        SmoothDisplacementFieldOff(LevelSetMotionRegistrationFilter self)



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothDisplacementFieldOff(self)


    def GetSmoothDisplacementField(self):
        """
        GetSmoothDisplacementField(LevelSetMotionRegistrationFilter self) -> bool



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetSmoothDisplacementField(self)


    def SetUpdateFieldStandardDeviations(self, *args):
        """
        SetUpdateFieldStandardDeviations(LevelSetMotionRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(LevelSetMotionRegistrationFilter self, double value)



        Set the values of the UpdateFieldStandardDeviations vector all to
        value


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetUpdateFieldStandardDeviations(self, *args)


    def GetUpdateFieldStandardDeviations(self):
        """
        GetUpdateFieldStandardDeviations(LevelSetMotionRegistrationFilter self) -> VectorDouble



        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetUpdateFieldStandardDeviations(self)


    def SetSmoothUpdateField(self, SmoothUpdateField):
        """
        SetSmoothUpdateField(LevelSetMotionRegistrationFilter self, bool SmoothUpdateField)



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetSmoothUpdateField(self, SmoothUpdateField)


    def SmoothUpdateFieldOn(self):
        """
        SmoothUpdateFieldOn(LevelSetMotionRegistrationFilter self)



        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothUpdateFieldOn(self)


    def SmoothUpdateFieldOff(self):
        """
        SmoothUpdateFieldOff(LevelSetMotionRegistrationFilter self)



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SmoothUpdateFieldOff(self)


    def GetSmoothUpdateField(self):
        """
        GetSmoothUpdateField(LevelSetMotionRegistrationFilter self) -> bool



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetSmoothUpdateField(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(LevelSetMotionRegistrationFilter self, unsigned int MaximumKernelWidth)



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(LevelSetMotionRegistrationFilter self) -> unsigned int



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(LevelSetMotionRegistrationFilter self, double MaximumError)



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(LevelSetMotionRegistrationFilter self) -> double



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMaximumError(self)


    def SetAlpha(self, Alpha):
        """
        SetAlpha(LevelSetMotionRegistrationFilter self, double Alpha)



        Set/Get the parameter alpha. Alpha is added to the calculated gradient
        magnitude prior to normalizing the gradient to protect against
        numerical instability as the gradient magnitude approaches zero. This
        should be set as a small fraction of the intensity dynamic range, for
        instance 0.04%. Default is the absolute (not percentage) value of 0.1.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetAlpha(self, Alpha)


    def GetAlpha(self):
        """
        GetAlpha(LevelSetMotionRegistrationFilter self) -> double



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetAlpha(self)


    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        """
        SetIntensityDifferenceThreshold(LevelSetMotionRegistrationFilter self, double IntensityDifferenceThreshold)



        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold)


    def GetIntensityDifferenceThreshold(self):
        """
        GetIntensityDifferenceThreshold(LevelSetMotionRegistrationFilter self) -> double



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetIntensityDifferenceThreshold(self)


    def SetGradientMagnitudeThreshold(self, GradientMagnitudeThreshold):
        """
        SetGradientMagnitudeThreshold(LevelSetMotionRegistrationFilter self, double GradientMagnitudeThreshold)



        Set/Get the threshold below which the gradient magnitude is considered
        the zero vector. Default is 1e-9.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetGradientMagnitudeThreshold(self, GradientMagnitudeThreshold)


    def GetGradientMagnitudeThreshold(self):
        """
        GetGradientMagnitudeThreshold(LevelSetMotionRegistrationFilter self) -> double



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetGradientMagnitudeThreshold(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(LevelSetMotionRegistrationFilter self, bool UseImageSpacing)



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(LevelSetMotionRegistrationFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(LevelSetMotionRegistrationFilter self)



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(LevelSetMotionRegistrationFilter self) -> bool



        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetUseImageSpacing(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(LevelSetMotionRegistrationFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(LevelSetMotionRegistrationFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetRMSChange(self)


    def GetMetric(self):
        """
        GetMetric(LevelSetMotionRegistrationFilter self) -> double



        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the the overlapping region between the two images. This
        is value is only available for the previous iteration and NOT the
        current iteration.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetMetric(self)


    def GetName(self):
        """
        GetName(LevelSetMotionRegistrationFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_GetName(self)


    def __str__(self):
        """
        __str__(LevelSetMotionRegistrationFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LevelSetMotionRegistrationFilter self, Image fixedImage, Image movingImage) -> Image
        Execute(LevelSetMotionRegistrationFilter self, Image fixedImage, Image movingImage, double gradientSmoothingStandardDeviations, uint32_t numberOfIterations, double maximumRMSError, VectorDouble standardDeviations, bool smoothDisplacementField, VectorDouble updateFieldStandardDeviations, bool smoothUpdateField, unsigned int maximumKernelWidth, double maximumError, double alpha, double intensityDifferenceThreshold, double gradientMagnitudeThreshold, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.LevelSetMotionRegistrationFilter_Execute(self, *args)

LevelSetMotionRegistrationFilter_swigregister = _SimpleITK.LevelSetMotionRegistrationFilter_swigregister
LevelSetMotionRegistrationFilter_swigregister(LevelSetMotionRegistrationFilter)

class LiThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Li Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the LiThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::LiThreshold for the procedural interface

     itk::LiThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLiThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LiThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LiThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LiThresholdImageFilter self) -> LiThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LiThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LiThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(LiThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.LiThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(LiThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.LiThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(LiThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.LiThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(LiThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.LiThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(LiThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.LiThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(LiThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.LiThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(LiThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.LiThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(LiThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.LiThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(LiThresholdImageFilter self)



        """
        return _SimpleITK.LiThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(LiThresholdImageFilter self) -> bool



        """
        return _SimpleITK.LiThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(LiThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.LiThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(LiThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.LiThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(LiThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.LiThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(LiThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LiThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LiThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LiThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(LiThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(LiThresholdImageFilter self, Image image) -> Image
        Execute(LiThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(LiThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.LiThresholdImageFilter_Execute(self, *args)

LiThresholdImageFilter_swigregister = _SimpleITK.LiThresholdImageFilter_swigregister
LiThresholdImageFilter_swigregister(LiThresholdImageFilter)


def LiThreshold(*args):
    """
    LiThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    LiThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.LiThreshold(*args)
class Log10ImageFilter(ImageFilter_1):
    """


    Computes the log10 of each pixel.


    The computation is performed using std::log10(x).
    See:
     itk::simple::Log10 for the procedural interface

     itk::Log10ImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLog10ImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Log10ImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Log10ImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::Log10ImageFilter self) -> Log10ImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_Log10ImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_Log10ImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(Log10ImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.Log10ImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(Log10ImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.Log10ImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(Log10ImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.Log10ImageFilter_Execute(self, image1)

Log10ImageFilter_swigregister = _SimpleITK.Log10ImageFilter_swigregister
Log10ImageFilter_swigregister(Log10ImageFilter)


def Log10(image1):
    """
    Log10(Image image1) -> Image



    Computes the log10 of each pixel.


    This function directly calls the execute method of Log10ImageFilter in order to support a procedural API


    See:
     itk::simple::Log10ImageFilter for the object oriented interface



    """
    return _SimpleITK.Log10(image1)
class LogImageFilter(ImageFilter_1):
    """


    Computes the log() of each pixel.



    See:
     itk::simple::Log for the procedural interface

     itk::LogImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkLogImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LogImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::LogImageFilter self) -> LogImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_LogImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_LogImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(LogImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.LogImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(LogImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.LogImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(LogImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.LogImageFilter_Execute(self, image1)

LogImageFilter_swigregister = _SimpleITK.LogImageFilter_swigregister
LogImageFilter_swigregister(LogImageFilter)


def Log(image1):
    """
    Log(Image image1) -> Image



    Computes the log() of each pixel.


    This function directly calls the execute method of LogImageFilter in order to support a procedural API


    See:
     itk::simple::LogImageFilter for the object oriented interface



    """
    return _SimpleITK.Log(image1)
class MagnitudeAndPhaseToComplexImageFilter(ImageFilter_2):
    """


    Implements pixel-wise conversion of magnitude and phase data into
    complex voxels.


    This filter is parametrized over the types of the two input images and
    the type of the output image.

    The filter expect all images to have the same dimension (e.g. all 2D,
    or all 3D, or all ND)
    See:
     itk::simple::MagnitudeAndPhaseToComplex for the procedural interface

     itk::MagnitudeAndPhaseToComplexImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMagnitudeAndPhaseToComplexImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MagnitudeAndPhaseToComplexImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MagnitudeAndPhaseToComplexImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MagnitudeAndPhaseToComplexImageFilter self) -> MagnitudeAndPhaseToComplexImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MagnitudeAndPhaseToComplexImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MagnitudeAndPhaseToComplexImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(MagnitudeAndPhaseToComplexImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MagnitudeAndPhaseToComplexImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MagnitudeAndPhaseToComplexImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MagnitudeAndPhaseToComplexImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MagnitudeAndPhaseToComplexImageFilter self, Image image1, Image image2) -> Image
        Execute(MagnitudeAndPhaseToComplexImageFilter self, Image image1, double constant) -> Image
        Execute(MagnitudeAndPhaseToComplexImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.MagnitudeAndPhaseToComplexImageFilter_Execute(self, *args)

MagnitudeAndPhaseToComplexImageFilter_swigregister = _SimpleITK.MagnitudeAndPhaseToComplexImageFilter_swigregister
MagnitudeAndPhaseToComplexImageFilter_swigregister(MagnitudeAndPhaseToComplexImageFilter)


def MagnitudeAndPhaseToComplex(*args):
    """
    MagnitudeAndPhaseToComplex(Image image1, Image image2) -> Image
    MagnitudeAndPhaseToComplex(Image image1, double constant) -> Image
    MagnitudeAndPhaseToComplex(double constant, Image image2) -> Image



    """
    return _SimpleITK.MagnitudeAndPhaseToComplex(*args)
class MaskImageFilter(ImageFilter_0):
    """


    Mask an image with a mask.


    This class is templated over the types of the input image type, the
    mask image type and the type of the output image. Numeric conversions
    (castings) are done by the C++ defaults.

    The pixel type of the input 2 image must have a valid definition of
    the operator != with zero. This condition is required because
    internally this filter will perform the operation


    The pixel from the input 1 is cast to the pixel type of the output
    image.

    Note that the input and the mask images must be of the same size.


    WARNING:
    Any pixel value other than masking value (0 by default) will not be
    masked out.

    See:
     MaskNegatedImageFilter
    Wiki Examples:

    All Examples

    Apply a mask to an image
    See:
     itk::simple::Mask for the procedural interface

     itk::MaskImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMaskImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaskImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaskImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MaskImageFilter self) -> MaskImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MaskImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MaskImageFilter
    __del__ = lambda self: None

    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(MaskImageFilter self, double OutsideValue)



        Method to explicitly set the outside value of the mask. Defaults to 0


        """
        return _SimpleITK.MaskImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(MaskImageFilter self) -> double



        """
        return _SimpleITK.MaskImageFilter_GetOutsideValue(self)


    def GetName(self):
        """
        GetName(MaskImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MaskImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MaskImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MaskImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MaskImageFilter self, Image image, Image maskImage) -> Image
        Execute(MaskImageFilter self, Image image, Image maskImage, double outsideValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MaskImageFilter_Execute(self, *args)

MaskImageFilter_swigregister = _SimpleITK.MaskImageFilter_swigregister
MaskImageFilter_swigregister(MaskImageFilter)


def Mask(image, maskImage, outsideValue=0):
    """
    Mask(Image image, Image maskImage, double outsideValue=0) -> Image



    Mask an image with a mask.


    This function directly calls the execute method of MaskImageFilter in order to support a procedural API


    See:
     itk::simple::MaskImageFilter for the object oriented interface



    """
    return _SimpleITK.Mask(image, maskImage, outsideValue)
class MaskNegatedImageFilter(ImageFilter_0):
    """


    Mask an image with the negative of a mask.


    This class is templated over the types of the input image type, the
    mask image type and the type of the output image. Numeric conversions
    (castings) are done by the C++ defaults. The pixel type of the input 2
    image must have a valid definition of the operator != with zero. This
    condition is required because internally this filter will perform the
    operation ifpixel_from_mask_image!=0pixel_output_image=output_valueels
    epixel_output_image=pixel_input_image The pixel from the input 1 is
    cast to the pixel type of the output image. Note that the input and
    the mask images must be of the same size.
    WARNING:
    Any pixel value other than 0 will not be masked out.

    See:
     MaskImageFilter
    Wiki Examples:

    All Examples

    Apply the inverse of a mask to an image

    See:
     itk::simple::MaskNegated for the procedural interface

     itk::MaskNegatedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaskNegatedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaskNegatedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaskNegatedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MaskNegatedImageFilter self) -> MaskNegatedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MaskNegatedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MaskNegatedImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(MaskNegatedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MaskNegatedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MaskNegatedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MaskNegatedImageFilter___str__(self)


    def Execute(self, image, maskImage):
        """
        Execute(MaskNegatedImageFilter self, Image image, Image maskImage) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.MaskNegatedImageFilter_Execute(self, image, maskImage)

MaskNegatedImageFilter_swigregister = _SimpleITK.MaskNegatedImageFilter_swigregister
MaskNegatedImageFilter_swigregister(MaskNegatedImageFilter)


def MaskNegated(image, maskImage):
    """
    MaskNegated(Image image, Image maskImage) -> Image



    Mask an image with the negative of a mask.


    This function directly calls the execute method of MaskNegatedImageFilter in order to support a procedural API


    See:
     itk::simple::MaskNegatedImageFilter for the object oriented interface



    """
    return _SimpleITK.MaskNegated(image, maskImage)
class MaskedFFTNormalizedCorrelationImageFilter(ImageFilter_0):
    """


    Calculate masked normalized cross correlation using FFTs.


    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. For example, if
    only a mask for the fixed image is needed, the movingMask can either
    not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. For example, when the masks have strange shapes, it is
    difficult to predict how the correlation of the masks will interact
    and what the maximum overlap will be. It is also useful when the mask
    shapes or sizes change because it is relative to the internally
    computed maximum of the overlap. Larger values zero-out pixels on a
    larger border around the correlation image. Thus, larger values remove
    less stable computations but also limit the capture range. Experiments
    have shown that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain, all
    input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:


    WARNING:
    The pixel type of the output image must be of real type (float or
    double). ConceptChecking is used to enforce the output pixel type. You
    will get a compilation error if the pixel type of the output image is
    not float or double.
     References: 1) D. Padfield. "Masked object registration in the
    Fourier domain." Transactions on Image Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.


    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    See:
     itk::simple::MaskedFFTNormalizedCorrelation for the procedural interface

     itk::MaskedFFTNormalizedCorrelationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaskedFFTNormalizedCorrelationImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaskedFFTNormalizedCorrelationImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaskedFFTNormalizedCorrelationImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MaskedFFTNormalizedCorrelationImageFilter self) -> MaskedFFTNormalizedCorrelationImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MaskedFFTNormalizedCorrelationImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MaskedFFTNormalizedCorrelationImageFilter
    __del__ = lambda self: None

    def SetRequiredNumberOfOverlappingPixels(self, RequiredNumberOfOverlappingPixels):
        """
        SetRequiredNumberOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self, uint64_t RequiredNumberOfOverlappingPixels)



        Set and get the required number of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_SetRequiredNumberOfOverlappingPixels(self, RequiredNumberOfOverlappingPixels)


    def GetRequiredNumberOfOverlappingPixels(self):
        """
        GetRequiredNumberOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self) -> uint64_t



        Set and get the required number of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_GetRequiredNumberOfOverlappingPixels(self)


    def SetRequiredFractionOfOverlappingPixels(self, RequiredFractionOfOverlappingPixels):
        """
        SetRequiredFractionOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self, float RequiredFractionOfOverlappingPixels)



        Set and get the required fraction of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_SetRequiredFractionOfOverlappingPixels(self, RequiredFractionOfOverlappingPixels)


    def GetRequiredFractionOfOverlappingPixels(self):
        """
        GetRequiredFractionOfOverlappingPixels(MaskedFFTNormalizedCorrelationImageFilter self) -> float



        Set and get the required fraction of overlapping pixels


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_GetRequiredFractionOfOverlappingPixels(self)


    def GetName(self):
        """
        GetName(MaskedFFTNormalizedCorrelationImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MaskedFFTNormalizedCorrelationImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MaskedFFTNormalizedCorrelationImageFilter self, Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask) -> Image
        Execute(MaskedFFTNormalizedCorrelationImageFilter self, Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask, uint64_t requiredNumberOfOverlappingPixels, float requiredFractionOfOverlappingPixels) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_Execute(self, *args)

MaskedFFTNormalizedCorrelationImageFilter_swigregister = _SimpleITK.MaskedFFTNormalizedCorrelationImageFilter_swigregister
MaskedFFTNormalizedCorrelationImageFilter_swigregister(MaskedFFTNormalizedCorrelationImageFilter)


def MaskedFFTNormalizedCorrelation(fixedImage, movingImage, fixedImageMask, movingImageMask, requiredNumberOfOverlappingPixels=0, requiredFractionOfOverlappingPixels=0.0):
    """
    MaskedFFTNormalizedCorrelation(Image fixedImage, Image movingImage, Image fixedImageMask, Image movingImageMask, uint64_t requiredNumberOfOverlappingPixels=0, float requiredFractionOfOverlappingPixels=0.0) -> Image



    Calculate masked normalized cross correlation using FFTs.


    This function directly calls the execute method of MaskedFFTNormalizedCorrelationImageFilter in order to support a procedural API


    See:
     itk::simple::MaskedFFTNormalizedCorrelationImageFilter for the object oriented interface



    """
    return _SimpleITK.MaskedFFTNormalizedCorrelation(fixedImage, movingImage, fixedImageMask, movingImageMask, requiredNumberOfOverlappingPixels, requiredFractionOfOverlappingPixels)
class MaximumEntropyThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the MaximumEntropy Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the MaximumEntropyThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::MaximumEntropyThreshold for the procedural interface

     itk::MaximumEntropyThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaximumEntropyThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaximumEntropyThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaximumEntropyThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MaximumEntropyThresholdImageFilter self) -> MaximumEntropyThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MaximumEntropyThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MaximumEntropyThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(MaximumEntropyThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(MaximumEntropyThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(MaximumEntropyThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(MaximumEntropyThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(MaximumEntropyThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(MaximumEntropyThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(MaximumEntropyThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(MaximumEntropyThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(MaximumEntropyThresholdImageFilter self)



        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(MaximumEntropyThresholdImageFilter self) -> bool



        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(MaximumEntropyThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(MaximumEntropyThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(MaximumEntropyThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(MaximumEntropyThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MaximumEntropyThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MaximumEntropyThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(MaximumEntropyThresholdImageFilter self, Image image) -> Image
        Execute(MaximumEntropyThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(MaximumEntropyThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.MaximumEntropyThresholdImageFilter_Execute(self, *args)

MaximumEntropyThresholdImageFilter_swigregister = _SimpleITK.MaximumEntropyThresholdImageFilter_swigregister
MaximumEntropyThresholdImageFilter_swigregister(MaximumEntropyThresholdImageFilter)


def MaximumEntropyThreshold(*args):
    """
    MaximumEntropyThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    MaximumEntropyThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.MaximumEntropyThreshold(*args)
class MaximumImageFilter(ImageFilter_2):
    """


    Implements a pixel-wise operator Max(a,b) between two images.


    The pixel values of the output image are the maximum between the
    corresponding pixels of the two input images.

    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Wiki Examples:

    All Examples

    Pixel wise compare two input images and set the output pixel to their
    max
    See:
     itk::simple::Maximum for the procedural interface

     itk::MaximumImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMaximumImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaximumImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaximumImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MaximumImageFilter self) -> MaximumImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MaximumImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MaximumImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(MaximumImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MaximumImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MaximumImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MaximumImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MaximumImageFilter self, Image image1, Image image2) -> Image
        Execute(MaximumImageFilter self, Image image1, double constant) -> Image
        Execute(MaximumImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.MaximumImageFilter_Execute(self, *args)

MaximumImageFilter_swigregister = _SimpleITK.MaximumImageFilter_swigregister
MaximumImageFilter_swigregister(MaximumImageFilter)


def Maximum(*args):
    """
    Maximum(Image image1, Image image2) -> Image
    Maximum(Image image1, double constant) -> Image
    Maximum(double constant, Image image2) -> Image



    """
    return _SimpleITK.Maximum(*args)
class MaximumProjectionImageFilter(ImageFilter_1):
    """


    Maximum projection.


    This class was contributed to the insight journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la reproduction, inra
    de jouy-en-josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     itk::simple::MaximumProjection for the procedural interface

     itk::MaximumProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMaximumProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MaximumProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MaximumProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MaximumProjectionImageFilter self) -> MaximumProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MaximumProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MaximumProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(MaximumProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.MaximumProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(MaximumProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.MaximumProjectionImageFilter_GetProjectionDimension(self)


    def GetName(self):
        """
        GetName(MaximumProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MaximumProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MaximumProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MaximumProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MaximumProjectionImageFilter self, Image image1) -> Image
        Execute(MaximumProjectionImageFilter self, Image image1, unsigned int projectionDimension) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MaximumProjectionImageFilter_Execute(self, *args)

MaximumProjectionImageFilter_swigregister = _SimpleITK.MaximumProjectionImageFilter_swigregister
MaximumProjectionImageFilter_swigregister(MaximumProjectionImageFilter)


def MaximumProjection(image1, projectionDimension=0):
    """
    MaximumProjection(Image image1, unsigned int projectionDimension=0) -> Image



    Maximum projection.


    This function directly calls the execute method of MaximumProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::MaximumProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.MaximumProjection(image1, projectionDimension)
class MeanImageFilter(ImageFilter_1):
    """


    Applies an averaging filter to an image.


    Computes an image where a given pixel is the mean value of the the
    pixels in a neighborhood about the corresponding input pixel.

    A mean filter is one of the family of linear filters.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Mean filter an image
    See:
     itk::simple::Mean for the procedural interface

     itk::MeanImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMeanImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeanImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeanImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MeanImageFilter self) -> MeanImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MeanImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MeanImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(MeanImageFilter self, VectorUInt32 Radius)
        SetRadius(MeanImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.MeanImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(MeanImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.MeanImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(MeanImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MeanImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MeanImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MeanImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MeanImageFilter self, Image image1) -> Image
        Execute(MeanImageFilter self, Image image1, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MeanImageFilter_Execute(self, *args)

MeanImageFilter_swigregister = _SimpleITK.MeanImageFilter_swigregister
MeanImageFilter_swigregister(MeanImageFilter)


def Mean(*args, **kwargs):
    """
    Mean(Image image1, VectorUInt32 radius) -> Image



    Applies an averaging filter to an image.


    This function directly calls the execute method of MeanImageFilter in order to support a procedural API


    See:
     itk::simple::MeanImageFilter for the object oriented interface



    """
    return _SimpleITK.Mean(*args, **kwargs)
class MeanProjectionImageFilter(ImageFilter_1):
    """


    Mean projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MinimumProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     MaximumProjectionImageFilter

     itk::simple::MeanProjection for the procedural interface

     itk::MeanProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMeanProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeanProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeanProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MeanProjectionImageFilter self) -> MeanProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MeanProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MeanProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(MeanProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.MeanProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(MeanProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.MeanProjectionImageFilter_GetProjectionDimension(self)


    def GetName(self):
        """
        GetName(MeanProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MeanProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MeanProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MeanProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MeanProjectionImageFilter self, Image image1) -> Image
        Execute(MeanProjectionImageFilter self, Image image1, unsigned int projectionDimension) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MeanProjectionImageFilter_Execute(self, *args)

MeanProjectionImageFilter_swigregister = _SimpleITK.MeanProjectionImageFilter_swigregister
MeanProjectionImageFilter_swigregister(MeanProjectionImageFilter)


def MeanProjection(image1, projectionDimension=0):
    """
    MeanProjection(Image image1, unsigned int projectionDimension=0) -> Image



    Mean projection.


    This function directly calls the execute method of MeanProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::MeanProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.MeanProjection(image1, projectionDimension)
class MedianImageFilter(ImageFilter_1):
    """


    Applies a median filter to an image.


    Computes an image where a given pixel is the median value of the the
    pixels in a neighborhood about the corresponding input pixel.

    A median filter is one of the family of nonlinear filters. It is used
    to smooth an image without being biased by outliers or shot noise.

    This filter requires that the input pixel type provides an operator<()
    (LessThan Comparable).


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Median filter an image

    Median filter an RGB image
    See:
     itk::simple::Median for the procedural interface

     itk::MedianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMedianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MedianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MedianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MedianImageFilter self) -> MedianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MedianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MedianImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(MedianImageFilter self, VectorUInt32 Radius)
        SetRadius(MedianImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.MedianImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(MedianImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.MedianImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(MedianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MedianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MedianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MedianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MedianImageFilter self, Image image1) -> Image
        Execute(MedianImageFilter self, Image image1, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MedianImageFilter_Execute(self, *args)

MedianImageFilter_swigregister = _SimpleITK.MedianImageFilter_swigregister
MedianImageFilter_swigregister(MedianImageFilter)


def Median(*args, **kwargs):
    """
    Median(Image image1, VectorUInt32 radius) -> Image



    Applies a median filter to an image.


    This function directly calls the execute method of MedianImageFilter in order to support a procedural API


    See:
     itk::simple::MedianImageFilter for the object oriented interface



    """
    return _SimpleITK.Median(*args, **kwargs)
class MedianProjectionImageFilter(ImageFilter_1):
    """


    Median projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     MeanProjectionImageFilter

     itk::simple::MedianProjection for the procedural interface

     itk::MedianProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMedianProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MedianProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MedianProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MedianProjectionImageFilter self) -> MedianProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MedianProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MedianProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(MedianProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.MedianProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(MedianProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.MedianProjectionImageFilter_GetProjectionDimension(self)


    def GetName(self):
        """
        GetName(MedianProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MedianProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MedianProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MedianProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MedianProjectionImageFilter self, Image image1) -> Image
        Execute(MedianProjectionImageFilter self, Image image1, unsigned int projectionDimension) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MedianProjectionImageFilter_Execute(self, *args)

MedianProjectionImageFilter_swigregister = _SimpleITK.MedianProjectionImageFilter_swigregister
MedianProjectionImageFilter_swigregister(MedianProjectionImageFilter)


def MedianProjection(image1, projectionDimension=0):
    """
    MedianProjection(Image image1, unsigned int projectionDimension=0) -> Image



    Median projection.


    This function directly calls the execute method of MedianProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::MedianProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.MedianProjection(image1, projectionDimension)
class MergeLabelMapFilter(ImageFilter_3):
    """


    Merges several Label Maps.


    This filter takes one or more input Label Map and merges them.

    SetMethod() can be used to change how the filter manage the labels from the
    different label maps. KEEP (0): MergeLabelMapFilter do its best to keep the label unchanged, but if a label is already
    used in a previous label map, a new label is assigned. AGGREGATE (1):
    If the same label is found several times in the label maps, the label
    objects with the same label are merged. PACK (2): MergeLabelMapFilter relabel all the label objects by order of processing. No conflict can
    occur. STRICT (3): MergeLabelMapFilter keeps the labels unchanged and raises an exception if the same label
    is found in several images.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::MergeLabelMapFilter for the procedural interface


    C++ includes: sitkMergeLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MergeLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MergeLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MergeLabelMapFilter self) -> MergeLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MergeLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MergeLabelMapFilter
    __del__ = lambda self: None
    Keep = _SimpleITK.MergeLabelMapFilter_Keep
    Aggregate = _SimpleITK.MergeLabelMapFilter_Aggregate
    Pack = _SimpleITK.MergeLabelMapFilter_Pack
    Strict = _SimpleITK.MergeLabelMapFilter_Strict

    def SetMethod(self, Method):
        """
        SetMethod(MergeLabelMapFilter self, itk::simple::MergeLabelMapFilter::MethodType Method)



        Set/Get the method used to merge the label maps


        """
        return _SimpleITK.MergeLabelMapFilter_SetMethod(self, Method)


    def GetMethod(self):
        """
        GetMethod(MergeLabelMapFilter self) -> itk::simple::MergeLabelMapFilter::MethodType



        Set/Get the method used to merge the label maps


        """
        return _SimpleITK.MergeLabelMapFilter_GetMethod(self)


    def GetName(self):
        """
        GetName(MergeLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MergeLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(MergeLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MergeLabelMapFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MergeLabelMapFilter self, VectorOfImage images) -> Image
        Execute(MergeLabelMapFilter self, Image image1) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
        Execute(MergeLabelMapFilter self, VectorOfImage images, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
        Execute(MergeLabelMapFilter self, Image image1, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, Image image4, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
        Execute(MergeLabelMapFilter self, Image image1, Image image2, Image image3, Image image4, Image image5, itk::simple::MergeLabelMapFilter::MethodType method) -> Image



        """
        return _SimpleITK.MergeLabelMapFilter_Execute(self, *args)

MergeLabelMapFilter_swigregister = _SimpleITK.MergeLabelMapFilter_swigregister
MergeLabelMapFilter_swigregister(MergeLabelMapFilter)


def MergeLabelMap(*args):
    """
    MergeLabelMap(VectorOfImage images, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
    MergeLabelMap(Image image1, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
    MergeLabelMap(Image image1, Image image2, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
    MergeLabelMap(Image image1, Image image2, Image image3, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
    MergeLabelMap(Image image1, Image image2, Image image3, Image image4, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
    MergeLabelMap(Image image1, Image image2, Image image3, Image image4, Image image5, itk::simple::MergeLabelMapFilter::MethodType method) -> Image
    """
    return _SimpleITK.MergeLabelMap(*args)
class MinMaxCurvatureFlowImageFilter(ImageFilter_1):
    """


    Denoise an image using min/max curvature flow.


    MinMaxCurvatureFlowImageFilter implements a curvature driven image denoising algorithm. Iso-
    brightness contours in the grayscale input image are viewed as a level
    set. The level set is then evolved using a curvature-based speed
    function:

    \\[ I_t = F_{\\mbox{minmax}} |\\nabla I| \\]

    where $ F_{\\mbox{minmax}} = \\max(\\kappa,0) $ if $ \\mbox{Avg}_{\\mbox{stencil}}(x) $ is less than or equal to $ T_{thresold} $ and $ \\min(\\kappa,0) $ , otherwise. $ \\kappa $ is the mean curvature of the iso-brightness contour at point $ x $ .

    In min/max curvature flow, movement is turned on or off depending on
    the scale of the noise one wants to remove. Switching depends on the
    average image value of a region of radius $ R $ around each point. The choice of $ R $ , the stencil radius, governs the scale of the noise to be removed.

    The threshold value $ T_{threshold} $ is the average intensity obtained in the direction perpendicular to
    the gradient at point $ x $ at the extrema of the local neighborhood.

    This filter make use of the multi-threaded finite difference solver
    hierarchy. Updates are computed using a MinMaxCurvatureFlowFunction object. A zero flux Neumann boundary condition is used when computing
    derivatives near the data boundary.


    WARNING:
    This filter assumes that the input and output types have the same
    dimensions. This filter also requires that the output image pixels are
    of a real type. This filter works for any dimensional images, however
    for dimensions greater than 3D, an expensive brute-force search is
    used to compute the local threshold.
     Reference: "Level Set Methods and Fast Marching Methods", J.A.
    Sethian, Cambridge Press, Chapter 16, Second edition, 1999.


    See:
     MinMaxCurvatureFlowFunction

     CurvatureFlowImageFilter

     BinaryMinMaxCurvatureFlowImageFilter

     itk::simple::MinMaxCurvatureFlow for the procedural interface

     itk::MinMaxCurvatureFlowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinMaxCurvatureFlowImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinMaxCurvatureFlowImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinMaxCurvatureFlowImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MinMaxCurvatureFlowImageFilter self) -> MinMaxCurvatureFlowImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MinMaxCurvatureFlowImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MinMaxCurvatureFlowImageFilter
    __del__ = lambda self: None

    def SetTimeStep(self, TimeStep):
        """
        SetTimeStep(MinMaxCurvatureFlowImageFilter self, double TimeStep)



        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_SetTimeStep(self, TimeStep)


    def GetTimeStep(self):
        """
        GetTimeStep(MinMaxCurvatureFlowImageFilter self) -> double



        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetTimeStep(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(MinMaxCurvatureFlowImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(MinMaxCurvatureFlowImageFilter self) -> uint32_t



        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetNumberOfIterations(self)


    def SetStencilRadius(self, StencilRadius):
        """
        SetStencilRadius(MinMaxCurvatureFlowImageFilter self, int StencilRadius)



        Set/Get the stencil radius.


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_SetStencilRadius(self, StencilRadius)


    def GetStencilRadius(self):
        """
        GetStencilRadius(MinMaxCurvatureFlowImageFilter self) -> int



        Set/Get the stencil radius.


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetStencilRadius(self)


    def GetName(self):
        """
        GetName(MinMaxCurvatureFlowImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MinMaxCurvatureFlowImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MinMaxCurvatureFlowImageFilter self, Image image1) -> Image
        Execute(MinMaxCurvatureFlowImageFilter self, Image image1, double timeStep, uint32_t numberOfIterations, int stencilRadius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MinMaxCurvatureFlowImageFilter_Execute(self, *args)

MinMaxCurvatureFlowImageFilter_swigregister = _SimpleITK.MinMaxCurvatureFlowImageFilter_swigregister
MinMaxCurvatureFlowImageFilter_swigregister(MinMaxCurvatureFlowImageFilter)


def MinMaxCurvatureFlow(image1, timeStep=0.05, numberOfIterations=5, stencilRadius=2):
    """
    MinMaxCurvatureFlow(Image image1, double timeStep=0.05, uint32_t numberOfIterations=5, int stencilRadius=2) -> Image



    Denoise an image using min/max curvature flow.


    This function directly calls the execute method of MinMaxCurvatureFlowImageFilter in order to support a procedural API


    See:
     itk::simple::MinMaxCurvatureFlowImageFilter for the object oriented interface



    """
    return _SimpleITK.MinMaxCurvatureFlow(image1, timeStep, numberOfIterations, stencilRadius)
class MinimumImageFilter(ImageFilter_2):
    """


    Implements a pixel-wise operator Min(a,b) between two images.


    The pixel values of the output image are the minimum between the
    corresponding pixels of the two input images.

    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Wiki Examples:

    All Examples

    Pixel wise compare two input images and set the output pixel to their
    min
    See:
     itk::simple::Minimum for the procedural interface

     itk::MinimumImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMinimumImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinimumImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinimumImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MinimumImageFilter self) -> MinimumImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MinimumImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MinimumImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(MinimumImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MinimumImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MinimumImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MinimumImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MinimumImageFilter self, Image image1, Image image2) -> Image
        Execute(MinimumImageFilter self, Image image1, double constant) -> Image
        Execute(MinimumImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.MinimumImageFilter_Execute(self, *args)

MinimumImageFilter_swigregister = _SimpleITK.MinimumImageFilter_swigregister
MinimumImageFilter_swigregister(MinimumImageFilter)


def Minimum(*args):
    """
    Minimum(Image image1, Image image2) -> Image
    Minimum(Image image1, double constant) -> Image
    Minimum(double constant, Image image2) -> Image



    """
    return _SimpleITK.Minimum(*args)
class MinimumMaximumImageFilter(ImageFilter_1):
    """


    Computes the minimum and the maximum intensity values of an image.


    It is templated over input image type only. This filter just copies
    the input image through this output to be included within the
    pipeline. The implementation uses the StatisticsImageFilter .


    See:
     StatisticsImageFilter

     itk::MinimumMaximumImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinimumMaximumImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinimumMaximumImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinimumMaximumImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MinimumMaximumImageFilter self) -> MinimumMaximumImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MinimumMaximumImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MinimumMaximumImageFilter
    __del__ = lambda self: None

    def GetMinimum(self):
        """
        GetMinimum(MinimumMaximumImageFilter self) -> double



        Return the computed Minimum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MinimumMaximumImageFilter_GetMinimum(self)


    def GetMaximum(self):
        """
        GetMaximum(MinimumMaximumImageFilter self) -> double



        Return the computed Maximum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MinimumMaximumImageFilter_GetMaximum(self)


    def GetName(self):
        """
        GetName(MinimumMaximumImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MinimumMaximumImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MinimumMaximumImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MinimumMaximumImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(MinimumMaximumImageFilter self, Image image1)



        Execute the filter on the input image


        """
        return _SimpleITK.MinimumMaximumImageFilter_Execute(self, image1)

MinimumMaximumImageFilter_swigregister = _SimpleITK.MinimumMaximumImageFilter_swigregister
MinimumMaximumImageFilter_swigregister(MinimumMaximumImageFilter)

class MinimumProjectionImageFilter(ImageFilter_1):
    """


    Minimum projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     StandardDeviationProjectionImageFilter

     SumProjectionImageFilter

     BinaryProjectionImageFilter

     MaximumProjectionImageFilter

     MeanProjectionImageFilter

     itk::simple::MinimumProjection for the procedural interface

     itk::MinimumProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMinimumProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinimumProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinimumProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MinimumProjectionImageFilter self) -> MinimumProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MinimumProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MinimumProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(MinimumProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.MinimumProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(MinimumProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.MinimumProjectionImageFilter_GetProjectionDimension(self)


    def GetName(self):
        """
        GetName(MinimumProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MinimumProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MinimumProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MinimumProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MinimumProjectionImageFilter self, Image image1) -> Image
        Execute(MinimumProjectionImageFilter self, Image image1, unsigned int projectionDimension) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MinimumProjectionImageFilter_Execute(self, *args)

MinimumProjectionImageFilter_swigregister = _SimpleITK.MinimumProjectionImageFilter_swigregister
MinimumProjectionImageFilter_swigregister(MinimumProjectionImageFilter)


def MinimumProjection(image1, projectionDimension=0):
    """
    MinimumProjection(Image image1, unsigned int projectionDimension=0) -> Image



    Minimum projection.


    This function directly calls the execute method of MinimumProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::MinimumProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.MinimumProjection(image1, projectionDimension)
class MirrorPadImageFilter(ImageFilter_1):
    """


    Increase the image size by padding with replicants of the input image
    value.


    MirrorPadImageFilter changes the image bounds of an image. Any added pixels are filled in
    with a mirrored replica of the input image. For instance, if the
    output image needs a pixel that is two pixels to the left of the
    LargestPossibleRegion of the input image, the value assigned will be
    from the pixel two pixels inside the left boundary of the
    LargestPossibleRegion. The image bounds of the output must be
    specified.

    Visual explanation of padding regions. This filter is implemented as a
    multithreaded filter. It provides a ThreadedGenerateData() method for
    its implementation.


    See:
     WrapPadImageFilter , ConstantPadImageFilter
    Wiki Examples:

    All Examples

    Pad an image using mirroring over the boundaries
    See:
     itk::simple::MirrorPad for the procedural interface

     itk::MirrorPadImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMirrorPadImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MirrorPadImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MirrorPadImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MirrorPadImageFilter self) -> MirrorPadImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MirrorPadImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MirrorPadImageFilter
    __del__ = lambda self: None

    def SetPadLowerBound(self, PadLowerBound):
        """
        SetPadLowerBound(MirrorPadImageFilter self, VectorUInt32 PadLowerBound)



        """
        return _SimpleITK.MirrorPadImageFilter_SetPadLowerBound(self, PadLowerBound)


    def GetPadLowerBound(self):
        """
        GetPadLowerBound(MirrorPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.MirrorPadImageFilter_GetPadLowerBound(self)


    def SetPadUpperBound(self, PadUpperBound):
        """
        SetPadUpperBound(MirrorPadImageFilter self, VectorUInt32 PadUpperBound)



        """
        return _SimpleITK.MirrorPadImageFilter_SetPadUpperBound(self, PadUpperBound)


    def GetPadUpperBound(self):
        """
        GetPadUpperBound(MirrorPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.MirrorPadImageFilter_GetPadUpperBound(self)


    def GetName(self):
        """
        GetName(MirrorPadImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MirrorPadImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MirrorPadImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MirrorPadImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MirrorPadImageFilter self, Image image1) -> Image
        Execute(MirrorPadImageFilter self, Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MirrorPadImageFilter_Execute(self, *args)

MirrorPadImageFilter_swigregister = _SimpleITK.MirrorPadImageFilter_swigregister
MirrorPadImageFilter_swigregister(MirrorPadImageFilter)


def MirrorPad(*args, **kwargs):
    """
    MirrorPad(Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) -> Image



    Increase the image size by padding with replicants of the input image
    value.


    This function directly calls the execute method of MirrorPadImageFilter in order to support a procedural API


    See:
     itk::simple::MirrorPadImageFilter for the object oriented interface



    """
    return _SimpleITK.MirrorPad(*args, **kwargs)
class ModulusImageFilter(ImageFilter_2):
    """


    Computes the modulus (x % dividend) pixel-wise.


    The input pixel type must support the c++ modulus operator (%).

    If the dividend is zero, the maximum value will be returned.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     itk::simple::Modulus for the procedural interface

     itk::ModulusImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkModulusImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModulusImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModulusImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ModulusImageFilter self) -> ModulusImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ModulusImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ModulusImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(ModulusImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ModulusImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ModulusImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ModulusImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ModulusImageFilter self, Image image1, Image image2) -> Image
        Execute(ModulusImageFilter self, Image image1, uint32_t constant) -> Image
        Execute(ModulusImageFilter self, uint32_t constant, Image image2) -> Image



        """
        return _SimpleITK.ModulusImageFilter_Execute(self, *args)

ModulusImageFilter_swigregister = _SimpleITK.ModulusImageFilter_swigregister
ModulusImageFilter_swigregister(ModulusImageFilter)


def Modulus(*args):
    """
    Modulus(Image image1, Image image2) -> Image
    Modulus(Image image1, uint32_t constant) -> Image
    Modulus(uint32_t constant, Image image2) -> Image



    """
    return _SimpleITK.Modulus(*args)
class MomentsThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Moments Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the MomentsThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::MomentsThreshold for the procedural interface

     itk::MomentsThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMomentsThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MomentsThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MomentsThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MomentsThresholdImageFilter self) -> MomentsThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MomentsThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MomentsThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(MomentsThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(MomentsThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(MomentsThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(MomentsThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(MomentsThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(MomentsThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.MomentsThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(MomentsThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(MomentsThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.MomentsThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(MomentsThresholdImageFilter self)



        """
        return _SimpleITK.MomentsThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(MomentsThresholdImageFilter self) -> bool



        """
        return _SimpleITK.MomentsThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(MomentsThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.MomentsThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(MomentsThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.MomentsThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(MomentsThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(MomentsThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MomentsThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MomentsThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MomentsThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MomentsThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(MomentsThresholdImageFilter self, Image image) -> Image
        Execute(MomentsThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(MomentsThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.MomentsThresholdImageFilter_Execute(self, *args)

MomentsThresholdImageFilter_swigregister = _SimpleITK.MomentsThresholdImageFilter_swigregister
MomentsThresholdImageFilter_swigregister(MomentsThresholdImageFilter)


def MomentsThreshold(*args):
    """
    MomentsThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    MomentsThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.MomentsThreshold(*args)
class MorphologicalGradientImageFilter(ImageFilter_1):
    """


    gray scale dilation of an image


    Dilate an image using grayscale morphology. Dilation takes the maximum
    of all the pixels identified by the structuring element.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.


    See:
     MorphologyImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter

     itk::simple::MorphologicalGradient for the procedural interface

     itk::MorphologicalGradientImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMorphologicalGradientImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MorphologicalGradientImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MorphologicalGradientImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MorphologicalGradientImageFilter self) -> MorphologicalGradientImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MorphologicalGradientImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MorphologicalGradientImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.MorphologicalGradientImageFilter_Annulus
    Ball = _SimpleITK.MorphologicalGradientImageFilter_Ball
    Box = _SimpleITK.MorphologicalGradientImageFilter_Box
    Cross = _SimpleITK.MorphologicalGradientImageFilter_Cross

    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(MorphologicalGradientImageFilter self, uint32_t r)
        SetKernelRadius(MorphologicalGradientImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.MorphologicalGradientImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(MorphologicalGradientImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.MorphologicalGradientImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(MorphologicalGradientImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.MorphologicalGradientImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(MorphologicalGradientImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.MorphologicalGradientImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(MorphologicalGradientImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MorphologicalGradientImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MorphologicalGradientImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MorphologicalGradientImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(MorphologicalGradientImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.MorphologicalGradientImageFilter_Execute(self, image1)

MorphologicalGradientImageFilter_swigregister = _SimpleITK.MorphologicalGradientImageFilter_swigregister
MorphologicalGradientImageFilter_swigregister(MorphologicalGradientImageFilter)


def MorphologicalGradient(*args):
    """
    MorphologicalGradient(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel) -> Image
    MorphologicalGradient(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel) -> Image



    itk::simple::MorphologicalGradientImageFilter Functional Interface

    This function directly calls the execute method of MorphologicalGradientImageFilter in order to support a fully functional API


    """
    return _SimpleITK.MorphologicalGradient(*args)
class MorphologicalWatershedFromMarkersImageFilter(ImageFilter_0):
    """


    Morphological watershed transform from markers.


    The watershed transform is a tool for image segmentation that is fast
    and flexible and potentially fairly parameter free. It was originally
    derived from a geophysical model of rain falling on a terrain and a
    variety of more formal definitions have been devised to allow
    development of practical algorithms. If an image is considered as a
    terrain and divided into catchment basins then the hope is that each
    catchment basin would contain an object of interest.

    The output is a label image. A label image, sometimes referred to as a
    categorical image, has unique values for each region. For example, if
    a watershed produces 2 regions, all pixels belonging to one region
    would have value A, and all belonging to the other might have value B.
    Unassigned pixels, such as watershed lines, might have the background
    value (0 by convention).

    The simplest way of using the watershed is to preprocess the image we
    want to segment so that the boundaries of our objects are bright (e.g
    apply an edge detector) and compute the watershed transform of the
    edge image. Watershed lines will correspond to the boundaries and our
    problem will be solved. This is rarely useful in practice because
    there are always more regional minima than there are objects, either
    due to noise or natural variations in the object surfaces. Therefore,
    while many watershed lines do lie on significant boundaries, there are
    many that don't. Various methods can be used to reduce the number of
    minima in the image, like thresholding the smallest values, filtering
    the minima and/or smoothing the image.

    This filter use another approach to avoid the problem of over
    segmentation: it let the user provide a marker image which mark the
    minima in the input image and give them a label. The minima are
    imposed in the input image by the markers. The labels of the output
    image are the label of the marker image.

    The morphological watershed transform algorithm is described in
    Chapter 9.2 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.

    This code was contributed in the Insight Journal paper: "The
    watershed transform in ITK - discussion and new developments" by
    Beare R., Lehmann G. https://hdl.handle.net/1926/202 http://www.insight-journal.org/browse/publication/92


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.
     Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.


    See:
     WatershedImageFilter , MorphologicalWatershedImageFilter

     itk::simple::MorphologicalWatershedFromMarkers for the procedural interface

     itk::MorphologicalWatershedFromMarkersImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMorphologicalWatershedFromMarkersImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MorphologicalWatershedFromMarkersImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MorphologicalWatershedFromMarkersImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MorphologicalWatershedFromMarkersImageFilter self) -> MorphologicalWatershedFromMarkersImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MorphologicalWatershedFromMarkersImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MorphologicalWatershedFromMarkersImageFilter
    __del__ = lambda self: None

    def SetMarkWatershedLine(self, MarkWatershedLine):
        """
        SetMarkWatershedLine(MorphologicalWatershedFromMarkersImageFilter self, bool MarkWatershedLine)



        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_SetMarkWatershedLine(self, MarkWatershedLine)


    def MarkWatershedLineOn(self):
        """
        MarkWatershedLineOn(MorphologicalWatershedFromMarkersImageFilter self)



        Set the value of MarkWatershedLine to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_MarkWatershedLineOn(self)


    def MarkWatershedLineOff(self):
        """
        MarkWatershedLineOff(MorphologicalWatershedFromMarkersImageFilter self)



        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_MarkWatershedLineOff(self)


    def GetMarkWatershedLine(self):
        """
        GetMarkWatershedLine(MorphologicalWatershedFromMarkersImageFilter self) -> bool



        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_GetMarkWatershedLine(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(MorphologicalWatershedFromMarkersImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(MorphologicalWatershedFromMarkersImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(MorphologicalWatershedFromMarkersImageFilter self)



        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(MorphologicalWatershedFromMarkersImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(MorphologicalWatershedFromMarkersImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MorphologicalWatershedFromMarkersImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MorphologicalWatershedFromMarkersImageFilter self, Image image, Image markerImage) -> Image
        Execute(MorphologicalWatershedFromMarkersImageFilter self, Image image, Image markerImage, bool markWatershedLine, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_Execute(self, *args)

MorphologicalWatershedFromMarkersImageFilter_swigregister = _SimpleITK.MorphologicalWatershedFromMarkersImageFilter_swigregister
MorphologicalWatershedFromMarkersImageFilter_swigregister(MorphologicalWatershedFromMarkersImageFilter)


def MorphologicalWatershedFromMarkers(image, markerImage, markWatershedLine=True, fullyConnected=False):
    """
    MorphologicalWatershedFromMarkers(Image image, Image markerImage, bool markWatershedLine=True, bool fullyConnected=False) -> Image



    Morphological watershed transform from markers.


    This function directly calls the execute method of MorphologicalWatershedFromMarkersImageFilter in order to support a procedural API


    See:
     itk::simple::MorphologicalWatershedFromMarkersImageFilter for the object oriented interface



    """
    return _SimpleITK.MorphologicalWatershedFromMarkers(image, markerImage, markWatershedLine, fullyConnected)
class MorphologicalWatershedImageFilter(ImageFilter_1):
    """


    TODO.


    TODO

    Watershed pixel are labeled 0. TOutputImage should be an integer type.
    Labels of output image are in no particular order. You can reorder the
    labels such that object labels are consecutive and sorted based on
    object size by passing the output of this filter to a RelabelComponentImageFilter .

    The morphological watershed transform algorithm is described in
    Chapter 9.2 of Pierre Soille's book "Morphological Image Analysis:
    Principles and Applications", Second Edition, Springer, 2003.

    This code was contributed in the Insight Journal paper: "The
    watershed transform in ITK - discussion and new developments" by
    Beare R., Lehmann G. https://hdl.handle.net/1926/202 http://www.insight-journal.org/browse/publication/92


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     WatershedImageFilter , MorphologicalWatershedFromMarkersImageFilter

     itk::simple::MorphologicalWatershed for the procedural interface

     itk::MorphologicalWatershedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkMorphologicalWatershedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MorphologicalWatershedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MorphologicalWatershedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MorphologicalWatershedImageFilter self) -> MorphologicalWatershedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MorphologicalWatershedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MorphologicalWatershedImageFilter
    __del__ = lambda self: None

    def SetLevel(self, Level):
        """
        SetLevel(MorphologicalWatershedImageFilter self, double Level)



        """
        return _SimpleITK.MorphologicalWatershedImageFilter_SetLevel(self, Level)


    def GetLevel(self):
        """
        GetLevel(MorphologicalWatershedImageFilter self) -> double



        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetLevel(self)


    def SetMarkWatershedLine(self, MarkWatershedLine):
        """
        SetMarkWatershedLine(MorphologicalWatershedImageFilter self, bool MarkWatershedLine)



        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_SetMarkWatershedLine(self, MarkWatershedLine)


    def MarkWatershedLineOn(self):
        """
        MarkWatershedLineOn(MorphologicalWatershedImageFilter self)



        Set the value of MarkWatershedLine to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_MarkWatershedLineOn(self)


    def MarkWatershedLineOff(self):
        """
        MarkWatershedLineOff(MorphologicalWatershedImageFilter self)



        """
        return _SimpleITK.MorphologicalWatershedImageFilter_MarkWatershedLineOff(self)


    def GetMarkWatershedLine(self):
        """
        GetMarkWatershedLine(MorphologicalWatershedImageFilter self) -> bool



        Set/Get whether the watershed pixel must be marked or not. Default is
        true. Set it to false do not only avoid writing watershed pixels, it
        also decrease algorithm complexity.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetMarkWatershedLine(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(MorphologicalWatershedImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(MorphologicalWatershedImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(MorphologicalWatershedImageFilter self)



        """
        return _SimpleITK.MorphologicalWatershedImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(MorphologicalWatershedImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(MorphologicalWatershedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MorphologicalWatershedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MorphologicalWatershedImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MorphologicalWatershedImageFilter self, Image image1) -> Image
        Execute(MorphologicalWatershedImageFilter self, Image image1, double level, bool markWatershedLine, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.MorphologicalWatershedImageFilter_Execute(self, *args)

MorphologicalWatershedImageFilter_swigregister = _SimpleITK.MorphologicalWatershedImageFilter_swigregister
MorphologicalWatershedImageFilter_swigregister(MorphologicalWatershedImageFilter)


def MorphologicalWatershed(image1, level=0.0, markWatershedLine=True, fullyConnected=False):
    """
    MorphologicalWatershed(Image image1, double level=0.0, bool markWatershedLine=True, bool fullyConnected=False) -> Image



    TODO.


    This function directly calls the execute method of MorphologicalWatershedImageFilter in order to support a procedural API


    See:
     itk::simple::MorphologicalWatershedImageFilter for the object oriented interface



    """
    return _SimpleITK.MorphologicalWatershed(image1, level, markWatershedLine, fullyConnected)
class MultiLabelSTAPLEImageFilter(ImageFilter_3):
    """


    This filter performs a pixelwise combination of an arbitrary number of
    input images, where each of them represents a segmentation of the same
    scene (i.e., image).


    The labelings in the images are weighted relative to each other based
    on their "performance" as estimated by an expectation-maximization
    algorithm. In the process, a ground truth segmentation is estimated,
    and the estimated performances of the individual segmentations are
    relative to this estimated ground truth.

    The algorithm is based on the binary STAPLE algorithm by Warfield et
    al. as published originally in

    S. Warfield, K. Zou, W. Wells, "Validation of image segmentation and
    expert quality with an expectation-maximization algorithm" in MICCAI
    2002: Fifth International Conference on Medical Image Computing and Computer-Assisted Intervention, Springer-Verlag,
    Heidelberg, Germany, 2002, pp. 298-306

    The multi-label algorithm implemented here is described in detail in

    T. Rohlfing, D. B. Russakoff, and C. R. Maurer, Jr., "Performance-
    based classifier combination in atlas-based image segmentation using
    expectation-maximization parameter estimation," IEEE Transactions on
    Medical Imaging, vol. 23, pp. 983-994, Aug. 2004.

    INPUTS
    All input volumes to this filter must be segmentations of an image,
    that is, they must have discrete pixel values where each value
    represents a different segmented object.
     Input volumes must all contain the same size RequestedRegions. Not all input images must contain all possible labels, but all label
    values must have the same meaning in all images.

    The filter can optionally be provided with estimates for the a priori
    class probabilities through the SetPriorProbabilities function. If no
    estimate is provided, one is automatically generated by analyzing the
    relative frequencies of the labels in the input images.

    OUTPUTS
    The filter produces a single output volume. Each output pixel contains
    the label that has the highest probability of being the correct label,
    based on the performance models of the individual segmentations. If
    the maximum probaility is not unique, i.e., if more than one label
    have a maximum probability, then an "undecided" label is assigned to
    that output pixel.
     By default, the label used for undecided pixels is the maximum label
    value used in the input images plus one. Since it is possible for an
    image with 8 bit pixel values to use all 256 possible label values, it
    is permissible to combine 8 bit (i.e., byte) images into a 16 bit
    (i.e., short) output image.

    In addition to the combined image, the estimated confusion matrices
    for each of the input segmentations can be obtained through the
    GetConfusionMatrix member function.

    PARAMETERS
    The label used for "undecided" labels can be set using
    SetLabelForUndecidedPixels. This functionality can be unset by calling
    UnsetLabelForUndecidedPixels.
     A termination threshold for the EM iteration can be defined by
    calling SetTerminationUpdateThreshold. The iteration terminates once
    no single parameter of any confusion matrix changes by less than this
    threshold. Alternatively, a maximum number of iterations can be
    specified by calling SetMaximumNumberOfIterations. The algorithm may
    still terminate after a smaller number of iterations if the
    termination threshold criterion is satisfied.

    EVENTS
    This filter invokes IterationEvent() at each iteration of the E-M
    algorithm. Setting the AbortGenerateData() flag will cause the
    algorithm to halt after the current iteration and produce results just
    as if it had converged. The algorithm makes no attempt to report its
    progress since the number of iterations needed cannot be known in
    advance.

    Torsten Rohlfing, SRI International, Neuroscience Program

    See:
     itk::simple::MultiLabelSTAPLE for the procedural interface


    C++ includes: sitkMultiLabelSTAPLEImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiLabelSTAPLEImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiLabelSTAPLEImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MultiLabelSTAPLEImageFilter self) -> MultiLabelSTAPLEImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MultiLabelSTAPLEImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MultiLabelSTAPLEImageFilter
    __del__ = lambda self: None

    def SetLabelForUndecidedPixels(self, LabelForUndecidedPixels):
        """
        SetLabelForUndecidedPixels(MultiLabelSTAPLEImageFilter self, uint64_t LabelForUndecidedPixels)



        Set label value for undecided pixels.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetLabelForUndecidedPixels(self, LabelForUndecidedPixels)


    def GetLabelForUndecidedPixels(self):
        """
        GetLabelForUndecidedPixels(MultiLabelSTAPLEImageFilter self) -> uint64_t



             Get label value used for undecided pixels.

        After updating the filter, this function returns the actual label
        value used for undecided pixels in the current output. Note that this
        value is overwritten when SetLabelForUndecidedPixels is called and the
        new value only becomes effective upon the next filter update.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetLabelForUndecidedPixels(self)


    def SetTerminationUpdateThreshold(self, TerminationUpdateThreshold):
        """
        SetTerminationUpdateThreshold(MultiLabelSTAPLEImageFilter self, float TerminationUpdateThreshold)



        Set termination threshold based on confusion matrix parameter updates.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetTerminationUpdateThreshold(self, TerminationUpdateThreshold)


    def GetTerminationUpdateThreshold(self):
        """
        GetTerminationUpdateThreshold(MultiLabelSTAPLEImageFilter self) -> float



        Set termination threshold based on confusion matrix parameter updates.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetTerminationUpdateThreshold(self)


    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        """
        SetMaximumNumberOfIterations(MultiLabelSTAPLEImageFilter self, unsigned int MaximumNumberOfIterations)



        Set maximum number of iterations.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetMaximumNumberOfIterations(self, MaximumNumberOfIterations)


    def GetMaximumNumberOfIterations(self):
        """
        GetMaximumNumberOfIterations(MultiLabelSTAPLEImageFilter self) -> unsigned int



        Set maximum number of iterations.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetMaximumNumberOfIterations(self)


    def SetPriorProbabilities(self, PriorProbabilities):
        """
        SetPriorProbabilities(MultiLabelSTAPLEImageFilter self, VectorFloat PriorProbabilities)



            Set manual estimates for the a priori class probabilities. The
        size of the array must be greater than the value of the largest label. The index into the array corresponds to the label
        value in the segmented image for the class.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_SetPriorProbabilities(self, PriorProbabilities)


    def GetPriorProbabilities(self):
        """
        GetPriorProbabilities(MultiLabelSTAPLEImageFilter self) -> VectorFloat



             Get prior class probabilities.

        After updating the filter, this function returns the actual prior
        class probabilities. If these were not previously set by a call to
        SetPriorProbabilities, then they are estimated from the input
        segmentations and the result is available through this function.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetPriorProbabilities(self)


    def GetConfusionMatrix(self, input):
        """
        GetConfusionMatrix(MultiLabelSTAPLEImageFilter self, unsigned int input) -> VectorFloat



        Get confusion matrix for the i-th input segmentation.

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetConfusionMatrix(self, input)


    def GetName(self):
        """
        GetName(MultiLabelSTAPLEImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MultiLabelSTAPLEImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MultiLabelSTAPLEImageFilter self, VectorOfImage images) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, VectorOfImage images, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
        Execute(MultiLabelSTAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image



        """
        return _SimpleITK.MultiLabelSTAPLEImageFilter_Execute(self, *args)

MultiLabelSTAPLEImageFilter_swigregister = _SimpleITK.MultiLabelSTAPLEImageFilter_swigregister
MultiLabelSTAPLEImageFilter_swigregister(MultiLabelSTAPLEImageFilter)


def MultiLabelSTAPLE(*args):
    """
    MultiLabelSTAPLE(VectorOfImage images, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
    MultiLabelSTAPLE(Image image1, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, Image image3, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, Image image3, Image image4, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
    MultiLabelSTAPLE(Image image1, Image image2, Image image3, Image image4, Image image5, uint64_t labelForUndecidedPixels, float terminationUpdateThreshold=1e-5, unsigned int maximumNumberOfIterations, VectorFloat priorProbabilities) -> Image
    """
    return _SimpleITK.MultiLabelSTAPLE(*args)
class MultiplyImageFilter(ImageFilter_2):
    """


    Pixel-wise multiplication of two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Wiki Examples:

    All Examples

    Multiply two images together

    Multiply every pixel in an image by a constant
    See:
     itk::simple::Multiply for the procedural interface

     itk::MultiplyImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkMultiplyImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiplyImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiplyImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::MultiplyImageFilter self) -> MultiplyImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_MultiplyImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_MultiplyImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(MultiplyImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.MultiplyImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(MultiplyImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.MultiplyImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(MultiplyImageFilter self, Image image1, Image image2) -> Image
        Execute(MultiplyImageFilter self, Image image1, double constant) -> Image
        Execute(MultiplyImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.MultiplyImageFilter_Execute(self, *args)

MultiplyImageFilter_swigregister = _SimpleITK.MultiplyImageFilter_swigregister
MultiplyImageFilter_swigregister(MultiplyImageFilter)


def Multiply(*args):
    """
    Multiply(Image image1, Image image2) -> Image
    Multiply(Image image1, double constant) -> Image
    Multiply(double constant, Image image2) -> Image



    """
    return _SimpleITK.Multiply(*args)
class N4BiasFieldCorrectionImageFilter(ImageFilter_0):
    """


    Implementation of the N4 bias field correction algorithm.


    The nonparametric nonuniform intensity normalization (N3) algorithm,
    as introduced by Sled et al. in 1998 is a method for correcting
    nonuniformity associated with MR images. The algorithm assumes a
    simple parametric model (Gaussian) for the bias field and does not
    require tissue class segmentation. In addition, there are only a
    couple of parameters to tune with the default values performing quite
    well. N3 has been publicly available as a set of perl scripts ( http://www.bic.mni.mcgill.ca/ServicesSoftwareAdvancedImageProcessingTo
    ols/HomePage )

    The N4 algorithm, encapsulated with this class, is a variation of the
    original N3 algorithm with the additional benefits of an improved
    B-spline fitting routine which allows for multiple resolutions to be
    used during the correction process. We also modify the iterative
    update component of algorithm such that the residual bias field is
    continually updated

    Notes for the user:
    Since much of the image manipulation is done in the log space of the
    intensities, input images with negative and small values (< 1) can
    produce poor results.

    The original authors recommend performing the bias field correction on
    a downsampled version of the original image.

    A binary mask or a weighted image can be supplied. If a binary mask is
    specified, those voxels in the input image which correspond to the
    voxels in the mask image are used to estimate the bias field. If a
    UseMaskLabel value is set to true, only voxels in the MaskImage that
    match the MaskLabel will be used; otherwise, all non-zero voxels in
    the MaskImage will be masked. If a confidence image is specified, the
    input voxels are weighted in the b-spline fitting routine according to
    the confidence voxel values.

    The filter returns the corrected image. If the bias field is wanted,
    one can reconstruct it using the class
    itkBSplineControlPointImageFilter. See the IJ article and the test
    file for an example.

    The 'Z' parameter in Sled's 1998 paper is the square root of the class
    variable 'm_WienerFilterNoise'.
     The basic algorithm iterates between sharpening the intensity
    histogram of the corrected input image and spatially smoothing those
    results with a B-spline scalar field estimate of the bias field.


    Nicholas J. Tustison
     Contributed by Nicholas J. Tustison, James C. Gee in the Insight
    Journal paper: https://hdl.handle.net/10380/3053

    REFERENCE
     J.G. Sled, A.P. Zijdenbos and A.C. Evans. "A Nonparametric Method
    for Automatic Correction of Intensity Nonuniformity in Data" IEEE
    Transactions on Medical Imaging, Vol 17, No 1. Feb 1998.

    N.J. Tustison, B.B. Avants, P.A. Cook, Y. Zheng, A. Egan, P.A.
    Yushkevich, and J.C. Gee. "N4ITK: Improved N3 Bias Correction" IEEE
    Transactions on Medical Imaging, 29(6):1310-1320, June 2010.
    See:
     itk::simple::N4BiasFieldCorrection for the procedural interface

     itk::N4BiasFieldCorrectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkN4BiasFieldCorrectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, N4BiasFieldCorrectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, N4BiasFieldCorrectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::N4BiasFieldCorrectionImageFilter self) -> N4BiasFieldCorrectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_N4BiasFieldCorrectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_N4BiasFieldCorrectionImageFilter
    __del__ = lambda self: None

    def SetConvergenceThreshold(self, ConvergenceThreshold):
        """
        SetConvergenceThreshold(N4BiasFieldCorrectionImageFilter self, double ConvergenceThreshold)



        Set the convergence threshold. Convergence is determined by the
        coefficient of variation of the difference image between the current
        bias field estimate and the previous estimate. If this value is less
        than the specified threshold, the algorithm proceeds to the next
        fitting level or terminates if it is at the last level.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetConvergenceThreshold(self, ConvergenceThreshold)


    def GetConvergenceThreshold(self):
        """
        GetConvergenceThreshold(N4BiasFieldCorrectionImageFilter self) -> double



        Get the convergence threshold. Convergence is determined by the
        coefficient of variation of the difference image between the current
        bias field estimate and the previous estimate. If this value is less
        than the specified threshold, the algorithm proceeds to the next
        fitting level or terminates if it is at the last level.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetConvergenceThreshold(self)


    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        """
        SetMaximumNumberOfIterations(N4BiasFieldCorrectionImageFilter self, VectorUInt32 MaximumNumberOfIterations)



        Set the maximum number of iterations specified at each fitting level.
        Default = 50.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetMaximumNumberOfIterations(self, MaximumNumberOfIterations)


    def GetMaximumNumberOfIterations(self):
        """
        GetMaximumNumberOfIterations(N4BiasFieldCorrectionImageFilter self) -> VectorUInt32



        Get the maximum number of iterations specified at each fitting level.
        Default = 50.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetMaximumNumberOfIterations(self)


    def SetBiasFieldFullWidthAtHalfMaximum(self, BiasFieldFullWidthAtHalfMaximum):
        """
        SetBiasFieldFullWidthAtHalfMaximum(N4BiasFieldCorrectionImageFilter self, double BiasFieldFullWidthAtHalfMaximum)



        Set the full width at half maximum parameter characterizing the width
        of the Gaussian deconvolution. Default = 0.15.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetBiasFieldFullWidthAtHalfMaximum(self, BiasFieldFullWidthAtHalfMaximum)


    def GetBiasFieldFullWidthAtHalfMaximum(self):
        """
        GetBiasFieldFullWidthAtHalfMaximum(N4BiasFieldCorrectionImageFilter self) -> double



        Get the full width at half maximum parameter characterizing the width
        of the Gaussian deconvolution. Default = 0.15.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetBiasFieldFullWidthAtHalfMaximum(self)


    def SetWienerFilterNoise(self, WienerFilterNoise):
        """
        SetWienerFilterNoise(N4BiasFieldCorrectionImageFilter self, double WienerFilterNoise)



        Set the noise estimate defining the Wiener filter. Default = 0.01.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetWienerFilterNoise(self, WienerFilterNoise)


    def GetWienerFilterNoise(self):
        """
        GetWienerFilterNoise(N4BiasFieldCorrectionImageFilter self) -> double



        Get the noise estimate defining the Wiener filter. Default = 0.01.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetWienerFilterNoise(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(N4BiasFieldCorrectionImageFilter self, uint32_t NumberOfHistogramBins)



        Set number of bins defining the log input intensity histogram. Default
        = 200.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(N4BiasFieldCorrectionImageFilter self) -> uint32_t



        Get number of bins defining the log input intensity histogram. Default
        = 200.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetNumberOfHistogramBins(self)


    def SetNumberOfControlPoints(self, *args):
        """
        SetNumberOfControlPoints(N4BiasFieldCorrectionImageFilter self, VectorUInt32 NumberOfControlPoints)
        SetNumberOfControlPoints(N4BiasFieldCorrectionImageFilter self, uint32_t value)



        Set the values of the NumberOfControlPoints vector all to value


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetNumberOfControlPoints(self, *args)


    def GetNumberOfControlPoints(self):
        """
        GetNumberOfControlPoints(N4BiasFieldCorrectionImageFilter self) -> VectorUInt32



        Get the control point grid size defining the B-spline estimate of the
        scalar bias field. In each dimension, the B-spline mesh size is equal
        to the number of control points in that dimension minus the spline
        order. Default = 4 control points in each dimension for a mesh size of
        1 in each dimension.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetNumberOfControlPoints(self)


    def SetSplineOrder(self, SplineOrder):
        """
        SetSplineOrder(N4BiasFieldCorrectionImageFilter self, uint32_t SplineOrder)



        Set the spline order defining the bias field estimate. Default = 3.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_SetSplineOrder(self, SplineOrder)


    def GetSplineOrder(self):
        """
        GetSplineOrder(N4BiasFieldCorrectionImageFilter self) -> uint32_t



        Get the spline order defining the bias field estimate. Default = 3.


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetSplineOrder(self)


    def GetName(self):
        """
        GetName(N4BiasFieldCorrectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(N4BiasFieldCorrectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(N4BiasFieldCorrectionImageFilter self, Image image, Image maskImage) -> Image
        Execute(N4BiasFieldCorrectionImageFilter self, Image image, Image maskImage, double convergenceThreshold, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum, double wienerFilterNoise, uint32_t numberOfHistogramBins, VectorUInt32 numberOfControlPoints, uint32_t splineOrder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.N4BiasFieldCorrectionImageFilter_Execute(self, *args)

N4BiasFieldCorrectionImageFilter_swigregister = _SimpleITK.N4BiasFieldCorrectionImageFilter_swigregister
N4BiasFieldCorrectionImageFilter_swigregister(N4BiasFieldCorrectionImageFilter)


def N4BiasFieldCorrection(*args, **kwargs):
    """
    N4BiasFieldCorrection(Image image, Image maskImage, double convergenceThreshold=0.001, VectorUInt32 maximumNumberOfIterations, double biasFieldFullWidthAtHalfMaximum=0.15, double wienerFilterNoise=0.01, uint32_t numberOfHistogramBins=200, VectorUInt32 numberOfControlPoints, uint32_t splineOrder=3) -> Image



    Implementation of the N4 bias field correction algorithm.


    This function directly calls the execute method of N4BiasFieldCorrectionImageFilter in order to support a procedural API


    See:
     itk::simple::N4BiasFieldCorrectionImageFilter for the object oriented interface



    """
    return _SimpleITK.N4BiasFieldCorrection(*args, **kwargs)
class NaryAddImageFilter(ImageFilter_3):
    """


    Pixel-wise addition of N images.


    This class is templated over the types of the input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The pixel type of the input images must have a valid definition of the
    operator+ with each other. This condition is required because
    internally this filter will perform the operation


    Additionally the type resulting from the sum, will be cast to the
    pixel type of the output image.

    The total operation over one pixel will be


    For example, this filter could be used directly for adding images
    whose pixels are vectors of the same dimension, and to store the
    resulting vector in an output image of vector pixels.


    WARNING:
    No numeric overflow checking is performed in this filter.

    See:
     itk::simple::NaryAdd for the procedural interface


    C++ includes: sitkNaryAddImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NaryAddImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NaryAddImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NaryAddImageFilter self) -> NaryAddImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NaryAddImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NaryAddImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(NaryAddImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NaryAddImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NaryAddImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NaryAddImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(NaryAddImageFilter self, VectorOfImage images) -> Image
        Execute(NaryAddImageFilter self, Image image1) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(NaryAddImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image



        """
        return _SimpleITK.NaryAddImageFilter_Execute(self, *args)

NaryAddImageFilter_swigregister = _SimpleITK.NaryAddImageFilter_swigregister
NaryAddImageFilter_swigregister(NaryAddImageFilter)


def NaryAdd(*args):
    """
    NaryAdd(VectorOfImage images) -> Image
    NaryAdd(Image image1) -> Image
    NaryAdd(Image image1, Image image2) -> Image
    NaryAdd(Image image1, Image image2, Image image3) -> Image
    NaryAdd(Image image1, Image image2, Image image3, Image image4) -> Image
    NaryAdd(Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
    """
    return _SimpleITK.NaryAdd(*args)
class NaryMaximumImageFilter(ImageFilter_3):
    """


    Computes the pixel-wise maximum of several images.


    This class is templated over the types of the input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The pixel type of the output images must have a valid definition of
    the operator<. This condition is required because internally this
    filter will perform an operation similar to:

     (where current_maximum is also of type OutputPixelType)

    for each of the n input images.

    For example, this filter could be used directly to find a "maximum
    projection" of a series of images, often used in preliminary analysis
    of time-series data.


    Zachary Pincus
     This filter was contributed by Zachary Pincus from the Department of
    Biochemistry and Program in Biomedical Informatics at Stanford
    University School of Medicine


    See:
     itk::simple::NaryMaximum for the procedural interface


    C++ includes: sitkNaryMaximumImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NaryMaximumImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NaryMaximumImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NaryMaximumImageFilter self) -> NaryMaximumImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NaryMaximumImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NaryMaximumImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(NaryMaximumImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NaryMaximumImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NaryMaximumImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NaryMaximumImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(NaryMaximumImageFilter self, VectorOfImage images) -> Image
        Execute(NaryMaximumImageFilter self, Image image1) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(NaryMaximumImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image



        """
        return _SimpleITK.NaryMaximumImageFilter_Execute(self, *args)

NaryMaximumImageFilter_swigregister = _SimpleITK.NaryMaximumImageFilter_swigregister
NaryMaximumImageFilter_swigregister(NaryMaximumImageFilter)


def NaryMaximum(*args):
    """
    NaryMaximum(VectorOfImage images) -> Image
    NaryMaximum(Image image1) -> Image
    NaryMaximum(Image image1, Image image2) -> Image
    NaryMaximum(Image image1, Image image2, Image image3) -> Image
    NaryMaximum(Image image1, Image image2, Image image3, Image image4) -> Image
    NaryMaximum(Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
    """
    return _SimpleITK.NaryMaximum(*args)
class NeighborhoodConnectedImageFilter(ImageFilter_1):
    """


    Label pixels that are connected to a seed and lie within a
    neighborhood.


    NeighborhoodConnectedImageFilter labels pixels with ReplaceValue that are connected to an initial Seed
    AND whose neighbors all lie within a Lower and Upper threshold range.
    See:
     itk::simple::NeighborhoodConnected for the procedural interface

     itk::NeighborhoodConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNeighborhoodConnectedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NeighborhoodConnectedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NeighborhoodConnectedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NeighborhoodConnectedImageFilter self) -> NeighborhoodConnectedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NeighborhoodConnectedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NeighborhoodConnectedImageFilter
    __del__ = lambda self: None

    def SetLower(self, Lower):
        """
        SetLower(NeighborhoodConnectedImageFilter self, double Lower)



        Set/Get the lower threshold. The default is 0.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetLower(self, Lower)


    def GetLower(self):
        """
        GetLower(NeighborhoodConnectedImageFilter self) -> double



        Set/Get the lower threshold. The default is 0.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetLower(self)


    def SetUpper(self, Upper):
        """
        SetUpper(NeighborhoodConnectedImageFilter self, double Upper)



        Set/Get the upper threshold. The default is the largest possible value
        for the InputPixelType.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetUpper(self, Upper)


    def GetUpper(self):
        """
        GetUpper(NeighborhoodConnectedImageFilter self) -> double



        Set/Get the upper threshold. The default is the largest possible value
        for the InputPixelType.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetUpper(self)


    def SetRadius(self, *args):
        """
        SetRadius(NeighborhoodConnectedImageFilter self, VectorUInt32 Radius)
        SetRadius(NeighborhoodConnectedImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(NeighborhoodConnectedImageFilter self) -> VectorUInt32



        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetRadius(self)


    def SetReplaceValue(self, ReplaceValue):
        """
        SetReplaceValue(NeighborhoodConnectedImageFilter self, double ReplaceValue)



        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetReplaceValue(self, ReplaceValue)


    def GetReplaceValue(self):
        """
        GetReplaceValue(NeighborhoodConnectedImageFilter self) -> double



        Set/Get value to replace thresholded pixels. Pixels that lie * within
        Lower and Upper (inclusive) will be replaced with this value. The
        default is 1.


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetReplaceValue(self)


    def SetSeedList(self, t):
        """
        SetSeedList(NeighborhoodConnectedImageFilter self, VectorUIntList t)



        Set SeedList


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetSeedList(self, t)


    def GetSeedList(self):
        """
        GetSeedList(NeighborhoodConnectedImageFilter self) -> VectorUIntList



        Get SeedList


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetSeedList(self)


    def ClearSeeds(self):
        """
        ClearSeeds(NeighborhoodConnectedImageFilter self)



        ClearSeeds - Clear out all seeds in the list


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_ClearSeeds(self)


    def SetSeed(self, idx):
        """
        SetSeed(NeighborhoodConnectedImageFilter self, VectorUInt32 idx)



        SetSeed - Set list to a single seed


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_SetSeed(self, idx)


    def AddSeed(self, idx):
        """
        AddSeed(NeighborhoodConnectedImageFilter self, VectorUInt32 idx)



        AddSeed - Add a seed to the end of the list


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_AddSeed(self, idx)


    def GetName(self):
        """
        GetName(NeighborhoodConnectedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NeighborhoodConnectedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(NeighborhoodConnectedImageFilter self, Image image1) -> Image
        Execute(NeighborhoodConnectedImageFilter self, Image image1, VectorUIntList seedList, double lower, double upper, VectorUInt32 radius, double replaceValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.NeighborhoodConnectedImageFilter_Execute(self, *args)

NeighborhoodConnectedImageFilter_swigregister = _SimpleITK.NeighborhoodConnectedImageFilter_swigregister
NeighborhoodConnectedImageFilter_swigregister(NeighborhoodConnectedImageFilter)


def NeighborhoodConnected(*args, **kwargs):
    """
    NeighborhoodConnected(Image image1, VectorUIntList seedList, double lower=0, double upper=1, VectorUInt32 radius, double replaceValue=1) -> Image



    itk::simple::NeighborhoodConnectedImageFilter Functional Interface

    This function directly calls the execute method of NeighborhoodConnectedImageFilter in order to support a fully functional API


    """
    return _SimpleITK.NeighborhoodConnected(*args, **kwargs)
class NoiseImageFilter(ImageFilter_1):
    """


    Calculate the local noise in an image.


    Computes an image where a given pixel is the standard deviation of the
    pixels in a neighborhood about the corresponding input pixel. This
    serves as an estimate of the local noise (or texture) in an image.
    Currently, this noise estimate assume a piecewise constant image. This
    filter should be extended to fitting a (hyper) plane to the
    neighborhood and calculating the standard deviation of the residuals
    to this (hyper) plane.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Compute the local noise in an image
    See:
     itk::simple::Noise for the procedural interface

     itk::NoiseImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkNoiseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoiseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoiseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NoiseImageFilter self) -> NoiseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NoiseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NoiseImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(NoiseImageFilter self, VectorUInt32 Radius)
        SetRadius(NoiseImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.NoiseImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(NoiseImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.NoiseImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(NoiseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NoiseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NoiseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NoiseImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(NoiseImageFilter self, Image image1) -> Image
        Execute(NoiseImageFilter self, Image image1, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.NoiseImageFilter_Execute(self, *args)

NoiseImageFilter_swigregister = _SimpleITK.NoiseImageFilter_swigregister
NoiseImageFilter_swigregister(NoiseImageFilter)


def Noise(*args, **kwargs):
    """
    Noise(Image image1, VectorUInt32 radius) -> Image



    Calculate the local noise in an image.


    This function directly calls the execute method of NoiseImageFilter in order to support a procedural API


    See:
     itk::simple::NoiseImageFilter for the object oriented interface



    """
    return _SimpleITK.Noise(*args, **kwargs)
class NormalizeImageFilter(ImageFilter_1):
    """


    Normalize an image by setting its mean to zero and variance to one.


    NormalizeImageFilter shifts and scales an image so that the pixels in the image have a
    zero mean and unit variance. This filter uses StatisticsImageFilter to compute the mean and variance of the input and then applies ShiftScaleImageFilter to shift and scale the pixels.

    NB: since this filter normalizes the data to lie within -1 to 1,
    integral types will produce an image that DOES NOT HAVE a unit
    variance.


    See:
     NormalizeToConstantImageFilter
    Wiki Examples:

    All Examples

    Normalize an image
    See:
     itk::simple::Normalize for the procedural interface

     itk::NormalizeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkNormalizeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormalizeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormalizeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NormalizeImageFilter self) -> NormalizeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NormalizeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NormalizeImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(NormalizeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NormalizeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NormalizeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NormalizeImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(NormalizeImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.NormalizeImageFilter_Execute(self, image1)

NormalizeImageFilter_swigregister = _SimpleITK.NormalizeImageFilter_swigregister
NormalizeImageFilter_swigregister(NormalizeImageFilter)


def Normalize(image1):
    """
    Normalize(Image image1) -> Image



    Normalize an image by setting its mean to zero and variance to one.


    This function directly calls the execute method of NormalizeImageFilter in order to support a procedural API


    See:
     itk::simple::NormalizeImageFilter for the object oriented interface



    """
    return _SimpleITK.Normalize(image1)
class NormalizeToConstantImageFilter(ImageFilter_1):
    """


    Scales image pixel intensities to make the sum of all pixels equal a
    user-defined constant.


    The default value of the constant is 1. It can be changed with SetConstant() .

    This transform is especially useful for normalizing a convolution
    kernel.

    This code was contributed in the Insight Journal paper: "FFT based
    convolution" by Lehmann G. https://hdl.handle.net/10380/3154


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     NormalizeImageFilter

     StatisticsImageFilter

     DivideImageFilter
    Wiki Examples:

    All Examples

    Scale all pixels so that their sum is a specified constant
    See:
     itk::simple::NormalizeToConstant for the procedural interface

     itk::NormalizeToConstantImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkNormalizeToConstantImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormalizeToConstantImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormalizeToConstantImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NormalizeToConstantImageFilter self) -> NormalizeToConstantImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NormalizeToConstantImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NormalizeToConstantImageFilter
    __del__ = lambda self: None

    def SetConstant(self, Constant):
        """
        SetConstant(NormalizeToConstantImageFilter self, double Constant)



        Set/get the normalization constant.


        """
        return _SimpleITK.NormalizeToConstantImageFilter_SetConstant(self, Constant)


    def GetConstant(self):
        """
        GetConstant(NormalizeToConstantImageFilter self) -> double



        Set/get the normalization constant.


        """
        return _SimpleITK.NormalizeToConstantImageFilter_GetConstant(self)


    def GetName(self):
        """
        GetName(NormalizeToConstantImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NormalizeToConstantImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NormalizeToConstantImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NormalizeToConstantImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(NormalizeToConstantImageFilter self, Image image1) -> Image
        Execute(NormalizeToConstantImageFilter self, Image image1, double constant) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.NormalizeToConstantImageFilter_Execute(self, *args)

NormalizeToConstantImageFilter_swigregister = _SimpleITK.NormalizeToConstantImageFilter_swigregister
NormalizeToConstantImageFilter_swigregister(NormalizeToConstantImageFilter)


def NormalizeToConstant(image1, constant=1.0):
    """
    NormalizeToConstant(Image image1, double constant=1.0) -> Image



    Scales image pixel intensities to make the sum of all pixels equal a
    user-defined constant.


    This function directly calls the execute method of NormalizeToConstantImageFilter in order to support a procedural API


    See:
     itk::simple::NormalizeToConstantImageFilter for the object oriented interface



    """
    return _SimpleITK.NormalizeToConstant(image1, constant)
class NormalizedCorrelationImageFilter(ImageFilter_0):
    """


    Computes the normalized correlation of an image and a template.


    This filter calculates the normalized correlation between an image and
    the template. Normalized correlation is frequently use in feature
    detection because it is invariant to local changes in contrast.

    The filter can be given a mask. When presented with an input image and
    a mask, the normalized correlation is only calculated at those pixels
    under the mask.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Normalized correlation
    See:
     itk::simple::NormalizedCorrelation for the procedural interface

     itk::NormalizedCorrelationImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkNormalizedCorrelationImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormalizedCorrelationImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormalizedCorrelationImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NormalizedCorrelationImageFilter self) -> NormalizedCorrelationImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NormalizedCorrelationImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NormalizedCorrelationImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(NormalizedCorrelationImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NormalizedCorrelationImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NormalizedCorrelationImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NormalizedCorrelationImageFilter___str__(self)


    def Execute(self, image, maskImage, templateImage):
        """
        Execute(NormalizedCorrelationImageFilter self, Image image, Image maskImage, Image templateImage) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.NormalizedCorrelationImageFilter_Execute(self, image, maskImage, templateImage)

NormalizedCorrelationImageFilter_swigregister = _SimpleITK.NormalizedCorrelationImageFilter_swigregister
NormalizedCorrelationImageFilter_swigregister(NormalizedCorrelationImageFilter)


def NormalizedCorrelation(image, maskImage, templateImage):
    """
    NormalizedCorrelation(Image image, Image maskImage, Image templateImage) -> Image



    Computes the normalized correlation of an image and a template.


    This function directly calls the execute method of NormalizedCorrelationImageFilter in order to support a procedural API


    See:
     itk::simple::NormalizedCorrelationImageFilter for the object oriented interface



    """
    return _SimpleITK.NormalizedCorrelation(image, maskImage, templateImage)
class NotEqualImageFilter(ImageFilter_2):
    """


    Implements pixel-wise generic operation of two images, or of an image
    and a constant.


    This class is parameterized over the types of the two input images and
    the type of the output image. It is also parameterized by the
    operation to be applied. A Functor style is used.

    The constant must be of the same type than the pixel type of the
    corresponding image. It is wrapped in a SimpleDataObjectDecorator so it can be updated through the pipeline. The SetConstant() and
    GetConstant() methods are provided as shortcuts to set or get the
    constant value without manipulating the decorator.


    See:
     UnaryFunctorImageFilter TernaryFunctorImageFilter
    Wiki Examples:

    All Examples

    Apply a predefined operation to corresponding pixels in two images

    Apply a custom operation to corresponding pixels in two images
    See:
     itk::simple::NotEqual for the procedural interface

     itk::BinaryFunctorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkNotEqualImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotEqualImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotEqualImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NotEqualImageFilter self) -> NotEqualImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NotEqualImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NotEqualImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(NotEqualImageFilter self, uint8_t BackgroundValue)



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(NotEqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the false pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(NotEqualImageFilter self, uint8_t ForegroundValue)



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(NotEqualImageFilter self) -> uint8_t



        Set/Get the value used to mark the true pixels of the operator.


        """
        return _SimpleITK.NotEqualImageFilter_GetForegroundValue(self)


    def GetName(self):
        """
        GetName(NotEqualImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NotEqualImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NotEqualImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NotEqualImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(NotEqualImageFilter self, Image image1, Image image2) -> Image
        Execute(NotEqualImageFilter self, Image image1, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(NotEqualImageFilter self, Image image1, double constant) -> Image
        Execute(NotEqualImageFilter self, double constant, Image image2) -> Image
        Execute(NotEqualImageFilter self, Image image1, double constant, uint8_t backgroundValue, uint8_t foregroundValue) -> Image
        Execute(NotEqualImageFilter self, double constant, Image image2, uint8_t backgroundValue, uint8_t foregroundValue) -> Image



        """
        return _SimpleITK.NotEqualImageFilter_Execute(self, *args)

NotEqualImageFilter_swigregister = _SimpleITK.NotEqualImageFilter_swigregister
NotEqualImageFilter_swigregister(NotEqualImageFilter)


def NotEqual(*args):
    """
    NotEqual(Image image1, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    NotEqual(Image image1, double constant, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image
    NotEqual(double constant, Image image2, uint8_t backgroundValue=0, uint8_t foregroundValue=1) -> Image



    """
    return _SimpleITK.NotEqual(*args)
class NotImageFilter(ImageFilter_1):
    """


    Implements the NOT logical operator pixel-wise on an image.


    This class is templated over the types of an input image and the type
    of the output image. Numeric conversions (castings) are done by the
    C++ defaults.

    Since the logical NOT operation is operates only on boolean types, the
    input type must be implicitly convertible to bool, which is only
    defined in C++ for integer types, the images passed to this filter
    must comply with the requirement of using integer pixel type.

    The total operation over one pixel will be


    Where "!" is the unary Logical NOT operator in C++.
    See:
     itk::simple::Not for the procedural interface

     itk::NotImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkNotImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::NotImageFilter self) -> NotImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_NotImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_NotImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(NotImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.NotImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(NotImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.NotImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(NotImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.NotImageFilter_Execute(self, image1)

NotImageFilter_swigregister = _SimpleITK.NotImageFilter_swigregister
NotImageFilter_swigregister(NotImageFilter)


def Not(image1):
    """
    Not(Image image1) -> Image



    Implements the NOT logical operator pixel-wise on an image.


    This function directly calls the execute method of NotImageFilter in order to support a procedural API


    See:
     itk::simple::NotImageFilter for the object oriented interface



    """
    return _SimpleITK.Not(image1)
class OpeningByReconstructionImageFilter(ImageFilter_1):
    """


    Opening by reconstruction of an image.


    This filter preserves regions, in the foreground, that can completely
    contain the structuring element. At the same time, this filter
    eliminates all other regions of foreground pixels. Contrary to the
    mophological opening, the opening by reconstruction preserves the
    shape of the components that are not removed by erosion. The opening
    by reconstruction of an image "f" is defined as:

    OpeningByReconstruction(f) = DilationByRecontruction(f, Erosion(f)).

    Opening by reconstruction not only removes structures destroyed by the
    erosion, but also levels down the contrast of the brightest regions.
    If PreserveIntensities is on, a subsequent reconstruction by dilation
    using a marker image that is the original image for all unaffected
    pixels.

    Opening by reconstruction is described in Chapter 6.3.9 of Pierre
    Soille's book "Morphological Image Analysis: Principles and
    Applications", Second Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     GrayscaleMorphologicalOpeningImageFilter

     itk::simple::OpeningByReconstruction for the procedural interface

     itk::OpeningByReconstructionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOpeningByReconstructionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OpeningByReconstructionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OpeningByReconstructionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::OpeningByReconstructionImageFilter self) -> OpeningByReconstructionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_OpeningByReconstructionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_OpeningByReconstructionImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.OpeningByReconstructionImageFilter_Annulus
    Ball = _SimpleITK.OpeningByReconstructionImageFilter_Ball
    Box = _SimpleITK.OpeningByReconstructionImageFilter_Box
    Cross = _SimpleITK.OpeningByReconstructionImageFilter_Cross

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(OpeningByReconstructionImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(OpeningByReconstructionImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(OpeningByReconstructionImageFilter self)



        """
        return _SimpleITK.OpeningByReconstructionImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(OpeningByReconstructionImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetFullyConnected(self)


    def SetPreserveIntensities(self, PreserveIntensities):
        """
        SetPreserveIntensities(OpeningByReconstructionImageFilter self, bool PreserveIntensities)



        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstrcution. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetPreserveIntensities(self, PreserveIntensities)


    def PreserveIntensitiesOn(self):
        """
        PreserveIntensitiesOn(OpeningByReconstructionImageFilter self)



        Set the value of PreserveIntensities to true or false respectfully.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_PreserveIntensitiesOn(self)


    def PreserveIntensitiesOff(self):
        """
        PreserveIntensitiesOff(OpeningByReconstructionImageFilter self)



        """
        return _SimpleITK.OpeningByReconstructionImageFilter_PreserveIntensitiesOff(self)


    def GetPreserveIntensities(self):
        """
        GetPreserveIntensities(OpeningByReconstructionImageFilter self) -> bool



        Set/Get whether the original intensities of the image retained for
        those pixels unaffected by the opening by reconstrcution. If Off, the
        output pixel contrast will be reduced.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetPreserveIntensities(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(OpeningByReconstructionImageFilter self, uint32_t r)
        SetKernelRadius(OpeningByReconstructionImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(OpeningByReconstructionImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(OpeningByReconstructionImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.OpeningByReconstructionImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(OpeningByReconstructionImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(OpeningByReconstructionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(OpeningByReconstructionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.OpeningByReconstructionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(OpeningByReconstructionImageFilter self, Image image1) -> Image
        Execute(OpeningByReconstructionImageFilter self, Image image1, bool fullyConnected, bool preserveIntensities) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.OpeningByReconstructionImageFilter_Execute(self, *args)

OpeningByReconstructionImageFilter_swigregister = _SimpleITK.OpeningByReconstructionImageFilter_swigregister
OpeningByReconstructionImageFilter_swigregister(OpeningByReconstructionImageFilter)


def OpeningByReconstruction(*args):
    """
    OpeningByReconstruction(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, bool fullyConnected=False, bool preserveIntensities=False) -> Image
    OpeningByReconstruction(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, bool fullyConnected=False, bool preserveIntensities=False) -> Image



    itk::simple::OpeningByReconstructionImageFilter Functional Interface

    This function directly calls the execute method of OpeningByReconstructionImageFilter in order to support a fully functional API


    """
    return _SimpleITK.OpeningByReconstruction(*args)
class OrImageFilter(ImageFilter_2):
    """


    Implements the OR bitwise operator pixel-wise between two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Since the bitwise OR operation is only defined in C++ for integer
    types, the images passed to this filter must comply with the
    requirement of using integer pixel type.

    The total operation over one pixel will be


    Where "|" is the boolean OR operator in C++.

    Wiki Examples:

    All Examples

    Binary OR two images
    See:
     itk::simple::Or for the procedural interface

     itk::OrImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkOrImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OrImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OrImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::OrImageFilter self) -> OrImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_OrImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_OrImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(OrImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.OrImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(OrImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.OrImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(OrImageFilter self, Image image1, Image image2) -> Image
        Execute(OrImageFilter self, Image image1, int constant) -> Image
        Execute(OrImageFilter self, int constant, Image image2) -> Image



        """
        return _SimpleITK.OrImageFilter_Execute(self, *args)

OrImageFilter_swigregister = _SimpleITK.OrImageFilter_swigregister
OrImageFilter_swigregister(OrImageFilter)


def Or(*args):
    """
    Or(Image image1, Image image2) -> Image
    Or(Image image1, int constant) -> Image
    Or(int constant, Image image2) -> Image



    """
    return _SimpleITK.Or(*args)
class OtsuMultipleThresholdsImageFilter(ImageFilter_1):
    """


    Threshold an image using multiple Otsu Thresholds.


    This filter creates a labeled image that separates the input image
    into various classes. The filter computes the thresholds using the OtsuMultipleThresholdsCalculator and applies those thesholds to the input image using the ThresholdLabelerImageFilter . The NumberOfHistogramBins and NumberOfThresholds can be set for the
    Calculator. The LabelOffset can be set for the ThresholdLabelerImageFilter .

    This filter also includes an option to use the valley emphasis
    algorithm from H.F. Ng, "Automatic thresholding for defect
    detection", Pattern Recognition Letters, (27): 1644-1649, 2006. The
    valley emphasis algorithm is particularly effective when the object to
    be thresholded is small. See the following tests for examples:
    itkOtsuMultipleThresholdsImageFilterTest3 and
    itkOtsuMultipleThresholdsImageFilterTest4 To use this algorithm,
    simple call the setter: SetValleyEmphasis(true) It is turned off by
    default.


    See:
     ScalarImageToHistogramGenerator

     OtsuMultipleThresholdsCalculator

     ThresholdLabelerImageFilter

     itk::simple::OtsuMultipleThresholds for the procedural interface

     itk::OtsuMultipleThresholdsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOtsuMultipleThresholdsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OtsuMultipleThresholdsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OtsuMultipleThresholdsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::OtsuMultipleThresholdsImageFilter self) -> OtsuMultipleThresholdsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_OtsuMultipleThresholdsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_OtsuMultipleThresholdsImageFilter
    __del__ = lambda self: None

    def SetNumberOfThresholds(self, NumberOfThresholds):
        """
        SetNumberOfThresholds(OtsuMultipleThresholdsImageFilter self, uint8_t NumberOfThresholds)



        Set/Get the number of thresholds. Default is 1.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetNumberOfThresholds(self, NumberOfThresholds)


    def GetNumberOfThresholds(self):
        """
        GetNumberOfThresholds(OtsuMultipleThresholdsImageFilter self) -> uint8_t



        Set/Get the number of thresholds. Default is 1.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetNumberOfThresholds(self)


    def SetLabelOffset(self, LabelOffset):
        """
        SetLabelOffset(OtsuMultipleThresholdsImageFilter self, uint8_t LabelOffset)



        Set/Get the offset which labels have to start from. Default is 0.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetLabelOffset(self, LabelOffset)


    def GetLabelOffset(self):
        """
        GetLabelOffset(OtsuMultipleThresholdsImageFilter self) -> uint8_t



        Set/Get the offset which labels have to start from. Default is 0.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetLabelOffset(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(OtsuMultipleThresholdsImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins. Default is 128.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(OtsuMultipleThresholdsImageFilter self) -> uint32_t



        Set/Get the number of histogram bins. Default is 128.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetNumberOfHistogramBins(self)


    def SetValleyEmphasis(self, ValleyEmphasis):
        """
        SetValleyEmphasis(OtsuMultipleThresholdsImageFilter self, bool ValleyEmphasis)



        Set/Get the use of valley emphasis. Default is false.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_SetValleyEmphasis(self, ValleyEmphasis)


    def ValleyEmphasisOn(self):
        """
        ValleyEmphasisOn(OtsuMultipleThresholdsImageFilter self)



        Set the value of ValleyEmphasis to true or false respectfully.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_ValleyEmphasisOn(self)


    def ValleyEmphasisOff(self):
        """
        ValleyEmphasisOff(OtsuMultipleThresholdsImageFilter self)



        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_ValleyEmphasisOff(self)


    def GetValleyEmphasis(self):
        """
        GetValleyEmphasis(OtsuMultipleThresholdsImageFilter self) -> bool



        Set/Get the use of valley emphasis. Default is false.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetValleyEmphasis(self)


    def GetThresholds(self):
        """
        GetThresholds(OtsuMultipleThresholdsImageFilter self) -> VectorDouble



        Get the computed threshold.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetThresholds(self)


    def GetName(self):
        """
        GetName(OtsuMultipleThresholdsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(OtsuMultipleThresholdsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(OtsuMultipleThresholdsImageFilter self, Image image1) -> Image
        Execute(OtsuMultipleThresholdsImageFilter self, Image image1, uint8_t numberOfThresholds, uint8_t labelOffset, uint32_t numberOfHistogramBins, bool valleyEmphasis) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.OtsuMultipleThresholdsImageFilter_Execute(self, *args)

OtsuMultipleThresholdsImageFilter_swigregister = _SimpleITK.OtsuMultipleThresholdsImageFilter_swigregister
OtsuMultipleThresholdsImageFilter_swigregister(OtsuMultipleThresholdsImageFilter)


def OtsuMultipleThresholds(image1, numberOfThresholds=1, labelOffset=0, numberOfHistogramBins=128, valleyEmphasis=False):
    """
    OtsuMultipleThresholds(Image image1, uint8_t numberOfThresholds=1, uint8_t labelOffset=0, uint32_t numberOfHistogramBins=128, bool valleyEmphasis=False) -> Image



    Threshold an image using multiple Otsu Thresholds.


    This function directly calls the execute method of OtsuMultipleThresholdsImageFilter in order to support a procedural API


    See:
     itk::simple::OtsuMultipleThresholdsImageFilter for the object oriented interface



    """
    return _SimpleITK.OtsuMultipleThresholds(image1, numberOfThresholds, labelOffset, numberOfHistogramBins, valleyEmphasis)
class OtsuThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Otsu Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the OtsuThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811

    Wiki Examples:

    All Examples

    Separate foreground and background using Otsu's method

    See:
     HistogramThresholdImageFilter

     itk::simple::OtsuThreshold for the procedural interface

     itk::OtsuThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkOtsuThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OtsuThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OtsuThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::OtsuThresholdImageFilter self) -> OtsuThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_OtsuThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_OtsuThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(OtsuThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value. The default value NumericTraits<OutputPixelType>::max()


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(OtsuThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(OtsuThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(OtsuThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(OtsuThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins. Defaults is 128.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(OtsuThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.OtsuThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(OtsuThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(OtsuThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.OtsuThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(OtsuThresholdImageFilter self)



        """
        return _SimpleITK.OtsuThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(OtsuThresholdImageFilter self) -> bool



        """
        return _SimpleITK.OtsuThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(OtsuThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.OtsuThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(OtsuThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.OtsuThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(OtsuThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(OtsuThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.OtsuThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(OtsuThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.OtsuThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(OtsuThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(OtsuThresholdImageFilter self, Image image) -> Image
        Execute(OtsuThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(OtsuThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.OtsuThresholdImageFilter_Execute(self, *args)

OtsuThresholdImageFilter_swigregister = _SimpleITK.OtsuThresholdImageFilter_swigregister
OtsuThresholdImageFilter_swigregister(OtsuThresholdImageFilter)


def OtsuThreshold(*args):
    """
    OtsuThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255) -> Image
    OtsuThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=128, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.OtsuThreshold(*args)
class PasteImageFilter(ImageFilter_2):
    """


    Paste an image into another image.


    PasteImageFilter allows you to take a section of one image and paste into another
    image. The SetDestinationIndex() method prescribes where in the first input to start pasting data from
    the second input. The SetSourceRegion method prescribes the section of
    the second image to paste into the first. If the output requested
    region does not include the SourceRegion after it has been
    repositioned to DestinationIndex, then the output will just be a copy
    of the input.

    The two inputs and output image will have the same pixel type.

    Wiki Examples:

    All Examples

    Paste a part of one image into another image
    See:
     itk::simple::Paste for the procedural interface

     itk::PasteImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkPasteImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PasteImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PasteImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::PasteImageFilter self) -> PasteImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_PasteImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_PasteImageFilter
    __del__ = lambda self: None

    def SetSourceSize(self, SourceSize):
        """
        SetSourceSize(PasteImageFilter self, VectorUInt32 SourceSize)



        """
        return _SimpleITK.PasteImageFilter_SetSourceSize(self, SourceSize)


    def GetSourceSize(self):
        """
        GetSourceSize(PasteImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.PasteImageFilter_GetSourceSize(self)


    def SetSourceIndex(self, SourceIndex):
        """
        SetSourceIndex(PasteImageFilter self, VectorInt32 SourceIndex)



        """
        return _SimpleITK.PasteImageFilter_SetSourceIndex(self, SourceIndex)


    def GetSourceIndex(self):
        """
        GetSourceIndex(PasteImageFilter self) -> VectorInt32



        """
        return _SimpleITK.PasteImageFilter_GetSourceIndex(self)


    def SetDestinationIndex(self, DestinationIndex):
        """
        SetDestinationIndex(PasteImageFilter self, VectorInt32 DestinationIndex)



        Set/Get the destination index (where in the first input the second
        input will be pasted.


        """
        return _SimpleITK.PasteImageFilter_SetDestinationIndex(self, DestinationIndex)


    def GetDestinationIndex(self):
        """
        GetDestinationIndex(PasteImageFilter self) -> VectorInt32



        Set/Get the destination index (where in the first input the second
        input will be pasted.


        """
        return _SimpleITK.PasteImageFilter_GetDestinationIndex(self)


    def GetName(self):
        """
        GetName(PasteImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.PasteImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(PasteImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.PasteImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(PasteImageFilter self, Image image1, Image image2) -> Image
        Execute(PasteImageFilter self, Image image1, Image image2, VectorUInt32 sourceSize, VectorInt32 sourceIndex, VectorInt32 destinationIndex) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.PasteImageFilter_Execute(self, *args)

PasteImageFilter_swigregister = _SimpleITK.PasteImageFilter_swigregister
PasteImageFilter_swigregister(PasteImageFilter)


def Paste(*args, **kwargs):
    """
    Paste(Image image1, Image image2, VectorUInt32 sourceSize, VectorInt32 sourceIndex, VectorInt32 destinationIndex) -> Image



    Paste an image into another image.


    This function directly calls the execute method of PasteImageFilter in order to support a procedural API


    See:
     itk::simple::PasteImageFilter for the object oriented interface



    """
    return _SimpleITK.Paste(*args, **kwargs)
class PatchBasedDenoisingImageFilter(ImageFilter_1):
    """


    Derived class implementing a specific patch-based denoising algorithm,
    as detailed below.


    This class is derived from the base class PatchBasedDenoisingBaseImageFilter ; please refer to the documentation of the base class first. This
    class implements a denoising filter that uses iterative non-local, or
    semi-local, weighted averaging of image patches for image denoising.
    The intensity at each pixel 'p' gets updated as a weighted average of
    intensities of a chosen subset of pixels from the image.

    This class implements the denoising algorithm using a Gaussian kernel
    function for nonparametric density estimation. The class implements a
    scheme to automatically estimated the kernel bandwidth parameter
    (namely, sigma) using leave-one-out cross validation. It implements
    schemes for random sampling of patches non-locally (from the entire
    image) as well as semi-locally (from the spatial proximity of the
    pixel being denoised at the specific point in time). It implements a
    specific scheme for defining patch weights (mask) as described in
    Awate and Whitaker 2005 IEEE CVPR and 2006 IEEE TPAMI.


    See:
     PatchBasedDenoisingBaseImageFilter

     itk::PatchBasedDenoisingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkPatchBasedDenoisingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PatchBasedDenoisingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PatchBasedDenoisingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::PatchBasedDenoisingImageFilter self) -> PatchBasedDenoisingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_PatchBasedDenoisingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_PatchBasedDenoisingImageFilter
    __del__ = lambda self: None

    def SetKernelBandwidthSigma(self, KernelBandwidthSigma):
        """
        SetKernelBandwidthSigma(PatchBasedDenoisingImageFilter self, double KernelBandwidthSigma)



        Set/Get initial kernel bandwidth estimate. To prevent the class from
        automatically modifying this estimate, set KernelBandwidthEstimation
        to false in the base class.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthSigma(self, KernelBandwidthSigma)


    def GetKernelBandwidthSigma(self):
        """
        GetKernelBandwidthSigma(PatchBasedDenoisingImageFilter self) -> double



        Set/Get initial kernel bandwidth estimate. To prevent the class from
        automatically modifying this estimate, set KernelBandwidthEstimation
        to false in the base class.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthSigma(self)


    def SetPatchRadius(self, PatchRadius):
        """
        SetPatchRadius(PatchBasedDenoisingImageFilter self, uint32_t PatchRadius)



        Set/Get the patch radius specified in physical coordinates. Patch
        radius is preferably set to an even number. Currently, only isotropic
        patches in physical space are allowed; patches can be anisotropic in
        voxel space.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetPatchRadius(self, PatchRadius)


    def GetPatchRadius(self):
        """
        GetPatchRadius(PatchBasedDenoisingImageFilter self) -> uint32_t



        Set/Get the patch radius specified in physical coordinates. Patch
        radius is preferably set to an even number. Currently, only isotropic
        patches in physical space are allowed; patches can be anisotropic in
        voxel space.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetPatchRadius(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(PatchBasedDenoisingImageFilter self, uint32_t NumberOfIterations)



        Set/Get the number of denoising iterations to perform. Must be a
        positive integer. Defaults to 1.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(PatchBasedDenoisingImageFilter self) -> uint32_t



        Set/Get the number of denoising iterations to perform. Must be a
        positive integer. Defaults to 1.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNumberOfIterations(self)


    def SetNumberOfSamplePatches(self, NumberOfSamplePatches):
        """
        SetNumberOfSamplePatches(PatchBasedDenoisingImageFilter self, uint32_t NumberOfSamplePatches)



        Set/Get the number of patches to sample for each pixel.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNumberOfSamplePatches(self, NumberOfSamplePatches)


    def GetNumberOfSamplePatches(self):
        """
        GetNumberOfSamplePatches(PatchBasedDenoisingImageFilter self) -> uint32_t



        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNumberOfSamplePatches(self)


    def SetSampleVariance(self, SampleVariance):
        """
        SetSampleVariance(PatchBasedDenoisingImageFilter self, double SampleVariance)



        Set/Get the variance of the domain where patches are sampled.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetSampleVariance(self, SampleVariance)


    def GetSampleVariance(self):
        """
        GetSampleVariance(PatchBasedDenoisingImageFilter self) -> double



        Set/Get the variance of the domain where patches are sampled.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetSampleVariance(self)

    NOMODEL = _SimpleITK.PatchBasedDenoisingImageFilter_NOMODEL
    GAUSSIAN = _SimpleITK.PatchBasedDenoisingImageFilter_GAUSSIAN
    RICIAN = _SimpleITK.PatchBasedDenoisingImageFilter_RICIAN
    POISSON = _SimpleITK.PatchBasedDenoisingImageFilter_POISSON

    def SetNoiseModel(self, NoiseModel):
        """
        SetNoiseModel(PatchBasedDenoisingImageFilter self, itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType NoiseModel)



        Set/Get the noise model type. Defaults to GAUSSIAN. To use the noise
        model during denoising, FidelityWeight must be positive.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNoiseModel(self, NoiseModel)


    def GetNoiseModel(self):
        """
        GetNoiseModel(PatchBasedDenoisingImageFilter self) -> itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType



        Set/Get the noise model type. Defaults to GAUSSIAN. To use the noise
        model during denoising, FidelityWeight must be positive.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNoiseModel(self)


    def SetNoiseSigma(self, NoiseSigma):
        """
        SetNoiseSigma(PatchBasedDenoisingImageFilter self, double NoiseSigma)



        Set/Get the noise sigma. Used by the noise model where appropriate,
        defaults to 5% of the image intensity range


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNoiseSigma(self, NoiseSigma)


    def GetNoiseSigma(self):
        """
        GetNoiseSigma(PatchBasedDenoisingImageFilter self) -> double



        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNoiseSigma(self)


    def SetNoiseModelFidelityWeight(self, NoiseModelFidelityWeight):
        """
        SetNoiseModelFidelityWeight(PatchBasedDenoisingImageFilter self, double NoiseModelFidelityWeight)



        Set/Get the weight on the fidelity term (penalizes deviations from the
        noisy data). This option is used when a noise model is specified. This
        weight controls the balance between the smoothing and the closeness to
        the noisy data.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetNoiseModelFidelityWeight(self, NoiseModelFidelityWeight)


    def GetNoiseModelFidelityWeight(self):
        """
        GetNoiseModelFidelityWeight(PatchBasedDenoisingImageFilter self) -> double



        Set/Get the weight on the fidelity term (penalizes deviations from the
        noisy data). This option is used when a noise model is specified. This
        weight controls the balance between the smoothing and the closeness to
        the noisy data.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetNoiseModelFidelityWeight(self)


    def SetAlwaysTreatComponentsAsEuclidean(self, AlwaysTreatComponentsAsEuclidean):
        """
        SetAlwaysTreatComponentsAsEuclidean(PatchBasedDenoisingImageFilter self, bool AlwaysTreatComponentsAsEuclidean)



        Set/Get flag indicating whether all components should always be
        treated as if they are in euclidean space regardless of pixel type.
        Defaults to false.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetAlwaysTreatComponentsAsEuclidean(self, AlwaysTreatComponentsAsEuclidean)


    def AlwaysTreatComponentsAsEuclideanOn(self):
        """
        AlwaysTreatComponentsAsEuclideanOn(PatchBasedDenoisingImageFilter self)



        Set the value of AlwaysTreatComponentsAsEuclidean to true or false
        respectfully.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_AlwaysTreatComponentsAsEuclideanOn(self)


    def AlwaysTreatComponentsAsEuclideanOff(self):
        """
        AlwaysTreatComponentsAsEuclideanOff(PatchBasedDenoisingImageFilter self)



        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_AlwaysTreatComponentsAsEuclideanOff(self)


    def GetAlwaysTreatComponentsAsEuclidean(self):
        """
        GetAlwaysTreatComponentsAsEuclidean(PatchBasedDenoisingImageFilter self) -> bool



        Set/Get flag indicating whether all components should always be
        treated as if they are in euclidean space regardless of pixel type.
        Defaults to false.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetAlwaysTreatComponentsAsEuclidean(self)


    def SetKernelBandwidthEstimation(self, KernelBandwidthEstimation):
        """
        SetKernelBandwidthEstimation(PatchBasedDenoisingImageFilter self, bool KernelBandwidthEstimation)



        Set/Get flag indicating whether kernel-bandwidth should be estimated
        automatically from the image data. Defaults to true.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthEstimation(self, KernelBandwidthEstimation)


    def KernelBandwidthEstimationOn(self):
        """
        KernelBandwidthEstimationOn(PatchBasedDenoisingImageFilter self)



        Set the value of KernelBandwidthEstimation to true or false
        respectfully.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_KernelBandwidthEstimationOn(self)


    def KernelBandwidthEstimationOff(self):
        """
        KernelBandwidthEstimationOff(PatchBasedDenoisingImageFilter self)



        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_KernelBandwidthEstimationOff(self)


    def GetKernelBandwidthEstimation(self):
        """
        GetKernelBandwidthEstimation(PatchBasedDenoisingImageFilter self) -> bool



        Set/Get flag indicating whether kernel-bandwidth should be estimated
        automatically from the image data. Defaults to true.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthEstimation(self)


    def SetKernelBandwidthMultiplicationFactor(self, KernelBandwidthMultiplicationFactor):
        """
        SetKernelBandwidthMultiplicationFactor(PatchBasedDenoisingImageFilter self, double KernelBandwidthMultiplicationFactor)



        Set/Get the kernel bandwidth sigma multiplication factor used to
        modify the automatically-estimated kernel bandwidth sigma. At times,
        it may be desirable to modify the value of the automatically-estimated
        sigma. Typically, this number isn't very far from 1. Note: This is
        used only when KernelBandwidthEstimation is True/On.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthMultiplicationFactor(self, KernelBandwidthMultiplicationFactor)


    def GetKernelBandwidthMultiplicationFactor(self):
        """
        GetKernelBandwidthMultiplicationFactor(PatchBasedDenoisingImageFilter self) -> double



        Set/Get the kernel bandwidth sigma multiplication factor used to
        modify the automatically-estimated kernel bandwidth sigma. At times,
        it may be desirable to modify the value of the automatically-estimated
        sigma. Typically, this number isn't very far from 1. Note: This is
        used only when KernelBandwidthEstimation is True/On.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthMultiplicationFactor(self)


    def SetKernelBandwidthUpdateFrequency(self, KernelBandwidthUpdateFrequency):
        """
        SetKernelBandwidthUpdateFrequency(PatchBasedDenoisingImageFilter self, uint32_t KernelBandwidthUpdateFrequency)



        Set/Get the update frequency for the kernel bandwidth estimation. An
        optimal bandwidth will be re-estimated based on the denoised image
        after every 'n' iterations. Must be a positive integer. Defaults to 3,
        i.e. bandwidth updated after every 3 denoising iteration.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthUpdateFrequency(self, KernelBandwidthUpdateFrequency)


    def GetKernelBandwidthUpdateFrequency(self):
        """
        GetKernelBandwidthUpdateFrequency(PatchBasedDenoisingImageFilter self) -> uint32_t



        Set/Get the update frequency for the kernel bandwidth estimation. An
        optimal bandwidth will be re-estimated based on the denoised image
        after every 'n' iterations. Must be a positive integer. Defaults to 3,
        i.e. bandwidth updated after every 3 denoising iteration.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthUpdateFrequency(self)


    def SetKernelBandwidthFractionPixelsForEstimation(self, KernelBandwidthFractionPixelsForEstimation):
        """
        SetKernelBandwidthFractionPixelsForEstimation(PatchBasedDenoisingImageFilter self, double KernelBandwidthFractionPixelsForEstimation)



        Set/Get the fraction of the image to use for kernel bandwidth sigma
        estimation. To reduce the computational burden for computing sigma, a
        small random fraction of the image pixels can be used.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_SetKernelBandwidthFractionPixelsForEstimation(self, KernelBandwidthFractionPixelsForEstimation)


    def GetKernelBandwidthFractionPixelsForEstimation(self):
        """
        GetKernelBandwidthFractionPixelsForEstimation(PatchBasedDenoisingImageFilter self) -> double



        Set/Get the fraction of the image to use for kernel bandwidth sigma
        estimation. To reduce the computational burden for computing sigma, a
        small random fraction of the image pixels can be used.


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetKernelBandwidthFractionPixelsForEstimation(self)


    def GetName(self):
        """
        GetName(PatchBasedDenoisingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(PatchBasedDenoisingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(PatchBasedDenoisingImageFilter self, Image image1) -> Image
        Execute(PatchBasedDenoisingImageFilter self, Image image1, double kernelBandwidthSigma, uint32_t patchRadius, uint32_t numberOfIterations, uint32_t numberOfSamplePatches, double sampleVariance, itk::simple::PatchBasedDenoisingImageFilter::NoiseModelType noiseModel, double noiseSigma, double noiseModelFidelityWeight, bool alwaysTreatComponentsAsEuclidean, bool kernelBandwidthEstimation, double kernelBandwidthMultiplicationFactor, uint32_t kernelBandwidthUpdateFrequency, double kernelBandwidthFractionPixelsForEstimation) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.PatchBasedDenoisingImageFilter_Execute(self, *args)

PatchBasedDenoisingImageFilter_swigregister = _SimpleITK.PatchBasedDenoisingImageFilter_swigregister
PatchBasedDenoisingImageFilter_swigregister(PatchBasedDenoisingImageFilter)

class PermuteAxesImageFilter(ImageFilter_1):
    """


    Permutes the image axes according to a user specified order.


    PermuateAxesImageFilter permutes the image axes according to a user
    specified order. The permutation order is set via method SetOrder(
    order ) where the input is an array of ImageDimension number of
    unsigned int. The elements of the array must be a rearrangment of the
    numbers from 0 to ImageDimension - 1.

    The i-th axis of the output image corresponds with the order[i]-th
    axis of the input image.

    The output meta image information (LargestPossibleRegion, spacing,
    origin) is computed by permuting the corresponding input meta
    information.

    Wiki Examples:

    All Examples

    Switch the axes of an image
    See:
     itk::simple::PermuteAxes for the procedural interface

     itk::PermuteAxesImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkPermuteAxesImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PermuteAxesImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PermuteAxesImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::PermuteAxesImageFilter self) -> PermuteAxesImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_PermuteAxesImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_PermuteAxesImageFilter
    __del__ = lambda self: None

    def SetOrder(self, Order):
        """
        SetOrder(PermuteAxesImageFilter self, VectorUInt32 Order)



        Set the permutation order. The elements of order must be a
        rearrangement of the numbers from 0 to ImageDimension - 1.


        """
        return _SimpleITK.PermuteAxesImageFilter_SetOrder(self, Order)


    def GetOrder(self):
        """
        GetOrder(PermuteAxesImageFilter self) -> VectorUInt32



        Get the permutation order.


        """
        return _SimpleITK.PermuteAxesImageFilter_GetOrder(self)


    def GetName(self):
        """
        GetName(PermuteAxesImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.PermuteAxesImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(PermuteAxesImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.PermuteAxesImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(PermuteAxesImageFilter self, Image image1) -> Image
        Execute(PermuteAxesImageFilter self, Image image1, VectorUInt32 order) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.PermuteAxesImageFilter_Execute(self, *args)

PermuteAxesImageFilter_swigregister = _SimpleITK.PermuteAxesImageFilter_swigregister
PermuteAxesImageFilter_swigregister(PermuteAxesImageFilter)
cvar = _SimpleITK.cvar
PermuteAxesImageFilter.DefaultOrder = _SimpleITK.cvar.PermuteAxesImageFilter_DefaultOrder


def PermuteAxes(*args, **kwargs):
    """
    PermuteAxes(Image image1, VectorUInt32 order) -> Image



    Permutes the image axes according to a user specified order.


    This function directly calls the execute method of PermuteAxesImageFilter in order to support a procedural API


    See:
     itk::simple::PermuteAxesImageFilter for the object oriented interface



    """
    return _SimpleITK.PermuteAxes(*args, **kwargs)
class PhysicalPointImageSource(ImageFilter_0):
    """


    Generate an image of the physical locations of each pixel.


    This image source supports image which have a multi-component pixel
    equal to the image dimension, and variable length VectorImages. It is
    recommented that the component type be a real valued type.
    See:
     itk::simple::PhysicalPointImageSource for the procedural interface

     itk::PhysicalPointImageSource for the Doxygen on the original ITK class.


    C++ includes: sitkPhysicalPointImageSource.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhysicalPointImageSource, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PhysicalPointImageSource, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::PhysicalPointImageSource self) -> PhysicalPointImageSource



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_PhysicalPointImageSource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_PhysicalPointImageSource
    __del__ = lambda self: None

    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(PhysicalPointImageSource self, itk::simple::PixelIDValueEnum OutputPixelType)



        """
        return _SimpleITK.PhysicalPointImageSource_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(PhysicalPointImageSource self) -> itk::simple::PixelIDValueEnum



        """
        return _SimpleITK.PhysicalPointImageSource_GetOutputPixelType(self)


    def SetSize(self, Size):
        """
        SetSize(PhysicalPointImageSource self, VectorUInt32 Size)



        """
        return _SimpleITK.PhysicalPointImageSource_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(PhysicalPointImageSource self) -> VectorUInt32



        """
        return _SimpleITK.PhysicalPointImageSource_GetSize(self)


    def SetOrigin(self, Origin):
        """
        SetOrigin(PhysicalPointImageSource self, VectorDouble Origin)



        """
        return _SimpleITK.PhysicalPointImageSource_SetOrigin(self, Origin)


    def GetOrigin(self):
        """
        GetOrigin(PhysicalPointImageSource self) -> VectorDouble



        """
        return _SimpleITK.PhysicalPointImageSource_GetOrigin(self)


    def SetSpacing(self, Spacing):
        """
        SetSpacing(PhysicalPointImageSource self, VectorDouble Spacing)



        """
        return _SimpleITK.PhysicalPointImageSource_SetSpacing(self, Spacing)


    def GetSpacing(self):
        """
        GetSpacing(PhysicalPointImageSource self) -> VectorDouble



        """
        return _SimpleITK.PhysicalPointImageSource_GetSpacing(self)


    def SetDirection(self, Direction):
        """
        SetDirection(PhysicalPointImageSource self, VectorDouble Direction)



        """
        return _SimpleITK.PhysicalPointImageSource_SetDirection(self, Direction)


    def GetDirection(self):
        """
        GetDirection(PhysicalPointImageSource self) -> VectorDouble



        """
        return _SimpleITK.PhysicalPointImageSource_GetDirection(self)


    def GetName(self):
        """
        GetName(PhysicalPointImageSource self) -> std::string



        Name of this class


        """
        return _SimpleITK.PhysicalPointImageSource_GetName(self)


    def __str__(self):
        """
        __str__(PhysicalPointImageSource self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.PhysicalPointImageSource___str__(self)


    def Execute(self, *args):
        """
        Execute(PhysicalPointImageSource self) -> Image
        Execute(PhysicalPointImageSource self, itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.PhysicalPointImageSource_Execute(self, *args)


    def SetReferenceImage(self, refImage):
        """
        SetReferenceImage(PhysicalPointImageSource self, Image refImage)



        This methods sets the size, origin, spacing and direction to that of
        the provided image


        """
        return _SimpleITK.PhysicalPointImageSource_SetReferenceImage(self, refImage)

PhysicalPointImageSource_swigregister = _SimpleITK.PhysicalPointImageSource_swigregister
PhysicalPointImageSource_swigregister(PhysicalPointImageSource)


def PhysicalPointSource(*args, **kwargs):
    """
    PhysicalPointSource(itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble origin, VectorDouble spacing, VectorDouble direction) -> Image



    Generate an image of the physical locations of each pixel.


    This function directly calls the execute method of PhysicalPointImageSource in order to support a procedural API


    See:
     itk::simple::PhysicalPointImageSource for the object oriented interface



    """
    return _SimpleITK.PhysicalPointSource(*args, **kwargs)
class PowImageFilter(ImageFilter_2):
    """


    Computes the powers of 2 images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    The output of the pow function will be cast to the pixel type of the
    output image.

    The total operation over one pixel will be

    The pow function can be applied to two images with the following:

    Additionally, this filter can be used to raise every pixel of an image
    to a power of a constant by using
    See:
     itk::simple::Pow for the procedural interface

     itk::PowImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkPowImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PowImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PowImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::PowImageFilter self) -> PowImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_PowImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_PowImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(PowImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.PowImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(PowImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.PowImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(PowImageFilter self, Image image1, Image image2) -> Image
        Execute(PowImageFilter self, Image image1, double constant) -> Image
        Execute(PowImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.PowImageFilter_Execute(self, *args)

PowImageFilter_swigregister = _SimpleITK.PowImageFilter_swigregister
PowImageFilter_swigregister(PowImageFilter)


def Pow(*args):
    """
    Pow(Image image1, Image image2) -> Image
    Pow(Image image1, double constant) -> Image
    Pow(double constant, Image image2) -> Image



    """
    return _SimpleITK.Pow(*args)
class ProjectedLandweberDeconvolutionImageFilter(ImageFilter_2):
    """


    Deconvolve an image using the projected Landweber deconvolution
    algorithm.


    This filter performs the same calculation per iteration as the LandweberDeconvolutionImageFilter . However, at each iteration, negative pixels in the intermediate
    result are projected (set) to zero. This is useful if the solution is
    assumed to always be non-negative, which is the case when dealing with
    images formed by counting photons, for example.

    This code was adapted from the Insight Journal contribution:

    "Deconvolution: infrastructure and reference algorithms" by Gaetan
    Lehmann https://hdl.handle.net/10380/3207


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France
     Cory Quammen, The University of North Carolina at Chapel Hill


    See:
     IterativeDeconvolutionImageFilter

     RichardsonLucyDeconvolutionImageFilter

     LandweberDeconvolutionImageFilter

     itk::simple::ProjectedLandweberDeconvolution for the procedural interface

     itk::ProjectedLandweberDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkProjectedLandweberDeconvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProjectedLandweberDeconvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProjectedLandweberDeconvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ProjectedLandweberDeconvolutionImageFilter self) -> ProjectedLandweberDeconvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ProjectedLandweberDeconvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ProjectedLandweberDeconvolutionImageFilter
    __del__ = lambda self: None

    def SetAlpha(self, Alpha):
        """
        SetAlpha(ProjectedLandweberDeconvolutionImageFilter self, double Alpha)



        Set the relaxation factor.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetAlpha(self, Alpha)


    def GetAlpha(self):
        """
        GetAlpha(ProjectedLandweberDeconvolutionImageFilter self) -> double



        Get the relaxation factor.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetAlpha(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(ProjectedLandweberDeconvolutionImageFilter self, int NumberOfIterations)



        Set the number of iterations.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(ProjectedLandweberDeconvolutionImageFilter self) -> int



        Get the number of iterations.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetNumberOfIterations(self)


    def SetNormalize(self, Normalize):
        """
        SetNormalize(ProjectedLandweberDeconvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(ProjectedLandweberDeconvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(ProjectedLandweberDeconvolutionImageFilter self)



        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(ProjectedLandweberDeconvolutionImageFilter self) -> bool



        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(ProjectedLandweberDeconvolutionImageFilter self, itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(ProjectedLandweberDeconvolutionImageFilter self) -> itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SAME
    VALID = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(ProjectedLandweberDeconvolutionImageFilter self, itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(ProjectedLandweberDeconvolutionImageFilter self) -> itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(ProjectedLandweberDeconvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ProjectedLandweberDeconvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ProjectedLandweberDeconvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(ProjectedLandweberDeconvolutionImageFilter self, Image image1, Image image2, double alpha, int numberOfIterations, bool normalize, itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_Execute(self, *args)

ProjectedLandweberDeconvolutionImageFilter_swigregister = _SimpleITK.ProjectedLandweberDeconvolutionImageFilter_swigregister
ProjectedLandweberDeconvolutionImageFilter_swigregister(ProjectedLandweberDeconvolutionImageFilter)


def ProjectedLandweberDeconvolution(*args, **kwargs):
    """
    ProjectedLandweberDeconvolution(Image image1, Image image2, double alpha=0.1, int numberOfIterations=1, bool normalize=False, itk::simple::ProjectedLandweberDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::ProjectedLandweberDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    Deconvolve an image using the projected Landweber deconvolution
    algorithm.


    This function directly calls the execute method of ProjectedLandweberDeconvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::ProjectedLandweberDeconvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.ProjectedLandweberDeconvolution(*args, **kwargs)
class RankImageFilter(ImageFilter_1):
    """


    Rank filter of a greyscale image.


    Nonlinear filter in which each output pixel is a user defined rank of
    input pixels in a user defined neighborhood. The default rank is 0.5
    (median). The boundary conditions are different to the standard
    itkMedianImageFilter. In this filter the neighborhood is cropped at
    the boundary, and is therefore smaller.

    This filter uses a recursive implementation - essentially the one by
    Huang 1979, I believe, to compute the rank, and is therefore usually a
    lot faster than the direct implementation. The extensions to Huang are
    support for arbitrary pixel types (using c++ maps) and arbitrary
    neighborhoods. I presume that these are not new ideas.

    This filter is based on the sliding window code from the
    consolidatedMorphology package on InsightJournal.

    The structuring element is assumed to be composed of binary values
    (zero or one). Only elements of the structuring element having values
    > 0 are candidates for affecting the center pixel.

    This code was contributed in the Insight Journal paper: "Efficient
    implementation of kernel filtering" by Beare R., Lehmann G https://hdl.handle.net/1926/555 http://www.insight-journal.org/browse/publication/160


    Richard Beare

    See:
     itk::simple::Rank for the procedural interface

     itk::RankImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRankImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RankImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RankImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RankImageFilter self) -> RankImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RankImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RankImageFilter
    __del__ = lambda self: None

    def SetRank(self, Rank):
        """
        SetRank(RankImageFilter self, double Rank)



        """
        return _SimpleITK.RankImageFilter_SetRank(self, Rank)


    def GetRank(self):
        """
        GetRank(RankImageFilter self) -> double



        """
        return _SimpleITK.RankImageFilter_GetRank(self)


    def SetRadius(self, *args):
        """
        SetRadius(RankImageFilter self, VectorUInt32 Radius)
        SetRadius(RankImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.RankImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(RankImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.RankImageFilter_GetRadius(self)


    def GetName(self):
        """
        GetName(RankImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RankImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RankImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RankImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RankImageFilter self, Image image1) -> Image
        Execute(RankImageFilter self, Image image1, double rank, VectorUInt32 radius) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RankImageFilter_Execute(self, *args)

RankImageFilter_swigregister = _SimpleITK.RankImageFilter_swigregister
RankImageFilter_swigregister(RankImageFilter)


def Rank(*args, **kwargs):
    """
    Rank(Image image1, double rank=0.5, VectorUInt32 radius) -> Image



    Rank filter of a greyscale image.


    This function directly calls the execute method of RankImageFilter in order to support a procedural API


    See:
     itk::simple::RankImageFilter for the object oriented interface



    """
    return _SimpleITK.Rank(*args, **kwargs)
class RealAndImaginaryToComplexImageFilter(ImageFilter_2):
    """


    ComposeImageFilter combine several scalar images into a multicomponent image.


    ComposeImageFilter combine several scalar images into an itk::Image of vector pixel ( itk::Vector , itk::RGBPixel , ...), of std::complex pixel, or in an itk::VectorImage .

    Inputs and Usage
     All input images are expected to have the same template parameters
    and have the same size and origin.

    See:
     VectorImage

     VectorIndexSelectionCastImageFilter
    Wiki Examples:

    All Examples

    Create a vector image from a collection of scalar images

    Compose a vector image (with 3 components) from three scalar images

    Convert a real image and an imaginary image to a complex image
    See:
     itk::simple::RealAndImaginaryToComplex for the procedural interface

     itk::ComposeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRealAndImaginaryToComplexImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealAndImaginaryToComplexImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealAndImaginaryToComplexImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RealAndImaginaryToComplexImageFilter self) -> RealAndImaginaryToComplexImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RealAndImaginaryToComplexImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RealAndImaginaryToComplexImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(RealAndImaginaryToComplexImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RealAndImaginaryToComplexImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RealAndImaginaryToComplexImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RealAndImaginaryToComplexImageFilter___str__(self)


    def Execute(self, image1, image2):
        """
        Execute(RealAndImaginaryToComplexImageFilter self, Image image1, Image image2) -> Image



        Execute the filter on the input images


        """
        return _SimpleITK.RealAndImaginaryToComplexImageFilter_Execute(self, image1, image2)

RealAndImaginaryToComplexImageFilter_swigregister = _SimpleITK.RealAndImaginaryToComplexImageFilter_swigregister
RealAndImaginaryToComplexImageFilter_swigregister(RealAndImaginaryToComplexImageFilter)


def RealAndImaginaryToComplex(image1, image2):
    """
    RealAndImaginaryToComplex(Image image1, Image image2) -> Image



    ComposeImageFilter combine several scalar images into a multicomponent image.


    This function directly calls the execute method of RealAndImaginaryToComplexImageFilter in order to support a procedural API


    See:
     itk::simple::RealAndImaginaryToComplexImageFilter for the object oriented interface



    """
    return _SimpleITK.RealAndImaginaryToComplex(image1, image2)
class RealToHalfHermitianForwardFFTImageFilter(ImageFilter_1):
    """


    Base class for specialized real-to-complex forward Fast Fourier Transform .


    This is a base class for the "forward" or "direct" discrete
    Fourier Transform . This is an abstract base class: the actual implementation is
    provided by the best child class available on the system when the
    object is created via the object factory system.

    This class transforms a real input image into its complex Fourier
    transform. The Fourier transform of a real input image has Hermitian
    symmetry: $ f(\\mathbf{x}) = f^*(-\\mathbf{x}) $ . That is, when the result of the transform is split in half along
    the X-dimension, the values in the second half of the transform are
    the complex conjugates of values in the first half reflected about the
    center of the image in each dimension. This filter takes advantage of
    the Hermitian symmetry property and reduces the size of the output in
    the first dimension to N/2+1, where N is the size of the input image
    in that dimension and the division by 2 is rounded down.


    See:
     HalfHermitianToRealInverseFFTImageFilter

     ForwardFFTImageFilter

     itk::simple::RealToHalfHermitianForwardFFT for the procedural interface

     itk::RealToHalfHermitianForwardFFTImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRealToHalfHermitianForwardFFTImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealToHalfHermitianForwardFFTImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealToHalfHermitianForwardFFTImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RealToHalfHermitianForwardFFTImageFilter self) -> RealToHalfHermitianForwardFFTImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RealToHalfHermitianForwardFFTImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RealToHalfHermitianForwardFFTImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(RealToHalfHermitianForwardFFTImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RealToHalfHermitianForwardFFTImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RealToHalfHermitianForwardFFTImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RealToHalfHermitianForwardFFTImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(RealToHalfHermitianForwardFFTImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.RealToHalfHermitianForwardFFTImageFilter_Execute(self, image1)

RealToHalfHermitianForwardFFTImageFilter_swigregister = _SimpleITK.RealToHalfHermitianForwardFFTImageFilter_swigregister
RealToHalfHermitianForwardFFTImageFilter_swigregister(RealToHalfHermitianForwardFFTImageFilter)


def RealToHalfHermitianForwardFFT(image1):
    """
    RealToHalfHermitianForwardFFT(Image image1) -> Image



    Base class for specialized real-to-complex forward Fast Fourier Transform .


    This function directly calls the execute method of RealToHalfHermitianForwardFFTImageFilter in order to support a procedural API


    See:
     itk::simple::RealToHalfHermitianForwardFFTImageFilter for the object oriented interface



    """
    return _SimpleITK.RealToHalfHermitianForwardFFT(image1)
class ReconstructionByDilationImageFilter(ImageFilter_2):
    """


    grayscale reconstruction by dilation of an image


    Reconstruction by dilation operates on a "marker" image and a
    "mask" image, and is defined as the dilation of the marker image
    with respect to the mask image iterated until stability.

    The marker image must be less than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.

    Algorithm implemented in this filter is based on algorithm described
    by Kevin Robinson and Paul F. Whelan in "Efficient Morphological
    Reconstruction: A Downhill Filter", Pattern Recognition Letters,
    Volume 25, Issue 15, November 2004, Pages 1759-1767.

    The algorithm, a description of the transform and some applications
    can be found in "Morphological Grayscale Reconstruction in Image
    Analysis:  Applications and Efficient Algorithms", Luc Vincent, IEEE
    Transactions on image processing, Vol. 2, April 1993.


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter , ReconstructionByErosionImageFilter , OpeningByReconstructionImageFilter , ClosingByReconstructionImageFilter , ReconstructionImageFilter

     itk::simple::ReconstructionByDilation for the procedural interface

     itk::ReconstructionByDilationImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkReconstructionByDilationImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReconstructionByDilationImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReconstructionByDilationImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ReconstructionByDilationImageFilter self) -> ReconstructionByDilationImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ReconstructionByDilationImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ReconstructionByDilationImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ReconstructionByDilationImageFilter self, bool FullyConnected)



        """
        return _SimpleITK.ReconstructionByDilationImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ReconstructionByDilationImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ReconstructionByDilationImageFilter self)



        """
        return _SimpleITK.ReconstructionByDilationImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ReconstructionByDilationImageFilter self) -> bool



        """
        return _SimpleITK.ReconstructionByDilationImageFilter_GetFullyConnected(self)


    def SetUseInternalCopy(self, UseInternalCopy):
        """
        SetUseInternalCopy(ReconstructionByDilationImageFilter self, bool UseInternalCopy)



        """
        return _SimpleITK.ReconstructionByDilationImageFilter_SetUseInternalCopy(self, UseInternalCopy)


    def UseInternalCopyOn(self):
        """
        UseInternalCopyOn(ReconstructionByDilationImageFilter self)



        Set the value of UseInternalCopy to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_UseInternalCopyOn(self)


    def UseInternalCopyOff(self):
        """
        UseInternalCopyOff(ReconstructionByDilationImageFilter self)



        """
        return _SimpleITK.ReconstructionByDilationImageFilter_UseInternalCopyOff(self)


    def GetUseInternalCopy(self):
        """
        GetUseInternalCopy(ReconstructionByDilationImageFilter self) -> bool



        """
        return _SimpleITK.ReconstructionByDilationImageFilter_GetUseInternalCopy(self)


    def GetName(self):
        """
        GetName(ReconstructionByDilationImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ReconstructionByDilationImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ReconstructionByDilationImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ReconstructionByDilationImageFilter self, Image image1, Image image2) -> Image
        Execute(ReconstructionByDilationImageFilter self, Image image1, Image image2, bool fullyConnected, bool useInternalCopy) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ReconstructionByDilationImageFilter_Execute(self, *args)

ReconstructionByDilationImageFilter_swigregister = _SimpleITK.ReconstructionByDilationImageFilter_swigregister
ReconstructionByDilationImageFilter_swigregister(ReconstructionByDilationImageFilter)


def ReconstructionByDilation(image1, image2, fullyConnected=False, useInternalCopy=True):
    """
    ReconstructionByDilation(Image image1, Image image2, bool fullyConnected=False, bool useInternalCopy=True) -> Image



    grayscale reconstruction by dilation of an image


    This function directly calls the execute method of ReconstructionByDilationImageFilter in order to support a procedural API


    See:
     itk::simple::ReconstructionByDilationImageFilter for the object oriented interface



    """
    return _SimpleITK.ReconstructionByDilation(image1, image2, fullyConnected, useInternalCopy)
class ReconstructionByErosionImageFilter(ImageFilter_2):
    """


    grayscale reconstruction by erosion of an image


    Reconstruction by erosion operates on a "marker" image and a
    "mask" image, and is defined as the erosion of the marker image with
    respect to the mask image iterated until stability.

    The marker image must be less than or equal to the mask image (on a
    pixel by pixel basis).

    Geodesic morphology is described in Chapter 6.2 of Pierre Soille's
    book "Morphological Image Analysis: Principles and Applications",
    Second Edition, Springer, 2003.

    Algorithm implemented in this filter is based on algorithm described
    by Kevin Robinson and Paul F. Whelan in "Efficient Morphological
    Reconstruction: A Downhill Filter", Pattern Recognition Letters,
    Volume 25, Issue 15, November 2004, Pages 1759-1767.

    The algorithm, a description of the transform and some applications
    can be found in "Morphological Grayscale Reconstruction in Image
    Analysis:  Applications and Efficient Algorithms", Luc Vincent, IEEE
    Transactions on image processing, Vol. 2, April 1993.


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     MorphologyImageFilter , GrayscaleDilateImageFilter , GrayscaleFunctionDilateImageFilter , BinaryDilateImageFilter , ReconstructionByErosionImageFilter , OpeningByReconstructionImageFilter , ClosingByReconstructionImageFilter , ReconstructionImageFilter

     itk::simple::ReconstructionByErosion for the procedural interface

     itk::ReconstructionByErosionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkReconstructionByErosionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReconstructionByErosionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReconstructionByErosionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ReconstructionByErosionImageFilter self) -> ReconstructionByErosionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ReconstructionByErosionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ReconstructionByErosionImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ReconstructionByErosionImageFilter self, bool FullyConnected)



        """
        return _SimpleITK.ReconstructionByErosionImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ReconstructionByErosionImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ReconstructionByErosionImageFilter self)



        """
        return _SimpleITK.ReconstructionByErosionImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ReconstructionByErosionImageFilter self) -> bool



        """
        return _SimpleITK.ReconstructionByErosionImageFilter_GetFullyConnected(self)


    def SetUseInternalCopy(self, UseInternalCopy):
        """
        SetUseInternalCopy(ReconstructionByErosionImageFilter self, bool UseInternalCopy)



        """
        return _SimpleITK.ReconstructionByErosionImageFilter_SetUseInternalCopy(self, UseInternalCopy)


    def UseInternalCopyOn(self):
        """
        UseInternalCopyOn(ReconstructionByErosionImageFilter self)



        Set the value of UseInternalCopy to true or false respectfully.


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_UseInternalCopyOn(self)


    def UseInternalCopyOff(self):
        """
        UseInternalCopyOff(ReconstructionByErosionImageFilter self)



        """
        return _SimpleITK.ReconstructionByErosionImageFilter_UseInternalCopyOff(self)


    def GetUseInternalCopy(self):
        """
        GetUseInternalCopy(ReconstructionByErosionImageFilter self) -> bool



        """
        return _SimpleITK.ReconstructionByErosionImageFilter_GetUseInternalCopy(self)


    def GetName(self):
        """
        GetName(ReconstructionByErosionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ReconstructionByErosionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ReconstructionByErosionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ReconstructionByErosionImageFilter self, Image image1, Image image2) -> Image
        Execute(ReconstructionByErosionImageFilter self, Image image1, Image image2, bool fullyConnected, bool useInternalCopy) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ReconstructionByErosionImageFilter_Execute(self, *args)

ReconstructionByErosionImageFilter_swigregister = _SimpleITK.ReconstructionByErosionImageFilter_swigregister
ReconstructionByErosionImageFilter_swigregister(ReconstructionByErosionImageFilter)


def ReconstructionByErosion(image1, image2, fullyConnected=False, useInternalCopy=True):
    """
    ReconstructionByErosion(Image image1, Image image2, bool fullyConnected=False, bool useInternalCopy=True) -> Image



    grayscale reconstruction by erosion of an image


    This function directly calls the execute method of ReconstructionByErosionImageFilter in order to support a procedural API


    See:
     itk::simple::ReconstructionByErosionImageFilter for the object oriented interface



    """
    return _SimpleITK.ReconstructionByErosion(image1, image2, fullyConnected, useInternalCopy)
class RecursiveGaussianImageFilter(ImageFilter_1):
    """


    Base class for computing IIR convolution with an approximation of a
    Gaussian kernel.


    \\[ \\frac{ 1 }{ \\sigma \\sqrt{ 2 \\pi } } \\exp{
    \\left( - \\frac{x^2}{ 2 \\sigma^2 } \\right) } \\]

    RecursiveGaussianImageFilter is the base class for recursive filters that approximate convolution
    with the Gaussian kernel. This class implements the recursive
    filtering method proposed by R.Deriche in IEEE-PAMI Vol.12, No.1,
    January 1990, pp 78-87, "Fast Algorithms for Low-Level Vision"

    Details of the implementation are described in the technical report: R.
    Deriche, "Recursively Implementing The Gaussian and Its
    Derivatives", INRIA, 1993, ftp://ftp.inria.fr/INRIA/tech-reports/RR/RR-1893.ps.gz

    Further improvements of the algorithm are described in: G. Farneback &
    C.-F. Westin, "On Implementation of Recursive Gaussian Filters", so
    far unpublished.

    As compared to itk::DiscreteGaussianImageFilter , this filter tends to be faster for large kernels, and it can take
    the derivative of the blurred image in one step. Also, note that we
    have itk::RecursiveGaussianImageFilter::SetSigma() , but itk::DiscreteGaussianImageFilter::SetVariance() .


    See:
     DiscreteGaussianImageFilter
    Wiki Examples:

    All Examples

    Find higher derivatives of an image
    See:
     itk::simple::RecursiveGaussian for the procedural interface

     itk::RecursiveGaussianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRecursiveGaussianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecursiveGaussianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RecursiveGaussianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RecursiveGaussianImageFilter self) -> RecursiveGaussianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RecursiveGaussianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RecursiveGaussianImageFilter
    __del__ = lambda self: None

    def SetSigma(self, Sigma):
        """
        SetSigma(RecursiveGaussianImageFilter self, double Sigma)



        Set/Get the Sigma, measured in world coordinates, of the Gaussian
        kernel. The default is 1.0. An exception will be generated if the
        Sigma value is less than or equal to zero.


        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetSigma(self, Sigma)


    def GetSigma(self):
        """
        GetSigma(RecursiveGaussianImageFilter self) -> double



        Set/Get the Sigma, measured in world coordinates, of the Gaussian
        kernel. The default is 1.0. An exception will be generated if the
        Sigma value is less than or equal to zero.


        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetSigma(self)


    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        """
        SetNormalizeAcrossScale(RecursiveGaussianImageFilter self, bool NormalizeAcrossScale)



             Set/Get the flag for normalizing the gaussian over scale-space.

        This flag enables the analysis of the differential shape of features
        independent of their size ( both pixels and physical size ). Following
        the notation of Tony Lindeberg:

        Let \\[ L(x; t) = g(x; t) \\ast f(x) \\] be the scale-space representation of image \\[ f(x) \\] where \\[ g(x; t) = \\frac{1}{ \\sqrt{ 2 \\pi t} } \\exp{
        \\left( -\\frac{x^2}{ 2 t } \\right) } \\] is the Gaussian function and \\[\\ast\\] denotes convolution. This is a change from above with \\[ t = \\sigma^2 \\] .

        Then the normalized derivative operator for normalized coordinates
        across scale is:

        \\[ \\partial_\\xi = \\sqrt{t} \\partial_x \\]

        The resulting scaling factor is \\[ \\sigma^N \\] where N is the order of the derivative.

        When this flag is ON the filter will be normalized in such a way that
        the values of derivatives are not biased by the size of the object.
        That is to say the maximum value a feature reaches across scale is
        independent of the scale of the object.

        For analyzing an image across scale-space you want to enable this
        flag. It is disabled by default.


        Not all scale space axioms are satisfied by this filter, some are only
        approximated. Particularly, at fine scales ( say less than 1 pixel )
        other methods such as a discrete Gaussian kernel should be considered.



        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetNormalizeAcrossScale(self, NormalizeAcrossScale)


    def NormalizeAcrossScaleOn(self):
        """
        NormalizeAcrossScaleOn(RecursiveGaussianImageFilter self)



        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.RecursiveGaussianImageFilter_NormalizeAcrossScaleOn(self)


    def NormalizeAcrossScaleOff(self):
        """
        NormalizeAcrossScaleOff(RecursiveGaussianImageFilter self)



        """
        return _SimpleITK.RecursiveGaussianImageFilter_NormalizeAcrossScaleOff(self)


    def GetNormalizeAcrossScale(self):
        """
        GetNormalizeAcrossScale(RecursiveGaussianImageFilter self) -> bool



        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetNormalizeAcrossScale(self)

    ZeroOrder = _SimpleITK.RecursiveGaussianImageFilter_ZeroOrder
    FirstOrder = _SimpleITK.RecursiveGaussianImageFilter_FirstOrder
    SecondOrder = _SimpleITK.RecursiveGaussianImageFilter_SecondOrder

    def SetOrder(self, Order):
        """
        SetOrder(RecursiveGaussianImageFilter self, itk::simple::RecursiveGaussianImageFilter::OrderType Order)



             Set/Get the Order of the Gaussian to convolve with.


        ZeroOrder is equivalent to convolving with a Gaussian. This is the
        default.

        FirstOrder is equivalent to convolving with the first derivative of a
        Gaussian.

        SecondOrder is equivalent to convolving with the second derivative of
        a Gaussian.



        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetOrder(self, Order)


    def GetOrder(self):
        """
        GetOrder(RecursiveGaussianImageFilter self) -> itk::simple::RecursiveGaussianImageFilter::OrderType



             Set/Get the Order of the Gaussian to convolve with.


        ZeroOrder is equivalent to convolving with a Gaussian. This is the
        default.

        FirstOrder is equivalent to convolving with the first derivative of a
        Gaussian.

        SecondOrder is equivalent to convolving with the second derivative of
        a Gaussian.



        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetOrder(self)


    def SetDirection(self, Direction):
        """
        SetDirection(RecursiveGaussianImageFilter self, unsigned int Direction)



        """
        return _SimpleITK.RecursiveGaussianImageFilter_SetDirection(self, Direction)


    def GetDirection(self):
        """
        GetDirection(RecursiveGaussianImageFilter self) -> unsigned int



        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetDirection(self)


    def GetName(self):
        """
        GetName(RecursiveGaussianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RecursiveGaussianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RecursiveGaussianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RecursiveGaussianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RecursiveGaussianImageFilter self, Image image1) -> Image
        Execute(RecursiveGaussianImageFilter self, Image image1, double sigma, bool normalizeAcrossScale, itk::simple::RecursiveGaussianImageFilter::OrderType order, unsigned int direction) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RecursiveGaussianImageFilter_Execute(self, *args)

RecursiveGaussianImageFilter_swigregister = _SimpleITK.RecursiveGaussianImageFilter_swigregister
RecursiveGaussianImageFilter_swigregister(RecursiveGaussianImageFilter)


def RecursiveGaussian(*args, **kwargs):
    """
    RecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False, itk::simple::RecursiveGaussianImageFilter::OrderType order, unsigned int direction=0) -> Image



    Base class for computing IIR convolution with an approximation of a
    Gaussian kernel.


    This function directly calls the execute method of RecursiveGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::RecursiveGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.RecursiveGaussian(*args, **kwargs)
class RegionOfInterestImageFilter(ImageFilter_1):
    """


    Extract a region of interest from the input image.


    This filter produces an output image of the same dimension as the
    input image. The user specifies the region of the input image that
    will be contained in the output image. The origin coordinates of the
    output images will be computed in such a way that if mapped to
    physical space, the output image will overlay the input image with
    perfect registration. In other words, a registration process between
    the output image and the input image will return an identity
    transform.

    If you are interested in changing the dimension of the image, you may
    want to consider the ExtractImageFilter . For example for extracting a 2D image from a slice of a 3D image.

    The region to extract is set using the method SetRegionOfInterest.


    See:
     ExtractImageFilter
    Wiki Examples:

    All Examples

    Extract a portion of an image (region of interest)
    See:
     itk::simple::RegionOfInterest for the procedural interface

     itk::RegionOfInterestImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRegionOfInterestImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionOfInterestImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RegionOfInterestImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RegionOfInterestImageFilter self) -> RegionOfInterestImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RegionOfInterestImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RegionOfInterestImageFilter
    __del__ = lambda self: None

    def SetSize(self, Size):
        """
        SetSize(RegionOfInterestImageFilter self, VectorUInt32 Size)



        """
        return _SimpleITK.RegionOfInterestImageFilter_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(RegionOfInterestImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.RegionOfInterestImageFilter_GetSize(self)


    def SetIndex(self, Index):
        """
        SetIndex(RegionOfInterestImageFilter self, VectorInt32 Index)



        odo the internal setting of the method need work!!!


        """
        return _SimpleITK.RegionOfInterestImageFilter_SetIndex(self, Index)


    def GetIndex(self):
        """
        GetIndex(RegionOfInterestImageFilter self) -> VectorInt32



        """
        return _SimpleITK.RegionOfInterestImageFilter_GetIndex(self)


    def GetName(self):
        """
        GetName(RegionOfInterestImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RegionOfInterestImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RegionOfInterestImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RegionOfInterestImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RegionOfInterestImageFilter self, Image image1) -> Image
        Execute(RegionOfInterestImageFilter self, Image image1, VectorUInt32 size, VectorInt32 index) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RegionOfInterestImageFilter_Execute(self, *args)

RegionOfInterestImageFilter_swigregister = _SimpleITK.RegionOfInterestImageFilter_swigregister
RegionOfInterestImageFilter_swigregister(RegionOfInterestImageFilter)


def RegionOfInterest(*args, **kwargs):
    """
    RegionOfInterest(Image image1, VectorUInt32 size, VectorInt32 index) -> Image



    Extract a region of interest from the input image.


    This function directly calls the execute method of RegionOfInterestImageFilter in order to support a procedural API


    See:
     itk::simple::RegionOfInterestImageFilter for the object oriented interface



    """
    return _SimpleITK.RegionOfInterest(*args, **kwargs)
class RegionalMaximaImageFilter(ImageFilter_1):
    """


    Produce a binary image where foreground is the regional maxima of the
    input image.


    Regional maxima are flat zones surrounded by pixels of lower value.

    If the input image is constant, the entire image can be considered as
    a maxima or not. The desired behavior can be selected with the SetFlatIsMaxima() method.


    Gaetan Lehmann
     This class was contributed to the Insight Journal by author Gaetan
    Lehmann. Biologie du Developpement et de la Reproduction, INRA de
    Jouy-en-Josas, France. The paper can be found at https://hdl.handle.net/1926/153


    See:
     ValuedRegionalMaximaImageFilter

     HConvexImageFilter

     RegionalMinimaImageFilter
    Wiki Examples:

    All Examples

    RegionalMaximaImageFilter
    See:
     itk::simple::RegionalMaxima for the procedural interface

     itk::RegionalMaximaImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRegionalMaximaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionalMaximaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RegionalMaximaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RegionalMaximaImageFilter self) -> RegionalMaximaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RegionalMaximaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RegionalMaximaImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(RegionalMaximaImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(RegionalMaximaImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(RegionalMaximaImageFilter self, double ForegroundValue)



        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(RegionalMaximaImageFilter self) -> double



        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetForegroundValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(RegionalMaximaImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(RegionalMaximaImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.RegionalMaximaImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(RegionalMaximaImageFilter self)



        """
        return _SimpleITK.RegionalMaximaImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(RegionalMaximaImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetFullyConnected(self)


    def SetFlatIsMaxima(self, FlatIsMaxima):
        """
        SetFlatIsMaxima(RegionalMaximaImageFilter self, bool FlatIsMaxima)



        Set/Get wether a flat image must be considered as a maxima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMaximaImageFilter_SetFlatIsMaxima(self, FlatIsMaxima)


    def FlatIsMaximaOn(self):
        """
        FlatIsMaximaOn(RegionalMaximaImageFilter self)



        Set the value of FlatIsMaxima to true or false respectfully.


        """
        return _SimpleITK.RegionalMaximaImageFilter_FlatIsMaximaOn(self)


    def FlatIsMaximaOff(self):
        """
        FlatIsMaximaOff(RegionalMaximaImageFilter self)



        """
        return _SimpleITK.RegionalMaximaImageFilter_FlatIsMaximaOff(self)


    def GetFlatIsMaxima(self):
        """
        GetFlatIsMaxima(RegionalMaximaImageFilter self) -> bool



        Set/Get wether a flat image must be considered as a maxima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetFlatIsMaxima(self)


    def GetName(self):
        """
        GetName(RegionalMaximaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RegionalMaximaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RegionalMaximaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RegionalMaximaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RegionalMaximaImageFilter self, Image image1) -> Image
        Execute(RegionalMaximaImageFilter self, Image image1, double backgroundValue, double foregroundValue, bool fullyConnected, bool flatIsMaxima) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RegionalMaximaImageFilter_Execute(self, *args)

RegionalMaximaImageFilter_swigregister = _SimpleITK.RegionalMaximaImageFilter_swigregister
RegionalMaximaImageFilter_swigregister(RegionalMaximaImageFilter)


def RegionalMaxima(image1, backgroundValue=0.0, foregroundValue=1.0, fullyConnected=False, flatIsMaxima=True):
    """
    RegionalMaxima(Image image1, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False, bool flatIsMaxima=True) -> Image



    Produce a binary image where foreground is the regional maxima of the
    input image.


    This function directly calls the execute method of RegionalMaximaImageFilter in order to support a procedural API


    See:
     itk::simple::RegionalMaximaImageFilter for the object oriented interface



    """
    return _SimpleITK.RegionalMaxima(image1, backgroundValue, foregroundValue, fullyConnected, flatIsMaxima)
class RegionalMinimaImageFilter(ImageFilter_1):
    """


    Produce a binary image where foreground is the regional minima of the
    input image.


    Regional minima are flat zones surrounded by pixels of greater value.

    If the input image is constant, the entire image can be considered as
    a minima or not. The SetFlatIsMinima() method let the user choose which behavior to use.

    This class was contribtued to the Insight Journal by
    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France. https://hdl.handle.net/1926/153
    RegionalMaximaImageFilter MathematicalMorphologyImageFilters


    See:
     ValuedRegionalMinimaImageFilter

     HConcaveImageFilter
    Wiki Examples:

    All Examples

    RegionalMinimaImageFilter
    See:
     itk::simple::RegionalMinima for the procedural interface

     itk::RegionalMinimaImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRegionalMinimaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegionalMinimaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RegionalMinimaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RegionalMinimaImageFilter self) -> RegionalMinimaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RegionalMinimaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RegionalMinimaImageFilter
    __del__ = lambda self: None

    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(RegionalMinimaImageFilter self, double BackgroundValue)



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(RegionalMinimaImageFilter self) -> double



        Set/Get the value used as "background" in the output image. Defaults
        to NumericTraits<PixelType>::NonpositiveMin() .


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetBackgroundValue(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(RegionalMinimaImageFilter self, double ForegroundValue)



        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(RegionalMinimaImageFilter self) -> double



        Set/Get the value in the output image to consider as "foreground".
        Defaults to maximum value of PixelType.


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetForegroundValue(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(RegionalMinimaImageFilter self, bool FullyConnected)



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(RegionalMinimaImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.RegionalMinimaImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(RegionalMinimaImageFilter self)



        """
        return _SimpleITK.RegionalMinimaImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(RegionalMinimaImageFilter self) -> bool



        Set/Get whether the connected components are defined strictly by face
        connectivity or by face+edge+vertex connectivity. Default is
        FullyConnectedOff. For objects that are 1 pixel wide, use
        FullyConnectedOn.


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetFullyConnected(self)


    def SetFlatIsMinima(self, FlatIsMinima):
        """
        SetFlatIsMinima(RegionalMinimaImageFilter self, bool FlatIsMinima)



        Set/Get wether a flat image must be considered as a minima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMinimaImageFilter_SetFlatIsMinima(self, FlatIsMinima)


    def FlatIsMinimaOn(self):
        """
        FlatIsMinimaOn(RegionalMinimaImageFilter self)



        Set the value of FlatIsMinima to true or false respectfully.


        """
        return _SimpleITK.RegionalMinimaImageFilter_FlatIsMinimaOn(self)


    def FlatIsMinimaOff(self):
        """
        FlatIsMinimaOff(RegionalMinimaImageFilter self)



        """
        return _SimpleITK.RegionalMinimaImageFilter_FlatIsMinimaOff(self)


    def GetFlatIsMinima(self):
        """
        GetFlatIsMinima(RegionalMinimaImageFilter self) -> bool



        Set/Get wether a flat image must be considered as a minima or not.
        Defaults to true.


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetFlatIsMinima(self)


    def GetName(self):
        """
        GetName(RegionalMinimaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RegionalMinimaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RegionalMinimaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RegionalMinimaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RegionalMinimaImageFilter self, Image image1) -> Image
        Execute(RegionalMinimaImageFilter self, Image image1, double backgroundValue, double foregroundValue, bool fullyConnected, bool flatIsMinima) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RegionalMinimaImageFilter_Execute(self, *args)

RegionalMinimaImageFilter_swigregister = _SimpleITK.RegionalMinimaImageFilter_swigregister
RegionalMinimaImageFilter_swigregister(RegionalMinimaImageFilter)


def RegionalMinima(image1, backgroundValue=0.0, foregroundValue=1.0, fullyConnected=False, flatIsMinima=True):
    """
    RegionalMinima(Image image1, double backgroundValue=0.0, double foregroundValue=1.0, bool fullyConnected=False, bool flatIsMinima=True) -> Image



    Produce a binary image where foreground is the regional minima of the
    input image.


    This function directly calls the execute method of RegionalMinimaImageFilter in order to support a procedural API


    See:
     itk::simple::RegionalMinimaImageFilter for the object oriented interface



    """
    return _SimpleITK.RegionalMinima(image1, backgroundValue, foregroundValue, fullyConnected, flatIsMinima)
class RelabelComponentImageFilter(ImageFilter_1):
    """


    Relabel the components in an image such that consecutive labels are
    used.


    RelabelComponentImageFilter remaps the labels associated with the objects in an image (as from
    the output of ConnectedComponentImageFilter ) such that the label numbers are consecutive with no gaps between
    the label numbers used. By default, the relabeling will also sort the
    labels based on the size of the object: the largest object will have
    label #1, the second largest will have label #2, etc. If two labels
    have the same size their initial order is kept. The sorting by size
    can be disabled using SetSortByObjectSize.

    Label #0 is assumed to be the background and is left unaltered by the
    relabeling.

    RelabelComponentImageFilter is typically used on the output of the ConnectedComponentImageFilter for those applications that want to extract the largest object or the
    "k" largest objects. Any particular object can be extracted from the
    relabeled output using a BinaryThresholdImageFilter . A group of objects can be extracted from the relabled output using
    a ThresholdImageFilter .

    Once all the objects are relabeled, the application can query the
    number of objects and the size of each object. Object sizes are returned in a vector. The size of the background is not
    calculated. So the size of object #1 is GetSizeOfObjectsInPixels()
    [0], the size of object #2 is GetSizeOfObjectsInPixels() [1], etc.

    If user sets a minimum object size, all objects with fewer pixels than
    the minimum will be discarded, so that the number of objects reported
    will be only those remaining. The GetOriginalNumberOfObjects method
    can be called to find out how many objects were present before the
    small ones were discarded.

    RelabelComponentImageFilter can be run as an "in place" filter, where it will overwrite its
    output. The default is run out of place (or generate a separate
    output). "In place" operation can be controlled via methods in the
    superclass, InPlaceImageFilter::InPlaceOn() and
    InPlaceImageFilter::InPlaceOff() .


    See:
     ConnectedComponentImageFilter , BinaryThresholdImageFilter , ThresholdImageFilter
    Wiki Examples:

    All Examples

    Assign contiguous labels to connected regions of an image
    See:
     itk::simple::RelabelComponent for the procedural interface

     itk::RelabelComponentImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRelabelComponentImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RelabelComponentImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RelabelComponentImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RelabelComponentImageFilter self) -> RelabelComponentImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RelabelComponentImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RelabelComponentImageFilter
    __del__ = lambda self: None

    def SetMinimumObjectSize(self, MinimumObjectSize):
        """
        SetMinimumObjectSize(RelabelComponentImageFilter self, uint64_t MinimumObjectSize)



        Set the minimum size in pixels for an object. All objects smaller than
        this size will be discarded and will not appear in the output label
        map. NumberOfObjects will count only the objects whose pixel counts
        are greater than or equal to the minimum size. Call
        GetOriginalNumberOfObjects to find out how many objects were present
        in the original label map.


        """
        return _SimpleITK.RelabelComponentImageFilter_SetMinimumObjectSize(self, MinimumObjectSize)


    def GetMinimumObjectSize(self):
        """
        GetMinimumObjectSize(RelabelComponentImageFilter self) -> uint64_t



        Get the caller-defined minimum size of an object in pixels. If the
        caller has not set the minimum, 0 will be returned, which is to be
        interpreted as meaning that no minimum exists, and all objects in the
        original label map will be passed through to the output.


        """
        return _SimpleITK.RelabelComponentImageFilter_GetMinimumObjectSize(self)


    def GetName(self):
        """
        GetName(RelabelComponentImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RelabelComponentImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RelabelComponentImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RelabelComponentImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RelabelComponentImageFilter self, Image image1) -> Image
        Execute(RelabelComponentImageFilter self, Image image1, uint64_t minimumObjectSize) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RelabelComponentImageFilter_Execute(self, *args)

RelabelComponentImageFilter_swigregister = _SimpleITK.RelabelComponentImageFilter_swigregister
RelabelComponentImageFilter_swigregister(RelabelComponentImageFilter)


def RelabelComponent(image1, minimumObjectSize=0):
    """
    RelabelComponent(Image image1, uint64_t minimumObjectSize=0) -> Image



    Relabel the components in an image such that consecutive labels are
    used.


    This function directly calls the execute method of RelabelComponentImageFilter in order to support a procedural API


    See:
     itk::simple::RelabelComponentImageFilter for the object oriented interface



    """
    return _SimpleITK.RelabelComponent(image1, minimumObjectSize)
class RelabelLabelMapFilter(ImageFilter_1):
    """


    This filter relabels the LabelObjects; the new labels are arranged
    consecutively with consideration for the background value.


    This filter takes the LabelObjects from the input and reassigns them
    to the output by calling the PushLabelObject method, which by default,
    attempts to reorganize the labels consecutively. The user can assign
    an arbitrary value to the background; the filter will assign the
    labels consecutively by skipping the background value.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/1926/584 or http://www.insight-journal.org/browse/publication/176
    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ShapeLabelObject , RelabelComponentImageFilter

     itk::simple::RelabelLabelMapFilter for the procedural interface

     itk::RelabelLabelMapFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRelabelLabelMapFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RelabelLabelMapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RelabelLabelMapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RelabelLabelMapFilter self) -> RelabelLabelMapFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RelabelLabelMapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RelabelLabelMapFilter
    __del__ = lambda self: None

    def SetReverseOrdering(self, ReverseOrdering):
        """
        SetReverseOrdering(RelabelLabelMapFilter self, bool ReverseOrdering)



        """
        return _SimpleITK.RelabelLabelMapFilter_SetReverseOrdering(self, ReverseOrdering)


    def ReverseOrderingOn(self):
        """
        ReverseOrderingOn(RelabelLabelMapFilter self)



        Set the value of ReverseOrdering to true or false respectfully.


        """
        return _SimpleITK.RelabelLabelMapFilter_ReverseOrderingOn(self)


    def ReverseOrderingOff(self):
        """
        ReverseOrderingOff(RelabelLabelMapFilter self)



        """
        return _SimpleITK.RelabelLabelMapFilter_ReverseOrderingOff(self)


    def GetReverseOrdering(self):
        """
        GetReverseOrdering(RelabelLabelMapFilter self) -> bool



        """
        return _SimpleITK.RelabelLabelMapFilter_GetReverseOrdering(self)


    def GetName(self):
        """
        GetName(RelabelLabelMapFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RelabelLabelMapFilter_GetName(self)


    def __str__(self):
        """
        __str__(RelabelLabelMapFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RelabelLabelMapFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RelabelLabelMapFilter self, Image image1) -> Image
        Execute(RelabelLabelMapFilter self, Image image1, bool reverseOrdering) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RelabelLabelMapFilter_Execute(self, *args)

RelabelLabelMapFilter_swigregister = _SimpleITK.RelabelLabelMapFilter_swigregister
RelabelLabelMapFilter_swigregister(RelabelLabelMapFilter)


def RelabelLabelMap(image1, reverseOrdering=True):
    """
    RelabelLabelMap(Image image1, bool reverseOrdering=True) -> Image



    This filter relabels the LabelObjects; the new labels are arranged
    consecutively with consideration for the background value.


    This function directly calls the execute method of RelabelLabelMapFilter in order to support a procedural API


    See:
     itk::simple::RelabelLabelMapFilter for the object oriented interface



    """
    return _SimpleITK.RelabelLabelMap(image1, reverseOrdering)
class RenyiEntropyThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the RenyiEntropy Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the RenyiEntropyThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::RenyiEntropyThreshold for the procedural interface

     itk::RenyiEntropyThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRenyiEntropyThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RenyiEntropyThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RenyiEntropyThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RenyiEntropyThresholdImageFilter self) -> RenyiEntropyThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RenyiEntropyThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RenyiEntropyThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(RenyiEntropyThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(RenyiEntropyThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(RenyiEntropyThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(RenyiEntropyThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(RenyiEntropyThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(RenyiEntropyThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(RenyiEntropyThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(RenyiEntropyThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(RenyiEntropyThresholdImageFilter self)



        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(RenyiEntropyThresholdImageFilter self) -> bool



        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(RenyiEntropyThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(RenyiEntropyThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(RenyiEntropyThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(RenyiEntropyThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RenyiEntropyThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RenyiEntropyThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(RenyiEntropyThresholdImageFilter self, Image image) -> Image
        Execute(RenyiEntropyThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(RenyiEntropyThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.RenyiEntropyThresholdImageFilter_Execute(self, *args)

RenyiEntropyThresholdImageFilter_swigregister = _SimpleITK.RenyiEntropyThresholdImageFilter_swigregister
RenyiEntropyThresholdImageFilter_swigregister(RenyiEntropyThresholdImageFilter)


def RenyiEntropyThreshold(*args):
    """
    RenyiEntropyThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    RenyiEntropyThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.RenyiEntropyThreshold(*args)
class ResampleImageFilter(ImageFilter_1):
    """


    Resample an image via a coordinate transform.


    ResampleImageFilter resamples an existing image through some coordinate transform,
    interpolating via some image function. The class is templated over the
    types of the input and output images.

    Note that the choice of interpolator function can be important. This
    function is set via SetInterpolator() . The default is LinearInterpolateImageFunction <InputImageType, TInterpolatorPrecisionType>, which is reasonable for
    ordinary medical images. However, some synthetic images have pixels
    drawn from a finite prescribed set. An example would be a mask
    indicating the segmentation of a brain into a small number of tissue
    types. For such an image, one does not want to interpolate between
    different pixel values, and so NearestNeighborInterpolateImageFunction < InputImageType, TCoordRep > would be a better choice.

    If an sample is taken from outside the image domain, the default
    behavior is to use a default pixel value. If different behavior is
    desired, an extrapolator function can be set with SetExtrapolator() .

    Output information (spacing, size and direction) for the output image
    should be set. This information has the normal defaults of unit
    spacing, zero origin and identity direction. Optionally, the output
    information can be obtained from a reference image. If the reference
    image is provided and UseReferenceImage is On, then the spacing,
    origin and direction of the reference image will be used.

    Since this filter produces an image which is a different size than its
    input, it needs to override several of the methods defined in ProcessObject in order to properly manage the pipeline execution model. In
    particular, this filter overrides
    ProcessObject::GenerateInputRequestedRegion() and
    ProcessObject::GenerateOutputInformation() .

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.
    WARNING:
    For multithreading, the TransformPoint method of the user-designated
    coordinate transform must be threadsafe.
    Wiki Examples:

    All Examples

    Translate an image

    Upsampling an image

    Resample (stretch or compress) an image

    See:
     itk::ResampleImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkResampleImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResampleImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ResampleImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ResampleImageFilter self) -> ResampleImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ResampleImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ResampleImageFilter
    __del__ = lambda self: None

    def SetSize(self, Size):
        """
        SetSize(ResampleImageFilter self, VectorUInt32 Size)



        Get/Set the size of the output image.


        """
        return _SimpleITK.ResampleImageFilter_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(ResampleImageFilter self) -> VectorUInt32



        Get/Set the size of the output image.


        """
        return _SimpleITK.ResampleImageFilter_GetSize(self)


    def SetTransform(self, Transform):
        """
        SetTransform(ResampleImageFilter self, Transform Transform)



        Get/Set the coordinate transformation. Set the coordinate transform to
        use for resampling. Note that this must be in physical coordinates and
        it is the output-to-input transform, NOT the input-to-output transform
        that you might naively expect. By default the filter uses an Identity
        transform. You must provide a different transform here, before
        attempting to run the filter, if you do not want to use the default
        Identity transform.


        """
        return _SimpleITK.ResampleImageFilter_SetTransform(self, Transform)


    def GetTransform(self):
        """
        GetTransform(ResampleImageFilter self) -> Transform



        Get/Set the coordinate transformation. Set the coordinate transform to
        use for resampling. Note that this must be in physical coordinates and
        it is the output-to-input transform, NOT the input-to-output transform
        that you might naively expect. By default the filter uses an Identity
        transform. You must provide a different transform here, before
        attempting to run the filter, if you do not want to use the default
        Identity transform.


        """
        return _SimpleITK.ResampleImageFilter_GetTransform(self)


    def SetInterpolator(self, Interpolator):
        """
        SetInterpolator(ResampleImageFilter self, itk::simple::InterpolatorEnum Interpolator)



        Get/Set the interpolator function. The default is LinearInterpolateImageFunction <InputImageType, TInterpolatorPrecisionType>. Some other options are NearestNeighborInterpolateImageFunction (useful for binary masks and other images with a small number of
        possible pixel values), and BSplineInterpolateImageFunction (which provides a higher order of interpolation).


        """
        return _SimpleITK.ResampleImageFilter_SetInterpolator(self, Interpolator)


    def GetInterpolator(self):
        """
        GetInterpolator(ResampleImageFilter self) -> itk::simple::InterpolatorEnum



        Get/Set the interpolator function. The default is LinearInterpolateImageFunction <InputImageType, TInterpolatorPrecisionType>. Some other options are NearestNeighborInterpolateImageFunction (useful for binary masks and other images with a small number of
        possible pixel values), and BSplineInterpolateImageFunction (which provides a higher order of interpolation).


        """
        return _SimpleITK.ResampleImageFilter_GetInterpolator(self)


    def SetOutputOrigin(self, OutputOrigin):
        """
        SetOutputOrigin(ResampleImageFilter self, VectorDouble OutputOrigin)



        Set the output image origin.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputOrigin(self, OutputOrigin)


    def GetOutputOrigin(self):
        """
        GetOutputOrigin(ResampleImageFilter self) -> VectorDouble



        Get the output image origin.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputOrigin(self)


    def SetOutputSpacing(self, OutputSpacing):
        """
        SetOutputSpacing(ResampleImageFilter self, VectorDouble OutputSpacing)



        Set the output image spacing.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputSpacing(self, OutputSpacing)


    def GetOutputSpacing(self):
        """
        GetOutputSpacing(ResampleImageFilter self) -> VectorDouble



        Get the output image spacing.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputSpacing(self)


    def SetOutputDirection(self, OutputDirection):
        """
        SetOutputDirection(ResampleImageFilter self, VectorDouble OutputDirection)



        Set the output direciton cosine matrix.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputDirection(self, OutputDirection)


    def GetOutputDirection(self):
        """
        GetOutputDirection(ResampleImageFilter self) -> VectorDouble



        Set the output direciton cosine matrix.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputDirection(self)


    def SetDefaultPixelValue(self, DefaultPixelValue):
        """
        SetDefaultPixelValue(ResampleImageFilter self, double DefaultPixelValue)



        Get/Set the pixel value when a transformed pixel is outside of the
        image. The default default pixel value is 0.


        """
        return _SimpleITK.ResampleImageFilter_SetDefaultPixelValue(self, DefaultPixelValue)


    def GetDefaultPixelValue(self):
        """
        GetDefaultPixelValue(ResampleImageFilter self) -> double



        Get/Set the pixel value when a transformed pixel is outside of the
        image. The default default pixel value is 0.


        """
        return _SimpleITK.ResampleImageFilter_GetDefaultPixelValue(self)


    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(ResampleImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)



        Set the output pixel type, if sitkUnknown then the input type is used.


        """
        return _SimpleITK.ResampleImageFilter_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(ResampleImageFilter self) -> itk::simple::PixelIDValueEnum



        Get the ouput pixel type.


        """
        return _SimpleITK.ResampleImageFilter_GetOutputPixelType(self)


    def GetName(self):
        """
        GetName(ResampleImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ResampleImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ResampleImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ResampleImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ResampleImageFilter self, Image image1) -> Image
        Execute(ResampleImageFilter self, Image image1, VectorUInt32 size, Transform transform, itk::simple::InterpolatorEnum interpolator, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double defaultPixelValue, itk::simple::PixelIDValueEnum outputPixelType) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ResampleImageFilter_Execute(self, *args)


    def SetReferenceImage(self, refImage):
        """
        SetReferenceImage(ResampleImageFilter self, Image refImage)



        This methods sets the output size, origin, spacing and direction to
        that of the provided image


        """
        return _SimpleITK.ResampleImageFilter_SetReferenceImage(self, refImage)

ResampleImageFilter_swigregister = _SimpleITK.ResampleImageFilter_swigregister
ResampleImageFilter_swigregister(ResampleImageFilter)

class RescaleIntensityImageFilter(ImageFilter_1):
    """


    Applies a linear transformation to the intensity levels of the input Image .


    RescaleIntensityImageFilter applies pixel-wise a linear transformation to the intensity values of
    input image pixels. The linear transformation is defined by the user
    in terms of the minimum and maximum values that the output image
    should have.

    The following equation gives the mapping of the intensity values


    \\[ outputPixel = ( inputPixel - inputMin) \\cdot
    \\frac{(outputMax - outputMin )}{(inputMax - inputMin)} + outputMin
    \\]
     All computations are performed in the precison of the input pixel's
    RealType. Before assigning the computed value to the output pixel.

    NOTE: In this filter the minimum and maximum values of the input image
    are computed internally using the MinimumMaximumImageCalculator . Users are not supposed to set those values in this filter. If you
    need a filter where you can set the minimum and maximum values of the
    input, please use the IntensityWindowingImageFilter . If you want a filter that can use a user-defined linear
    transformation for the intensity, then please use the ShiftScaleImageFilter .


    See:
     IntensityWindowingImageFilter
    Wiki Examples:

    All Examples

    Rescale the intensity values of an image to a specified range
    See:
     itk::simple::RescaleIntensity for the procedural interface

     itk::RescaleIntensityImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkRescaleIntensityImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RescaleIntensityImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RescaleIntensityImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RescaleIntensityImageFilter self) -> RescaleIntensityImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RescaleIntensityImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RescaleIntensityImageFilter
    __del__ = lambda self: None

    def SetOutputMinimum(self, OutputMinimum):
        """
        SetOutputMinimum(RescaleIntensityImageFilter self, double OutputMinimum)



        """
        return _SimpleITK.RescaleIntensityImageFilter_SetOutputMinimum(self, OutputMinimum)


    def GetOutputMinimum(self):
        """
        GetOutputMinimum(RescaleIntensityImageFilter self) -> double



        """
        return _SimpleITK.RescaleIntensityImageFilter_GetOutputMinimum(self)


    def SetOutputMaximum(self, OutputMaximum):
        """
        SetOutputMaximum(RescaleIntensityImageFilter self, double OutputMaximum)



        """
        return _SimpleITK.RescaleIntensityImageFilter_SetOutputMaximum(self, OutputMaximum)


    def GetOutputMaximum(self):
        """
        GetOutputMaximum(RescaleIntensityImageFilter self) -> double



        """
        return _SimpleITK.RescaleIntensityImageFilter_GetOutputMaximum(self)


    def GetName(self):
        """
        GetName(RescaleIntensityImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RescaleIntensityImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RescaleIntensityImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RescaleIntensityImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RescaleIntensityImageFilter self, Image image1) -> Image
        Execute(RescaleIntensityImageFilter self, Image image1, double outputMinimum, double outputMaximum) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.RescaleIntensityImageFilter_Execute(self, *args)

RescaleIntensityImageFilter_swigregister = _SimpleITK.RescaleIntensityImageFilter_swigregister
RescaleIntensityImageFilter_swigregister(RescaleIntensityImageFilter)


def RescaleIntensity(image1, outputMinimum=0, outputMaximum=255):
    """
    RescaleIntensity(Image image1, double outputMinimum=0, double outputMaximum=255) -> Image



    Applies a linear transformation to the intensity levels of the input Image .


    This function directly calls the execute method of RescaleIntensityImageFilter in order to support a procedural API


    See:
     itk::simple::RescaleIntensityImageFilter for the object oriented interface



    """
    return _SimpleITK.RescaleIntensity(image1, outputMinimum, outputMaximum)
class RichardsonLucyDeconvolutionImageFilter(ImageFilter_2):
    """


    Deconvolve an image using the Richardson-Lucy deconvolution algorithm.


    This filter implements the Richardson-Lucy deconvolution algorithm as
    defined in Bertero M and Boccacci P, "Introduction to Inverse
    Problems in Imaging", 1998. The algorithm assumes that the input
    image has been formed by a linear shift-invariant system with a known
    kernel.

    The Richardson-Lucy algorithm assumes that noise in the image follows
    a Poisson distribution and that the distribution for each pixel is
    independent of the other pixels.

    This code was adapted from the Insight Journal contribution:

    "Deconvolution: infrastructure and reference algorithms" by Gaetan
    Lehmann https://hdl.handle.net/10380/3207


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France
     Cory Quammen, The University of North Carolina at Chapel Hill


    See:
     IterativeDeconvolutionImageFilter

     LandweberDeconvolutionImageFilter

     ProjectedLandweberDeconvolutionImageFilter

     itk::simple::RichardsonLucyDeconvolution for the procedural interface

     itk::RichardsonLucyDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkRichardsonLucyDeconvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RichardsonLucyDeconvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RichardsonLucyDeconvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::RichardsonLucyDeconvolutionImageFilter self) -> RichardsonLucyDeconvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_RichardsonLucyDeconvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_RichardsonLucyDeconvolutionImageFilter
    __del__ = lambda self: None

    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(RichardsonLucyDeconvolutionImageFilter self, int NumberOfIterations)



        Set the number of iterations.


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(RichardsonLucyDeconvolutionImageFilter self) -> int



        Get the number of iterations.


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetNumberOfIterations(self)


    def SetNormalize(self, Normalize):
        """
        SetNormalize(RichardsonLucyDeconvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(RichardsonLucyDeconvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(RichardsonLucyDeconvolutionImageFilter self)



        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(RichardsonLucyDeconvolutionImageFilter self) -> bool



        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(RichardsonLucyDeconvolutionImageFilter self, itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(RichardsonLucyDeconvolutionImageFilter self) -> itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SAME
    VALID = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(RichardsonLucyDeconvolutionImageFilter self, itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(RichardsonLucyDeconvolutionImageFilter self) -> itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(RichardsonLucyDeconvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(RichardsonLucyDeconvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(RichardsonLucyDeconvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(RichardsonLucyDeconvolutionImageFilter self, Image image1, Image image2, int numberOfIterations, bool normalize, itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.RichardsonLucyDeconvolutionImageFilter_Execute(self, *args)

RichardsonLucyDeconvolutionImageFilter_swigregister = _SimpleITK.RichardsonLucyDeconvolutionImageFilter_swigregister
RichardsonLucyDeconvolutionImageFilter_swigregister(RichardsonLucyDeconvolutionImageFilter)


def RichardsonLucyDeconvolution(*args, **kwargs):
    """
    RichardsonLucyDeconvolution(Image image1, Image image2, int numberOfIterations=1, bool normalize=False, itk::simple::RichardsonLucyDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::RichardsonLucyDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    Deconvolve an image using the Richardson-Lucy deconvolution algorithm.


    This function directly calls the execute method of RichardsonLucyDeconvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::RichardsonLucyDeconvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.RichardsonLucyDeconvolution(*args, **kwargs)
class STAPLEImageFilter(ImageFilter_3):
    """


    The STAPLE filter implements the Simultaneous Truth and Performance
    Level Estimation algorithm for generating ground truth volumes from a
    set of binary expert segmentations.


    The STAPLE algorithm treats segmentation as a pixelwise
    classification, which leads to an averaging scheme that accounts for
    systematic biases in the behavior of experts in order to generate a
    fuzzy ground truth volume and simultaneous accuracy assessment of each
    expert. The ground truth volumes produced by this filter are floating
    point volumes of values between zero and one that indicate probability
    of each pixel being in the object targeted by the segmentation.

    The STAPLE algorithm is described in

    S. Warfield, K. Zou, W. Wells, "Validation of image segmentation and
    expert quality with an expectation-maximization algorithm" in MICCAI
    2002: Fifth International Conference on Medical Image Computing and Computer-Assisted Intervention, Springer-Verlag,
    Heidelberg, Germany, 2002, pp. 298-306

    INPUTS
    Input volumes to the STAPLE filter must be binary segmentations of an
    image, that is, there must be a single foreground value that
    represents positively classified pixels (pixels that are considered to
    belong inside the segmentation). Any number of background pixel values
    may be present in the input images. You can, for example, input
    volumes with many different labels as long as the structure you are
    interested in creating ground truth for is consistently labeled among
    all input volumes. Pixel type of the input volumes does not matter.
    Specify the label value for positively classified pixels using
    SetForegroundValue. All other labels will be considered to be
    negatively classified pixels (background).
     Input volumes must all contain the same size RequestedRegions.

    OUTPUTS
    The STAPLE filter produces a single output volume with a range of
    floating point values from zero to one. IT IS VERY IMPORTANT TO
    INSTANTIATE THIS FILTER WITH A FLOATING POINT OUTPUT TYPE (floats or
    doubles). You may threshold the output above some probability
    threshold if you wish to produce a binary ground truth.
    PARAMETERS
    The STAPLE algorithm requires a number of inputs. You may specify any
    number of input volumes using the SetInput(i, p_i) method, where i
    ranges from zero to N-1, N is the total number of input segmentations,
    and p_i is the SmartPointer to the i-th segmentation.
     The SetConfidenceWeight parameter is a modifier for the prior
    probability that any pixel would be classified as inside the target
    object. This implementation of the STAPLE algorithm automatically
    calculates prior positive classification probability as the average
    fraction of the image volume filled by the target object in each input
    segmentation. The ConfidenceWeight parameter allows for scaling the of
    this default prior probability: if g_t is the prior probability that a
    pixel would be classified inside the target object, then g_t is set to
    g_t * ConfidenceWeight before iterating on the solution. In general
    ConfidenceWeight should be left to the default of 1.0.

    You must provide a foreground value using SetForegroundValue that the
    STAPLE algorithm will use to identify positively classified pixels in
    the the input images. All other values in the image will be treated as
    background values. For example, if your input segmentations consist of
    1's everywhere inside the segmented region, then use
    SetForegroundValue(1).

    The STAPLE algorithm is an iterative E-M algorithm and will converge
    on a solution after some number of iterations that cannot be known a
    priori. After updating the filter, the total elapsed iterations taken
    to converge on the solution can be queried through GetElapsedIterations() . You may also specify a MaximumNumberOfIterations, after which the
    algorithm will stop iterating regardless of whether or not it has
    converged. This implementation of the STAPLE algorithm will find the
    solution to within seven digits of precision unless it is stopped
    early.

    Once updated, the Sensitivity (true positive fraction, q) and
    Specificity (true negative fraction, q) for each expert input volume
    can be queried using GetSensitivity(i) and GetSpecificity(i), where i
    is the i-th input volume.

    REQUIRED PARAMETERS
    The only required parameters for this filter are the ForegroundValue
    and the input volumes. All other parameters may be safely left to
    their default values. Please see the paper cited above for more
    information on the STAPLE algorithm and its parameters. A proper
    understanding of the algorithm is important for interpreting the
    results that it produces.
    EVENTS
    This filter invokes IterationEvent() at each iteration of the E-M
    algorithm. Setting the AbortGenerateData() flag will cause the
    algorithm to halt after the current iteration and produce results just
    as if it had converged. The algorithm makes no attempt to report its
    progress since the number of iterations needed cannot be known in
    advance.

    See:
     itk::simple::STAPLE for the procedural interface


    C++ includes: sitkSTAPLEImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STAPLEImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, STAPLEImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::STAPLEImageFilter self) -> STAPLEImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_STAPLEImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_STAPLEImageFilter
    __del__ = lambda self: None

    def SetConfidenceWeight(self, ConfidenceWeight):
        """
        SetConfidenceWeight(STAPLEImageFilter self, double ConfidenceWeight)



        Scales the estimated prior probability that a pixel will be inside the
        targeted object of segmentation. The default prior probability g_t is
        calculated automatically as the average fraction of positively
        classified pixels to the total size of the volume (across all input
        volumes). ConfidenceWeight will scale this default value as g_t = g_t
        * ConfidenceWeight. In general, ConfidenceWeight should be left to the
        default of 1.0.


        """
        return _SimpleITK.STAPLEImageFilter_SetConfidenceWeight(self, ConfidenceWeight)


    def GetConfidenceWeight(self):
        """
        GetConfidenceWeight(STAPLEImageFilter self) -> double



        Scales the estimated prior probability that a pixel will be inside the
        targeted object of segmentation. The default prior probability g_t is
        calculated automatically as the average fraction of positively
        classified pixels to the total size of the volume (across all input
        volumes). ConfidenceWeight will scale this default value as g_t = g_t
        * ConfidenceWeight. In general, ConfidenceWeight should be left to the
        default of 1.0.


        """
        return _SimpleITK.STAPLEImageFilter_GetConfidenceWeight(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(STAPLEImageFilter self, double ForegroundValue)



        Set get the binary ON value of the input image.


        """
        return _SimpleITK.STAPLEImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(STAPLEImageFilter self) -> double



        Set get the binary ON value of the input image.


        """
        return _SimpleITK.STAPLEImageFilter_GetForegroundValue(self)


    def SetMaximumIterations(self, MaximumIterations):
        """
        SetMaximumIterations(STAPLEImageFilter self, unsigned int MaximumIterations)



        Set/Get the maximum number of iterations after which the STAPLE
        algorithm will be considered to have converged. In general this SHOULD
        NOT be set and the algorithm should be allowed to converge on its own.


        """
        return _SimpleITK.STAPLEImageFilter_SetMaximumIterations(self, MaximumIterations)


    def GetMaximumIterations(self):
        """
        GetMaximumIterations(STAPLEImageFilter self) -> unsigned int



        Set/Get the maximum number of iterations after which the STAPLE
        algorithm will be considered to have converged. In general this SHOULD
        NOT be set and the algorithm should be allowed to converge on its own.


        """
        return _SimpleITK.STAPLEImageFilter_GetMaximumIterations(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(STAPLEImageFilter self) -> uint32_t



        Get the number of elapsed iterations of the iterative E-M algorithm.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.STAPLEImageFilter_GetElapsedIterations(self)


    def GetSensitivity(self):
        """
        GetSensitivity(STAPLEImageFilter self) -> VectorDouble



        After the filter is updated, this method returns a std::vector<double>
        of all Sensitivity (true positive fraction, p) values for the expert
        input volumes.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.STAPLEImageFilter_GetSensitivity(self)


    def GetSpecificity(self):
        """
        GetSpecificity(STAPLEImageFilter self) -> VectorDouble



        After the filter is updated, this method returns the Specificity (true
        negative fraction, q) value for the i-th expert input volume.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.STAPLEImageFilter_GetSpecificity(self)


    def GetName(self):
        """
        GetName(STAPLEImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.STAPLEImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(STAPLEImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.STAPLEImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(STAPLEImageFilter self, VectorOfImage images) -> Image
        Execute(STAPLEImageFilter self, Image image1) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
        Execute(STAPLEImageFilter self, VectorOfImage images, double confidenceWeight, double foregroundValue, unsigned int maximumIterations) -> Image
        Execute(STAPLEImageFilter self, Image image1, double confidenceWeight, double foregroundValue, unsigned int maximumIterations) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, double confidenceWeight, double foregroundValue, unsigned int maximumIterations) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, double confidenceWeight, double foregroundValue, unsigned int maximumIterations) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, double confidenceWeight, double foregroundValue, unsigned int maximumIterations) -> Image
        Execute(STAPLEImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5, double confidenceWeight, double foregroundValue, unsigned int maximumIterations) -> Image



        """
        return _SimpleITK.STAPLEImageFilter_Execute(self, *args)

STAPLEImageFilter_swigregister = _SimpleITK.STAPLEImageFilter_swigregister
STAPLEImageFilter_swigregister(STAPLEImageFilter)


def STAPLE(*args):
    """
    STAPLE(VectorOfImage images, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations) -> Image
    STAPLE(Image image1, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations) -> Image
    STAPLE(Image image1, Image image2, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations) -> Image
    STAPLE(Image image1, Image image2, Image image3, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations) -> Image
    STAPLE(Image image1, Image image2, Image image3, Image image4, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations) -> Image
    STAPLE(Image image1, Image image2, Image image3, Image image4, Image image5, double confidenceWeight=1.0, double foregroundValue=1.0, unsigned int maximumIterations) -> Image
    """
    return _SimpleITK.STAPLE(*args)
class SaltAndPepperNoiseImageFilter(ImageFilter_1):
    """


    Alter an image with fixed value impulse noise, often called salt and
    pepper noise.


    Pixel alteration occurs at a user defined probability. Salt and pepper
    pixel are equally distributed.


    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://hdl.handle.net/10380/3158
    See:
     itk::simple::SaltAndPepperNoise for the procedural interface

     itk::SaltAndPepperNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSaltAndPepperNoiseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SaltAndPepperNoiseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SaltAndPepperNoiseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SaltAndPepperNoiseImageFilter self) -> SaltAndPepperNoiseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SaltAndPepperNoiseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SaltAndPepperNoiseImageFilter
    __del__ = lambda self: None

    def SetProbability(self, Probability):
        """
        SetProbability(SaltAndPepperNoiseImageFilter self, double Probability)



        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_SetProbability(self, Probability)


    def GetProbability(self):
        """
        GetProbability(SaltAndPepperNoiseImageFilter self) -> double



        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_GetProbability(self)


    def SetSeed(self, Seed):
        """
        SetSeed(SaltAndPepperNoiseImageFilter self, uint32_t Seed)



        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_SetSeed(self, Seed)


    def GetSeed(self):
        """
        GetSeed(SaltAndPepperNoiseImageFilter self) -> uint32_t



        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_GetSeed(self)


    def GetName(self):
        """
        GetName(SaltAndPepperNoiseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SaltAndPepperNoiseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SaltAndPepperNoiseImageFilter self, Image image1) -> Image
        Execute(SaltAndPepperNoiseImageFilter self, Image image1, double probability, uint32_t seed) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SaltAndPepperNoiseImageFilter_Execute(self, *args)

SaltAndPepperNoiseImageFilter_swigregister = _SimpleITK.SaltAndPepperNoiseImageFilter_swigregister
SaltAndPepperNoiseImageFilter_swigregister(SaltAndPepperNoiseImageFilter)


def SaltAndPepperNoise(*args, **kwargs):
    """
    SaltAndPepperNoise(Image image1, double probability=0.01, uint32_t seed) -> Image



    Alter an image with fixed value impulse noise, often called salt and
    pepper noise.


    This function directly calls the execute method of SaltAndPepperNoiseImageFilter in order to support a procedural API


    See:
     itk::simple::SaltAndPepperNoiseImageFilter for the object oriented interface



    """
    return _SimpleITK.SaltAndPepperNoise(*args, **kwargs)
class ScalarChanAndVeseDenseLevelSetImageFilter(ImageFilter_2):
    """


    Dense implementation of the Chan and Vese multiphase level set image
    filter.


    This code was adapted from the paper: "An active contour model
    without edges" T. Chan and L. Vese. In Scale-Space Theories in
    Computer Vision, pages 141-151, 1999.


    Mosaliganti K., Smith B., Gelas A., Gouaillard A., Megason S.
     This code was taken from the Insight Journal paper: "Cell Tracking
    using Coupled Active Surfaces for Nuclei and Membranes" http://www.insight-journal.org/browse/publication/642 https://hdl.handle.net/10380/3055

    That is based on the papers: "Level Set Segmentation: Active Contours
    without edge" http://www.insight-journal.org/browse/publication/322 https://hdl.handle.net/1926/1532

    and

    "Level set segmentation using coupled active surfaces" http://www.insight-journal.org/browse/publication/323 https://hdl.handle.net/1926/1533

    Wiki Examples:

    All Examples

    Single-phase Chan And Vese Dense Field Level Set Segmentation
    See:
     itk::simple::ScalarChanAndVeseDenseLevelSet for the procedural interface

     itk::ScalarChanAndVeseDenseLevelSetImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkScalarChanAndVeseDenseLevelSetImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarChanAndVeseDenseLevelSetImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarChanAndVeseDenseLevelSetImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter self) -> ScalarChanAndVeseDenseLevelSetImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ScalarChanAndVeseDenseLevelSetImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ScalarChanAndVeseDenseLevelSetImageFilter
    __del__ = lambda self: None

    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(ScalarChanAndVeseDenseLevelSetImageFilter self, double MaximumRMSError)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetMaximumRMSError(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(ScalarChanAndVeseDenseLevelSetImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(ScalarChanAndVeseDenseLevelSetImageFilter self) -> uint32_t



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetNumberOfIterations(self)


    def SetLambda1(self, Lambda1):
        """
        SetLambda1(ScalarChanAndVeseDenseLevelSetImageFilter self, double Lambda1)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetLambda1(self, Lambda1)


    def GetLambda1(self):
        """
        GetLambda1(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetLambda1(self)


    def SetLambda2(self, Lambda2):
        """
        SetLambda2(ScalarChanAndVeseDenseLevelSetImageFilter self, double Lambda2)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetLambda2(self, Lambda2)


    def GetLambda2(self):
        """
        GetLambda2(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetLambda2(self)


    def SetEpsilon(self, Epsilon):
        """
        SetEpsilon(ScalarChanAndVeseDenseLevelSetImageFilter self, double Epsilon)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetEpsilon(self, Epsilon)


    def GetEpsilon(self):
        """
        GetEpsilon(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetEpsilon(self)


    def SetCurvatureWeight(self, CurvatureWeight):
        """
        SetCurvatureWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double CurvatureWeight)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetCurvatureWeight(self, CurvatureWeight)


    def GetCurvatureWeight(self):
        """
        GetCurvatureWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetCurvatureWeight(self)


    def SetAreaWeight(self, AreaWeight):
        """
        SetAreaWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double AreaWeight)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetAreaWeight(self, AreaWeight)


    def GetAreaWeight(self):
        """
        GetAreaWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetAreaWeight(self)


    def SetReinitializationSmoothingWeight(self, ReinitializationSmoothingWeight):
        """
        SetReinitializationSmoothingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double ReinitializationSmoothingWeight)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetReinitializationSmoothingWeight(self, ReinitializationSmoothingWeight)


    def GetReinitializationSmoothingWeight(self):
        """
        GetReinitializationSmoothingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetReinitializationSmoothingWeight(self)


    def SetVolume(self, Volume):
        """
        SetVolume(ScalarChanAndVeseDenseLevelSetImageFilter self, double Volume)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetVolume(self, Volume)


    def GetVolume(self):
        """
        GetVolume(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetVolume(self)


    def SetVolumeMatchingWeight(self, VolumeMatchingWeight):
        """
        SetVolumeMatchingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self, double VolumeMatchingWeight)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetVolumeMatchingWeight(self, VolumeMatchingWeight)


    def GetVolumeMatchingWeight(self):
        """
        GetVolumeMatchingWeight(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetVolumeMatchingWeight(self)

    AtanRegularizedHeaviside = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_AtanRegularizedHeaviside
    SinRegularizedHeaviside = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SinRegularizedHeaviside
    Heaviside = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_Heaviside

    def SetHeavisideStepFunction(self, HeavisideStepFunction):
        """
        SetHeavisideStepFunction(ScalarChanAndVeseDenseLevelSetImageFilter self, itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType HeavisideStepFunction)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetHeavisideStepFunction(self, HeavisideStepFunction)


    def GetHeavisideStepFunction(self):
        """
        GetHeavisideStepFunction(ScalarChanAndVeseDenseLevelSetImageFilter self) -> itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetHeavisideStepFunction(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(ScalarChanAndVeseDenseLevelSetImageFilter self, bool UseImageSpacing)



        Use the image spacing information in calculations. Use this option if
        you want derivatives in physical space. Default is UseImageSpacingOn.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(ScalarChanAndVeseDenseLevelSetImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(ScalarChanAndVeseDenseLevelSetImageFilter self)



        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(ScalarChanAndVeseDenseLevelSetImageFilter self) -> bool



        Use the image spacing information in calculations. Use this option if
        you want derivatives in physical space. Default is UseImageSpacingOn.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetUseImageSpacing(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(ScalarChanAndVeseDenseLevelSetImageFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(ScalarChanAndVeseDenseLevelSetImageFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetRMSChange(self)


    def GetName(self):
        """
        GetName(ScalarChanAndVeseDenseLevelSetImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ScalarChanAndVeseDenseLevelSetImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ScalarChanAndVeseDenseLevelSetImageFilter self, Image image1, Image image2) -> Image
        Execute(ScalarChanAndVeseDenseLevelSetImageFilter self, Image image1, Image image2, double maximumRMSError, uint32_t numberOfIterations, double lambda1, double lambda2, double epsilon, double curvatureWeight, double areaWeight, double reinitializationSmoothingWeight, double volume, double volumeMatchingWeight, itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType heavisideStepFunction, bool useImageSpacing) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_Execute(self, *args)

ScalarChanAndVeseDenseLevelSetImageFilter_swigregister = _SimpleITK.ScalarChanAndVeseDenseLevelSetImageFilter_swigregister
ScalarChanAndVeseDenseLevelSetImageFilter_swigregister(ScalarChanAndVeseDenseLevelSetImageFilter)


def ScalarChanAndVeseDenseLevelSet(*args, **kwargs):
    """
    ScalarChanAndVeseDenseLevelSet(Image image1, Image image2, double maximumRMSError=0.02, uint32_t numberOfIterations=1000, double lambda1=1.0, double lambda2=1.0, double epsilon=1.0, double curvatureWeight=1.0, double areaWeight=0.0, double reinitializationSmoothingWeight=0.0, double volume=0.0, double volumeMatchingWeight=0.0, itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter::HeavisideStepFunctionType heavisideStepFunction, bool useImageSpacing=True) -> Image



    Dense implementation of the Chan and Vese multiphase level set image
    filter.


    This function directly calls the execute method of ScalarChanAndVeseDenseLevelSetImageFilter in order to support a procedural API


    See:
     itk::simple::ScalarChanAndVeseDenseLevelSetImageFilter for the object oriented interface



    """
    return _SimpleITK.ScalarChanAndVeseDenseLevelSet(*args, **kwargs)
class ScalarConnectedComponentImageFilter(ImageFilter_1):
    """


    A connected components filter that labels the objects in an arbitrary
    image. Two pixels are similar if they are within threshold of each
    other. Uses ConnectedComponentFunctorImageFilter .


    Wiki Examples:

    All Examples

    Label connected components in a grayscale image
    See:
     itk::simple::ScalarConnectedComponent for the procedural interface

     itk::ScalarConnectedComponentImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkScalarConnectedComponentImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarConnectedComponentImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarConnectedComponentImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ScalarConnectedComponentImageFilter self) -> ScalarConnectedComponentImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ScalarConnectedComponentImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ScalarConnectedComponentImageFilter
    __del__ = lambda self: None

    def SetDistanceThreshold(self, DistanceThreshold):
        """
        SetDistanceThreshold(ScalarConnectedComponentImageFilter self, double DistanceThreshold)



        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_SetDistanceThreshold(self, DistanceThreshold)


    def GetDistanceThreshold(self):
        """
        GetDistanceThreshold(ScalarConnectedComponentImageFilter self) -> double



        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_GetDistanceThreshold(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ScalarConnectedComponentImageFilter self, bool FullyConnected)



        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ScalarConnectedComponentImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ScalarConnectedComponentImageFilter self)



        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ScalarConnectedComponentImageFilter self) -> bool



        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(ScalarConnectedComponentImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ScalarConnectedComponentImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ScalarConnectedComponentImageFilter self, Image image1) -> Image
        Execute(ScalarConnectedComponentImageFilter self, Image image1, double distanceThreshold, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ScalarConnectedComponentImageFilter_Execute(self, *args)

ScalarConnectedComponentImageFilter_swigregister = _SimpleITK.ScalarConnectedComponentImageFilter_swigregister
ScalarConnectedComponentImageFilter_swigregister(ScalarConnectedComponentImageFilter)


def ScalarConnectedComponent(image1, distanceThreshold=0.0, fullyConnected=False):
    """
    ScalarConnectedComponent(Image image1, double distanceThreshold=0.0, bool fullyConnected=False) -> Image



    A connected components filter that labels the objects in an arbitrary
    image. Two pixels are similar if they are within threshold of each
    other. Uses ConnectedComponentFunctorImageFilter .


    This function directly calls the execute method of ScalarConnectedComponentImageFilter in order to support a procedural API


    See:
     itk::simple::ScalarConnectedComponentImageFilter for the object oriented interface



    """
    return _SimpleITK.ScalarConnectedComponent(image1, distanceThreshold, fullyConnected)
class ScalarImageKmeansImageFilter(ImageFilter_1):
    """


    Classifies the intensity values of a scalar image using the K-Means
    algorithm.


    Given an input image with scalar values, it uses the K-Means
    statistical classifier in order to define labels for every pixel in
    the image. The filter is templated over the type of the input image.
    The output image is predefined as having the same dimension of the
    input image and pixel type unsigned char, under the assumption that
    the classifier will generate less than 256 classes.

    You may want to look also at the RelabelImageFilter that may be used
    as a postprocessing stage, in particular if you are interested in
    ordering the labels by their relative size in number of pixels.


    See:
     Image

     ImageKmeansModelEstimator

     KdTreeBasedKmeansEstimator, WeightedCentroidKdTreeGenerator, KdTree

     RelabelImageFilter
    Wiki Examples:

    All Examples

    Cluster the pixels in a greyscale image
    See:
     itk::simple::ScalarImageKmeans for the procedural interface

     itk::ScalarImageKmeansImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkScalarImageKmeansImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarImageKmeansImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarImageKmeansImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ScalarImageKmeansImageFilter self) -> ScalarImageKmeansImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ScalarImageKmeansImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ScalarImageKmeansImageFilter
    __del__ = lambda self: None

    def SetClassWithInitialMean(self, ClassWithInitialMean):
        """
        SetClassWithInitialMean(ScalarImageKmeansImageFilter self, VectorDouble ClassWithInitialMean)



        """
        return _SimpleITK.ScalarImageKmeansImageFilter_SetClassWithInitialMean(self, ClassWithInitialMean)


    def GetClassWithInitialMean(self):
        """
        GetClassWithInitialMean(ScalarImageKmeansImageFilter self) -> VectorDouble



        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetClassWithInitialMean(self)


    def SetUseNonContiguousLabels(self, UseNonContiguousLabels):
        """
        SetUseNonContiguousLabels(ScalarImageKmeansImageFilter self, bool UseNonContiguousLabels)



        Set/Get the UseNonContiguousLabels flag. When this is set to false the
        labels are numbered contiguously, like in {0,1,3..N}. When the flag is
        set to true, the labels are selected in order to span the dynamic
        range of the output image. This last option is useful when the output
        image is intended only for display. The default value is false.


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_SetUseNonContiguousLabels(self, UseNonContiguousLabels)


    def UseNonContiguousLabelsOn(self):
        """
        UseNonContiguousLabelsOn(ScalarImageKmeansImageFilter self)



        Set the value of UseNonContiguousLabels to true or false respectfully.


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_UseNonContiguousLabelsOn(self)


    def UseNonContiguousLabelsOff(self):
        """
        UseNonContiguousLabelsOff(ScalarImageKmeansImageFilter self)



        """
        return _SimpleITK.ScalarImageKmeansImageFilter_UseNonContiguousLabelsOff(self)


    def GetUseNonContiguousLabels(self):
        """
        GetUseNonContiguousLabels(ScalarImageKmeansImageFilter self) -> bool



        Set/Get the UseNonContiguousLabels flag. When this is set to false the
        labels are numbered contiguously, like in {0,1,3..N}. When the flag is
        set to true, the labels are selected in order to span the dynamic
        range of the output image. This last option is useful when the output
        image is intended only for display. The default value is false.


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetUseNonContiguousLabels(self)


    def GetFinalMeans(self):
        """
        GetFinalMeans(ScalarImageKmeansImageFilter self) -> VectorDouble



        Return the array of Means found after the classification.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetFinalMeans(self)


    def GetName(self):
        """
        GetName(ScalarImageKmeansImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ScalarImageKmeansImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ScalarImageKmeansImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ScalarImageKmeansImageFilter self, Image image1) -> Image
        Execute(ScalarImageKmeansImageFilter self, Image image1, VectorDouble classWithInitialMean, bool useNonContiguousLabels) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ScalarImageKmeansImageFilter_Execute(self, *args)

ScalarImageKmeansImageFilter_swigregister = _SimpleITK.ScalarImageKmeansImageFilter_swigregister
ScalarImageKmeansImageFilter_swigregister(ScalarImageKmeansImageFilter)


def ScalarImageKmeans(*args, **kwargs):
    """
    ScalarImageKmeans(Image image1, VectorDouble classWithInitialMean, bool useNonContiguousLabels=False) -> Image



    Classifies the intensity values of a scalar image using the K-Means
    algorithm.


    This function directly calls the execute method of ScalarImageKmeansImageFilter in order to support a procedural API


    See:
     itk::simple::ScalarImageKmeansImageFilter for the object oriented interface



    """
    return _SimpleITK.ScalarImageKmeans(*args, **kwargs)
class ScalarToRGBColormapImageFilter(ImageFilter_1):
    """


    Implements pixel-wise intensity->rgb mapping operation on one image.


    This class is parameterized over the type of the input image and the
    type of the output image.

    The input image's scalar pixel values are mapped into a color map. The
    color map is specified by passing the SetColormap function one of the
    predefined maps. The following selects the "Hot" colormap:

    You can also specify a custom color map. This is done by creating a
    CustomColormapFunction, and then creating lists of values for the red,
    green, and blue channel. An example of setting the red channel of a
    colormap with only 2 colors is given below. The blue and green
    channels should be specified in the same manner.


    The range of values present in the input image is the range that is
    mapped to the entire range of colors.

    This code was contributed in the Insight Journal paper: "Meeting Andy
    Warhol Somewhere Over the Rainbow: RGB Colormapping and ITK" by
    Tustison N., Zhang H., Lehmann G., Yushkevich P., Gee J. https://hdl.handle.net/1926/1452 http://www.insight-journal.org/browse/publication/285


    See:
     BinaryFunctionImageFilter TernaryFunctionImageFilter
    Wiki Examples:

    All Examples

    Apply a color map to an image
    See:
     itk::simple::ScalarToRGBColormap for the procedural interface

     itk::ScalarToRGBColormapImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkScalarToRGBColormapImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScalarToRGBColormapImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScalarToRGBColormapImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ScalarToRGBColormapImageFilter self) -> ScalarToRGBColormapImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ScalarToRGBColormapImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ScalarToRGBColormapImageFilter
    __del__ = lambda self: None
    Red = _SimpleITK.ScalarToRGBColormapImageFilter_Red
    Green = _SimpleITK.ScalarToRGBColormapImageFilter_Green
    Blue = _SimpleITK.ScalarToRGBColormapImageFilter_Blue
    Grey = _SimpleITK.ScalarToRGBColormapImageFilter_Grey
    Hot = _SimpleITK.ScalarToRGBColormapImageFilter_Hot
    Cool = _SimpleITK.ScalarToRGBColormapImageFilter_Cool
    Spring = _SimpleITK.ScalarToRGBColormapImageFilter_Spring
    Summer = _SimpleITK.ScalarToRGBColormapImageFilter_Summer
    Autumn = _SimpleITK.ScalarToRGBColormapImageFilter_Autumn
    Winter = _SimpleITK.ScalarToRGBColormapImageFilter_Winter
    Copper = _SimpleITK.ScalarToRGBColormapImageFilter_Copper
    Jet = _SimpleITK.ScalarToRGBColormapImageFilter_Jet
    HSV = _SimpleITK.ScalarToRGBColormapImageFilter_HSV
    OverUnder = _SimpleITK.ScalarToRGBColormapImageFilter_OverUnder

    def SetColormap(self, Colormap):
        """
        SetColormap(ScalarToRGBColormapImageFilter self, itk::simple::ScalarToRGBColormapImageFilter::ColormapType Colormap)



        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_SetColormap(self, Colormap)


    def GetColormap(self):
        """
        GetColormap(ScalarToRGBColormapImageFilter self) -> itk::simple::ScalarToRGBColormapImageFilter::ColormapType



        Set/Get the colormap object.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_GetColormap(self)


    def SetUseInputImageExtremaForScaling(self, UseInputImageExtremaForScaling):
        """
        SetUseInputImageExtremaForScaling(ScalarToRGBColormapImageFilter self, bool UseInputImageExtremaForScaling)



        Set/Get UseInputImageExtremaForScaling. If true, the colormap uses the
        min and max values from the image to scale appropriately. Otherwise,
        these values can be set in the colormap manually.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_SetUseInputImageExtremaForScaling(self, UseInputImageExtremaForScaling)


    def UseInputImageExtremaForScalingOn(self):
        """
        UseInputImageExtremaForScalingOn(ScalarToRGBColormapImageFilter self)



        Set the value of UseInputImageExtremaForScaling to true or false
        respectfully.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_UseInputImageExtremaForScalingOn(self)


    def UseInputImageExtremaForScalingOff(self):
        """
        UseInputImageExtremaForScalingOff(ScalarToRGBColormapImageFilter self)



        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_UseInputImageExtremaForScalingOff(self)


    def GetUseInputImageExtremaForScaling(self):
        """
        GetUseInputImageExtremaForScaling(ScalarToRGBColormapImageFilter self) -> bool



        Set/Get UseInputImageExtremaForScaling. If true, the colormap uses the
        min and max values from the image to scale appropriately. Otherwise,
        these values can be set in the colormap manually.


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_GetUseInputImageExtremaForScaling(self)


    def GetName(self):
        """
        GetName(ScalarToRGBColormapImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ScalarToRGBColormapImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ScalarToRGBColormapImageFilter self, Image image1) -> Image
        Execute(ScalarToRGBColormapImageFilter self, Image image1, itk::simple::ScalarToRGBColormapImageFilter::ColormapType colormap, bool useInputImageExtremaForScaling) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ScalarToRGBColormapImageFilter_Execute(self, *args)

ScalarToRGBColormapImageFilter_swigregister = _SimpleITK.ScalarToRGBColormapImageFilter_swigregister
ScalarToRGBColormapImageFilter_swigregister(ScalarToRGBColormapImageFilter)


def ScalarToRGBColormap(*args, **kwargs):
    """
    ScalarToRGBColormap(Image image1, itk::simple::ScalarToRGBColormapImageFilter::ColormapType colormap, bool useInputImageExtremaForScaling=True) -> Image



    Implements pixel-wise intensity->rgb mapping operation on one image.


    This function directly calls the execute method of ScalarToRGBColormapImageFilter in order to support a procedural API


    See:
     itk::simple::ScalarToRGBColormapImageFilter for the object oriented interface



    """
    return _SimpleITK.ScalarToRGBColormap(*args, **kwargs)
class ShanbhagThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Shanbhag Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the ShanbhagThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::ShanbhagThreshold for the procedural interface

     itk::ShanbhagThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShanbhagThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShanbhagThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShanbhagThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ShanbhagThresholdImageFilter self) -> ShanbhagThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ShanbhagThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ShanbhagThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(ShanbhagThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(ShanbhagThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(ShanbhagThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(ShanbhagThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(ShanbhagThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(ShanbhagThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(ShanbhagThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(ShanbhagThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(ShanbhagThresholdImageFilter self)



        """
        return _SimpleITK.ShanbhagThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(ShanbhagThresholdImageFilter self) -> bool



        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(ShanbhagThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(ShanbhagThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(ShanbhagThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(ShanbhagThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ShanbhagThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ShanbhagThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ShanbhagThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ShanbhagThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(ShanbhagThresholdImageFilter self, Image image) -> Image
        Execute(ShanbhagThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(ShanbhagThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.ShanbhagThresholdImageFilter_Execute(self, *args)

ShanbhagThresholdImageFilter_swigregister = _SimpleITK.ShanbhagThresholdImageFilter_swigregister
ShanbhagThresholdImageFilter_swigregister(ShanbhagThresholdImageFilter)


def ShanbhagThreshold(*args):
    """
    ShanbhagThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    ShanbhagThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.ShanbhagThreshold(*args)
class ShapeDetectionLevelSetImageFilter(ImageFilter_2):
    """


    Segments structures in images based on a user supplied edge potential
    map.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the ShapeDetectionLevelSetFunction class contain additional information necessary to gain full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. An initial
    contour is propagated outwards (or inwards) until it ''sticks'' to the
    shape boundaries. This is done by using a level set speed function
    based on a user supplied edge potential map. This approach for
    segmentation follows that of Malladi et al (1995).
    INPUTS
    This filter requires two inputs. The first input is a initial level
    set. The initial level set is a real image which contains the initial
    contour/surface as the zero level set. For example, a signed distance
    function from the initial contour/surface is typically used. Note that
    for this algorithm the initial contour has to be wholly within (or
    wholly outside) the structure to be segmented.

    The second input is the feature image. For this filter, this is the
    edge potential map. General characteristics of an edge potential map
    is that it has values close to zero in regions near the edges and
    values close to one inside the shape itself. Typically, the edge
    potential map is compute from the image gradient, for example:
    \\[ g(I) = 1 / ( 1 + | (\\nabla * G)(I)| ) \\] \\[ g(I) = \\exp^{-|(\\nabla * G)(I)|} \\]

    where $ I $ is image intensity and $ (\\nabla * G) $ is the derivative of Gaussian operator.


    See SegmentationLevelSetImageFilter and SparseFieldLevelSetImageFilter for more information on Inputs.
    PARAMETERS
    The PropagationScaling parameter can be used to switch from
    propagation outwards (POSITIVE scaling parameter) versus propagating
    inwards (NEGATIVE scaling parameter).
     The smoothness of the resulting contour/surface can be adjusted using
    a combination of PropagationScaling and CurvatureScaling parameters.
    The larger the CurvatureScaling parameter, the smoother the resulting
    contour. The CurvatureScaling parameter should be non-negative for
    proper operation of this algorithm. To follow the implementation in
    Malladi et al paper, set the PropagtionScaling to $\\pm 1.0$ and CurvatureScaling to $ \\epsilon $ .

    Note that there is no advection term for this filter. Setting the
    advection scaling will have no effect.

    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Negative
    values in the output image represent the inside of the segmentated
    region and positive values in the image represent the outside of the
    segmented region. The zero crossings of the image correspond to the
    position of the propagating front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    REFERENCES

    "Shape Modeling with Front Propagation: A Level Set Approach", R.
    Malladi, J. A. Sethian and B. C. Vermuri. IEEE Trans. on Pattern
    Analysis and Machine Intelligence, Vol 17, No. 2, pp 158-174, February
    1995

    See:
     SegmentationLevelSetImageFilter

     ShapeDetectionLevelSetFunction

     SparseFieldLevelSetImageFilter

     itk::simple::ShapeDetectionLevelSet for the procedural interface

     itk::ShapeDetectionLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShapeDetectionLevelSetImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShapeDetectionLevelSetImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShapeDetectionLevelSetImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ShapeDetectionLevelSetImageFilter self) -> ShapeDetectionLevelSetImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ShapeDetectionLevelSetImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ShapeDetectionLevelSetImageFilter
    __del__ = lambda self: None

    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(ShapeDetectionLevelSetImageFilter self, double MaximumRMSError)



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(ShapeDetectionLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetMaximumRMSError(self)


    def SetPropagationScaling(self, PropagationScaling):
        """
        SetPropagationScaling(ShapeDetectionLevelSetImageFilter self, double PropagationScaling)



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetPropagationScaling(self, PropagationScaling)


    def GetPropagationScaling(self):
        """
        GetPropagationScaling(ShapeDetectionLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetPropagationScaling(self)


    def SetCurvatureScaling(self, CurvatureScaling):
        """
        SetCurvatureScaling(ShapeDetectionLevelSetImageFilter self, double CurvatureScaling)



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetCurvatureScaling(self, CurvatureScaling)


    def GetCurvatureScaling(self):
        """
        GetCurvatureScaling(ShapeDetectionLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetCurvatureScaling(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(ShapeDetectionLevelSetImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(ShapeDetectionLevelSetImageFilter self) -> uint32_t



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetNumberOfIterations(self)


    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        """
        SetReverseExpansionDirection(ShapeDetectionLevelSetImageFilter self, bool ReverseExpansionDirection)



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_SetReverseExpansionDirection(self, ReverseExpansionDirection)


    def ReverseExpansionDirectionOn(self):
        """
        ReverseExpansionDirectionOn(ShapeDetectionLevelSetImageFilter self)



        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_ReverseExpansionDirectionOn(self)


    def ReverseExpansionDirectionOff(self):
        """
        ReverseExpansionDirectionOff(ShapeDetectionLevelSetImageFilter self)



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_ReverseExpansionDirectionOff(self)


    def GetReverseExpansionDirection(self):
        """
        GetReverseExpansionDirection(ShapeDetectionLevelSetImageFilter self) -> bool



        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetReverseExpansionDirection(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(ShapeDetectionLevelSetImageFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(ShapeDetectionLevelSetImageFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetRMSChange(self)


    def GetName(self):
        """
        GetName(ShapeDetectionLevelSetImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ShapeDetectionLevelSetImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ShapeDetectionLevelSetImageFilter self, Image image1, Image image2) -> Image
        Execute(ShapeDetectionLevelSetImageFilter self, Image image1, Image image2, double maximumRMSError, double propagationScaling, double curvatureScaling, uint32_t numberOfIterations, bool reverseExpansionDirection) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ShapeDetectionLevelSetImageFilter_Execute(self, *args)

ShapeDetectionLevelSetImageFilter_swigregister = _SimpleITK.ShapeDetectionLevelSetImageFilter_swigregister
ShapeDetectionLevelSetImageFilter_swigregister(ShapeDetectionLevelSetImageFilter)


def ShapeDetectionLevelSet(image1, image2, maximumRMSError=0.02, propagationScaling=1.0, curvatureScaling=1.0, numberOfIterations=1000, reverseExpansionDirection=False):
    """
    ShapeDetectionLevelSet(Image image1, Image image2, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image



    Segments structures in images based on a user supplied edge potential
    map.


    This function directly calls the execute method of ShapeDetectionLevelSetImageFilter in order to support a procedural API


    See:
     itk::simple::ShapeDetectionLevelSetImageFilter for the object oriented interface



    """
    return _SimpleITK.ShapeDetectionLevelSet(image1, image2, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations, reverseExpansionDirection)
class ShiftScaleImageFilter(ImageFilter_1):
    """


    Shift and scale the pixels in an image.


    ShiftScaleImageFilter shifts the input pixel by Shift (default 0.0) and then scales the
    pixel by Scale (default 1.0). All computattions are performed in the
    precison of the input pixel's RealType. Before assigning the computed
    value to the output pixel, the value is clamped at the NonpositiveMin
    and max of the pixel type.
    See:
     itk::simple::ShiftScale for the procedural interface

     itk::ShiftScaleImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShiftScaleImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShiftScaleImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShiftScaleImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ShiftScaleImageFilter self) -> ShiftScaleImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ShiftScaleImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ShiftScaleImageFilter
    __del__ = lambda self: None

    def SetShift(self, Shift):
        """
        SetShift(ShiftScaleImageFilter self, double Shift)



        Set/Get the amount to Shift each Pixel. The shift is followed by a
        Scale.


        """
        return _SimpleITK.ShiftScaleImageFilter_SetShift(self, Shift)


    def GetShift(self):
        """
        GetShift(ShiftScaleImageFilter self) -> double



        Set/Get the amount to Shift each Pixel. The shift is followed by a
        Scale.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetShift(self)


    def SetScale(self, Scale):
        """
        SetScale(ShiftScaleImageFilter self, double Scale)



        Set/Get the amount to Scale each Pixel. The Scale is applied after the
        Shift.


        """
        return _SimpleITK.ShiftScaleImageFilter_SetScale(self, Scale)


    def GetScale(self):
        """
        GetScale(ShiftScaleImageFilter self) -> double



        Set/Get the amount to Scale each Pixel. The Scale is applied after the
        Shift.


        """
        return _SimpleITK.ShiftScaleImageFilter_GetScale(self)


    def GetName(self):
        """
        GetName(ShiftScaleImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ShiftScaleImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ShiftScaleImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ShiftScaleImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ShiftScaleImageFilter self, Image image1) -> Image
        Execute(ShiftScaleImageFilter self, Image image1, double shift, double scale) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ShiftScaleImageFilter_Execute(self, *args)

ShiftScaleImageFilter_swigregister = _SimpleITK.ShiftScaleImageFilter_swigregister
ShiftScaleImageFilter_swigregister(ShiftScaleImageFilter)


def ShiftScale(image1, shift=0, scale=1.0):
    """
    ShiftScale(Image image1, double shift=0, double scale=1.0) -> Image



    Shift and scale the pixels in an image.


    This function directly calls the execute method of ShiftScaleImageFilter in order to support a procedural API


    See:
     itk::simple::ShiftScaleImageFilter for the object oriented interface



    """
    return _SimpleITK.ShiftScale(image1, shift, scale)
class ShotNoiseImageFilter(ImageFilter_1):
    """


    Alter an image with shot noise.


    The shot noise follows a Poisson distribution:


    $ I = N(I_0) $

    where $ N(I_0) $ is a Poisson-distributed random variable of mean $ I_0 $ . The noise is thus dependent on the pixel intensities in the image.
     The intensities in the image can be scaled by a user provided value
    to map pixel values to the actual number of particles. The scaling can
    be seen as the inverse of the gain used during the acquisition. The
    noisy signal is then scaled back to its input intensity range:


    $ I = \\frac{N(I_0 \\times s)}{s} $

    where $ s $ is the scale factor.
     The Poisson-distributed variable $ \\lambda $ is computed by using the algorithm:


    $ \\begin{array}{l} k \\leftarrow 0 \\\\ p \\leftarrow 1
    \\\\ \\textbf{repeat} \\\\ \\left\\{ \\begin{array}{l}
    k \\leftarrow k+1 \\\\ p \\leftarrow p \\ast U()
    \\end{array} \\right. \\\\ \\textbf{until } p >
    e^{\\lambda} \\\\ \\textbf{return} (k) \\end{array} $

    where $ U() $ provides a uniformly distributed random variable in the interval $ [0,1] $ .
     This algorithm is very inefficient for large values of $ \\lambda $ , though. Fortunately, the Poisson distribution can be accurately
    approximated by a Gaussian distribution of mean and variance $ \\lambda $ when $ \\lambda $ is large enough. In this implementation, this value is considered to
    be 50. This leads to the faster algorithm:


    $ \\lambda + \\sqrt{\\lambda} \\times N()$

    where $ N() $ is a normally distributed random variable of mean 0 and variance 1.

    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://hdl.handle.net/10380/3158
    See:
     itk::simple::ShotNoise for the procedural interface

     itk::ShotNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkShotNoiseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShotNoiseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShotNoiseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ShotNoiseImageFilter self) -> ShotNoiseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ShotNoiseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ShotNoiseImageFilter
    __del__ = lambda self: None

    def SetScale(self, Scale):
        """
        SetScale(ShotNoiseImageFilter self, double Scale)



        Set/Get the value to map the pixel value to the actual particle
        counting. The scaling can be seen as the inverse of the gain used
        during the acquisition. The noisy signal is then scaled back to its
        input intensity range. Defaults to 1.0.


        """
        return _SimpleITK.ShotNoiseImageFilter_SetScale(self, Scale)


    def GetScale(self):
        """
        GetScale(ShotNoiseImageFilter self) -> double



        Set/Get the value to map the pixel value to the actual particle
        counting. The scaling can be seen as the inverse of the gain used
        during the acquisition. The noisy signal is then scaled back to its
        input intensity range. Defaults to 1.0.


        """
        return _SimpleITK.ShotNoiseImageFilter_GetScale(self)


    def SetSeed(self, Seed):
        """
        SetSeed(ShotNoiseImageFilter self, uint32_t Seed)



        """
        return _SimpleITK.ShotNoiseImageFilter_SetSeed(self, Seed)


    def GetSeed(self):
        """
        GetSeed(ShotNoiseImageFilter self) -> uint32_t



        """
        return _SimpleITK.ShotNoiseImageFilter_GetSeed(self)


    def GetName(self):
        """
        GetName(ShotNoiseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ShotNoiseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ShotNoiseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ShotNoiseImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ShotNoiseImageFilter self, Image image1) -> Image
        Execute(ShotNoiseImageFilter self, Image image1, double scale, uint32_t seed) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ShotNoiseImageFilter_Execute(self, *args)

ShotNoiseImageFilter_swigregister = _SimpleITK.ShotNoiseImageFilter_swigregister
ShotNoiseImageFilter_swigregister(ShotNoiseImageFilter)


def ShotNoise(*args, **kwargs):
    """
    ShotNoise(Image image1, double scale=1.0, uint32_t seed) -> Image



    Alter an image with shot noise.


    This function directly calls the execute method of ShotNoiseImageFilter in order to support a procedural API


    See:
     itk::simple::ShotNoiseImageFilter for the object oriented interface



    """
    return _SimpleITK.ShotNoise(*args, **kwargs)
class ShrinkImageFilter(ImageFilter_1):
    """


    Reduce the size of an image by an integer factor in each dimension.


    ShrinkImageFilter reduces the size of an image by an integer factor in each dimension.
    The algorithm implemented is a simple subsample. The output image size
    in each dimension is given by:

    outputSize[j] = max( std::floor(inputSize[j]/shrinkFactor[j]), 1 );

    NOTE: The physical centers of the input and output will be the same.
    Because of this, the Origin of the output may not be the same as the
    Origin of the input. Since this filter produces an image which is a
    different resolution, origin and with different pixel spacing than its
    input image, it needs to override several of the methods defined in ProcessObject in order to properly manage the pipeline execution model. In
    particular, this filter overrides
    ProcessObject::GenerateInputRequestedRegion() and
    ProcessObject::GenerateOutputInformation() .

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.

    Wiki Examples:

    All Examples

    Shrink an image
    See:
     itk::simple::Shrink for the procedural interface

     itk::ShrinkImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkShrinkImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShrinkImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShrinkImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ShrinkImageFilter self) -> ShrinkImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ShrinkImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ShrinkImageFilter
    __del__ = lambda self: None

    def SetShrinkFactor(self, s):
        """
        SetShrinkFactor(ShrinkImageFilter self, unsigned int s) -> ShrinkImageFilter



        Custom public declarations


        """
        return _SimpleITK.ShrinkImageFilter_SetShrinkFactor(self, s)


    def SetShrinkFactors(self, ShrinkFactors):
        """
        SetShrinkFactors(ShrinkImageFilter self, VectorUInt32 ShrinkFactors)



        Set the shrink factors. Values are clamped to a minimum value of 1.
        Default is 1 for all dimensions.


        """
        return _SimpleITK.ShrinkImageFilter_SetShrinkFactors(self, ShrinkFactors)


    def GetShrinkFactors(self):
        """
        GetShrinkFactors(ShrinkImageFilter self) -> VectorUInt32



        Get the shrink factors.


        """
        return _SimpleITK.ShrinkImageFilter_GetShrinkFactors(self)


    def GetName(self):
        """
        GetName(ShrinkImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ShrinkImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ShrinkImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ShrinkImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ShrinkImageFilter self, Image image1) -> Image
        Execute(ShrinkImageFilter self, Image image1, VectorUInt32 shrinkFactors) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ShrinkImageFilter_Execute(self, *args)

ShrinkImageFilter_swigregister = _SimpleITK.ShrinkImageFilter_swigregister
ShrinkImageFilter_swigregister(ShrinkImageFilter)


def Shrink(*args, **kwargs):
    """
    Shrink(Image image1, VectorUInt32 shrinkFactors) -> Image



    Reduce the size of an image by an integer factor in each dimension.


    This function directly calls the execute method of ShrinkImageFilter in order to support a procedural API


    See:
     itk::simple::ShrinkImageFilter for the object oriented interface



    """
    return _SimpleITK.Shrink(*args, **kwargs)
class SigmoidImageFilter(ImageFilter_1):
    """


    Computes the sigmoid function pixel-wise.


    A linear transformation is applied first on the argument of the
    sigmoid fuction. The resulting total transfrom is given by

    \\[ f(x) = (Max-Min) \\cdot \\frac{1}{\\left(1+e^{- \\frac{
    x - \\beta }{\\alpha}}\\right)} + Min \\]

    Every output pixel is equal to f(x). Where x is the intensity of the
    homologous input pixel, and alpha and beta are user-provided
    constants.

    Wiki Examples:

    All Examples

    Pass image pixels through a sigmoid function
    See:
     itk::simple::Sigmoid for the procedural interface

     itk::SigmoidImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSigmoidImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SigmoidImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SigmoidImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SigmoidImageFilter self) -> SigmoidImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SigmoidImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SigmoidImageFilter
    __del__ = lambda self: None

    def SetAlpha(self, Alpha):
        """
        SetAlpha(SigmoidImageFilter self, double Alpha)



        """
        return _SimpleITK.SigmoidImageFilter_SetAlpha(self, Alpha)


    def GetAlpha(self):
        """
        GetAlpha(SigmoidImageFilter self) -> double



        """
        return _SimpleITK.SigmoidImageFilter_GetAlpha(self)


    def SetBeta(self, Beta):
        """
        SetBeta(SigmoidImageFilter self, double Beta)



        """
        return _SimpleITK.SigmoidImageFilter_SetBeta(self, Beta)


    def GetBeta(self):
        """
        GetBeta(SigmoidImageFilter self) -> double



        """
        return _SimpleITK.SigmoidImageFilter_GetBeta(self)


    def SetOutputMaximum(self, OutputMaximum):
        """
        SetOutputMaximum(SigmoidImageFilter self, double OutputMaximum)



        """
        return _SimpleITK.SigmoidImageFilter_SetOutputMaximum(self, OutputMaximum)


    def GetOutputMaximum(self):
        """
        GetOutputMaximum(SigmoidImageFilter self) -> double



        """
        return _SimpleITK.SigmoidImageFilter_GetOutputMaximum(self)


    def SetOutputMinimum(self, OutputMinimum):
        """
        SetOutputMinimum(SigmoidImageFilter self, double OutputMinimum)



        """
        return _SimpleITK.SigmoidImageFilter_SetOutputMinimum(self, OutputMinimum)


    def GetOutputMinimum(self):
        """
        GetOutputMinimum(SigmoidImageFilter self) -> double



        """
        return _SimpleITK.SigmoidImageFilter_GetOutputMinimum(self)


    def GetName(self):
        """
        GetName(SigmoidImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SigmoidImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SigmoidImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SigmoidImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SigmoidImageFilter self, Image image1) -> Image
        Execute(SigmoidImageFilter self, Image image1, double alpha, double beta, double outputMaximum, double outputMinimum) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SigmoidImageFilter_Execute(self, *args)

SigmoidImageFilter_swigregister = _SimpleITK.SigmoidImageFilter_swigregister
SigmoidImageFilter_swigregister(SigmoidImageFilter)


def Sigmoid(image1, alpha=1, beta=0, outputMaximum=255, outputMinimum=0):
    """
    Sigmoid(Image image1, double alpha=1, double beta=0, double outputMaximum=255, double outputMinimum=0) -> Image



    Computes the sigmoid function pixel-wise.


    This function directly calls the execute method of SigmoidImageFilter in order to support a procedural API


    See:
     itk::simple::SigmoidImageFilter for the object oriented interface



    """
    return _SimpleITK.Sigmoid(image1, alpha, beta, outputMaximum, outputMinimum)
class SignedDanielssonDistanceMapImageFilter(ImageFilter_1):
    """


    This class is parametrized over the type of the input image and the
    type of the output image.

    This filter computes the distance map of the input image as an
    approximation with pixel accuracy to the Euclidean distance.

    For purposes of evaluating the signed distance map, the input is
    assumed to be binary composed of pixels with value 0 and non-zero.

    The inside is considered as having negative distances. Outside is
    treated as having positive distances. To change the convention, use
    the InsideIsPositive(bool) function.

    As a convention, the distance is evaluated from the boundary of the ON
    pixels.

    The filter returns


    A signed distance map with the approximation to the euclidean
    distance.

    A voronoi partition. (See itkDanielssonDistanceMapImageFilter)

    A vector map containing the component of the vector relating the
    current pixel with the closest point of the closest object to this
    pixel. Given that the components of the distance are computed in
    "pixels", the vector is represented by an itk::Offset . That is, physical coordinates are not used. (See
    itkDanielssonDistanceMapImageFilter)
     This filter internally uses the DanielssonDistanceMap filter. This
    filter is N-dimensional.


    See:
     itkDanielssonDistanceMapImageFilter

     itk::simple::SignedDanielssonDistanceMap for the procedural interface

     itk::SignedDanielssonDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSignedDanielssonDistanceMapImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SignedDanielssonDistanceMapImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SignedDanielssonDistanceMapImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SignedDanielssonDistanceMapImageFilter self) -> SignedDanielssonDistanceMapImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SignedDanielssonDistanceMapImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SignedDanielssonDistanceMapImageFilter
    __del__ = lambda self: None

    def SetInsideIsPositive(self, InsideIsPositive):
        """
        SetInsideIsPositive(SignedDanielssonDistanceMapImageFilter self, bool InsideIsPositive)



        Set if the inside represents positive values in the signed distance
        map. By convention ON pixels are treated as inside pixels.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SetInsideIsPositive(self, InsideIsPositive)


    def InsideIsPositiveOn(self):
        """
        InsideIsPositiveOn(SignedDanielssonDistanceMapImageFilter self)



        Set the value of InsideIsPositive to true or false respectfully.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_InsideIsPositiveOn(self)


    def InsideIsPositiveOff(self):
        """
        InsideIsPositiveOff(SignedDanielssonDistanceMapImageFilter self)



        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_InsideIsPositiveOff(self)


    def GetInsideIsPositive(self):
        """
        GetInsideIsPositive(SignedDanielssonDistanceMapImageFilter self) -> bool



        Get if the inside represents positive values in the signed distance
        map. See GetInsideIsPositive()


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetInsideIsPositive(self)


    def SetSquaredDistance(self, SquaredDistance):
        """
        SetSquaredDistance(SignedDanielssonDistanceMapImageFilter self, bool SquaredDistance)



        Set if the distance should be squared.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SetSquaredDistance(self, SquaredDistance)


    def SquaredDistanceOn(self):
        """
        SquaredDistanceOn(SignedDanielssonDistanceMapImageFilter self)



        Set the value of SquaredDistance to true or false respectfully.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SquaredDistanceOn(self)


    def SquaredDistanceOff(self):
        """
        SquaredDistanceOff(SignedDanielssonDistanceMapImageFilter self)



        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SquaredDistanceOff(self)


    def GetSquaredDistance(self):
        """
        GetSquaredDistance(SignedDanielssonDistanceMapImageFilter self) -> bool



        Get the distance squared.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetSquaredDistance(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(SignedDanielssonDistanceMapImageFilter self, bool UseImageSpacing)



        Set if image spacing should be used in computing distances.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(SignedDanielssonDistanceMapImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(SignedDanielssonDistanceMapImageFilter self)



        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(SignedDanielssonDistanceMapImageFilter self) -> bool



        Get whether spacing is used.


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(SignedDanielssonDistanceMapImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SignedDanielssonDistanceMapImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SignedDanielssonDistanceMapImageFilter self, Image image1) -> Image
        Execute(SignedDanielssonDistanceMapImageFilter self, Image image1, bool insideIsPositive, bool squaredDistance, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SignedDanielssonDistanceMapImageFilter_Execute(self, *args)

SignedDanielssonDistanceMapImageFilter_swigregister = _SimpleITK.SignedDanielssonDistanceMapImageFilter_swigregister
SignedDanielssonDistanceMapImageFilter_swigregister(SignedDanielssonDistanceMapImageFilter)


def SignedDanielssonDistanceMap(image1, insideIsPositive=False, squaredDistance=False, useImageSpacing=False):
    """
    SignedDanielssonDistanceMap(Image image1, bool insideIsPositive=False, bool squaredDistance=False, bool useImageSpacing=False) -> Image



    itk::simple::SignedDanielssonDistanceMapImageFilter Procedural Interface


    This function directly calls the execute method of SignedDanielssonDistanceMapImageFilter in order to support a procedural API


    See:
     itk::simple::SignedDanielssonDistanceMapImageFilter for the object oriented interface



    """
    return _SimpleITK.SignedDanielssonDistanceMap(image1, insideIsPositive, squaredDistance, useImageSpacing)
class SignedMaurerDistanceMapImageFilter(ImageFilter_1):
    """


    This filter calculates the Euclidean distance transform of a binary
    image in linear time for arbitrary dimensions.


    Inputs and Outputs
    This is an image-to-image filter. The dimensionality is arbitrary. The
    only dimensionality constraint is that the input and output images be
    of the same dimensions and size. To maintain integer arithmetic within
    the filter, the default output is the signed squared distance. This
    implies that the input image should be of type "unsigned int" or
    "int" whereas the output image is of type "int". Obviously, if the
    user wishes to utilize the image spacing or to have a filter with the
    Euclidean distance (as opposed to the squared distance), output image
    types of float or double should be used.
     The inside is considered as having negative distances. Outside is
    treated as having positive distances. To change the convention, use
    the InsideIsPositive(bool) function.

    Parameters
    Set/GetBackgroundValue specifies the background of the value of the
    input binary image. Normally this is zero and, as such, zero is the
    default value. Other than that, the usage is completely analogous to
    the itk::DanielssonDistanceImageFilter class except it does not return
    the Voronoi map.
     Reference: C. R. Maurer, Jr., R. Qi, and V. Raghavan, "A Linear Time
    Algorithm for Computing Exact Euclidean Distance Transforms of Binary
    Images in Arbitrary Dimensions", IEEE - Transactions on Pattern
    Analysis and Machine Intelligence, 25(2): 265-270, 2003.
    See:
     itk::simple::SignedMaurerDistanceMap for the procedural interface

     itk::SignedMaurerDistanceMapImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSignedMaurerDistanceMapImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SignedMaurerDistanceMapImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SignedMaurerDistanceMapImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SignedMaurerDistanceMapImageFilter self) -> SignedMaurerDistanceMapImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SignedMaurerDistanceMapImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SignedMaurerDistanceMapImageFilter
    __del__ = lambda self: None

    def SetInsideIsPositive(self, InsideIsPositive):
        """
        SetInsideIsPositive(SignedMaurerDistanceMapImageFilter self, bool InsideIsPositive)



        Set if the inside represents positive values in the signed distance
        map. By convention ON pixels are treated as inside pixels.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_SetInsideIsPositive(self, InsideIsPositive)


    def InsideIsPositiveOn(self):
        """
        InsideIsPositiveOn(SignedMaurerDistanceMapImageFilter self)



        Set the value of InsideIsPositive to true or false respectfully.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_InsideIsPositiveOn(self)


    def InsideIsPositiveOff(self):
        """
        InsideIsPositiveOff(SignedMaurerDistanceMapImageFilter self)



        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_InsideIsPositiveOff(self)


    def GetInsideIsPositive(self):
        """
        GetInsideIsPositive(SignedMaurerDistanceMapImageFilter self) -> bool



        Get if the inside represents positive values in the signed distance
        map.
        See:
         GetInsideIsPositive()



        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_GetInsideIsPositive(self)


    def SetSquaredDistance(self, SquaredDistance):
        """
        SetSquaredDistance(SignedMaurerDistanceMapImageFilter self, bool SquaredDistance)



        Set if the distance should be squared.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_SetSquaredDistance(self, SquaredDistance)


    def SquaredDistanceOn(self):
        """
        SquaredDistanceOn(SignedMaurerDistanceMapImageFilter self)



        Set the value of SquaredDistance to true or false respectfully.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_SquaredDistanceOn(self)


    def SquaredDistanceOff(self):
        """
        SquaredDistanceOff(SignedMaurerDistanceMapImageFilter self)



        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_SquaredDistanceOff(self)


    def GetSquaredDistance(self):
        """
        GetSquaredDistance(SignedMaurerDistanceMapImageFilter self) -> bool



        Get the distance squared.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_GetSquaredDistance(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(SignedMaurerDistanceMapImageFilter self, bool UseImageSpacing)



        Set if image spacing should be used in computing distances.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(SignedMaurerDistanceMapImageFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(SignedMaurerDistanceMapImageFilter self)



        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(SignedMaurerDistanceMapImageFilter self) -> bool



        Get whether spacing is used.


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_GetUseImageSpacing(self)


    def GetName(self):
        """
        GetName(SignedMaurerDistanceMapImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SignedMaurerDistanceMapImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SignedMaurerDistanceMapImageFilter self, Image image1) -> Image
        Execute(SignedMaurerDistanceMapImageFilter self, Image image1, bool insideIsPositive, bool squaredDistance, bool useImageSpacing) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SignedMaurerDistanceMapImageFilter_Execute(self, *args)

SignedMaurerDistanceMapImageFilter_swigregister = _SimpleITK.SignedMaurerDistanceMapImageFilter_swigregister
SignedMaurerDistanceMapImageFilter_swigregister(SignedMaurerDistanceMapImageFilter)


def SignedMaurerDistanceMap(image1, insideIsPositive=False, squaredDistance=True, useImageSpacing=False):
    """
    SignedMaurerDistanceMap(Image image1, bool insideIsPositive=False, bool squaredDistance=True, bool useImageSpacing=False) -> Image



    This filter calculates the Euclidean distance transform of a binary
    image in linear time for arbitrary dimensions.


    This function directly calls the execute method of SignedMaurerDistanceMapImageFilter in order to support a procedural API


    See:
     itk::simple::SignedMaurerDistanceMapImageFilter for the object oriented interface



    """
    return _SimpleITK.SignedMaurerDistanceMap(image1, insideIsPositive, squaredDistance, useImageSpacing)
class SimilarityIndexImageFilter(ImageFilter_2):
    """


    Measures the similarity between the set of non-zero pixels of two
    images.


    SimilarityIndexImageFilter measures the similarity between the set non-zero pixels of two images
    using the following formula: \\[ S = \\frac{2 | A \\cap B |}{|A| + |B|} \\] where $A$ and $B$ are respectively the set of non-zero pixels in the first and second
    input images. Operator $|\\cdot|$ represents the size of a set and $\\cap$ represents the intersection of two sets.

    The measure is derived from a reliability measure known as the kappa
    statistic. $S$ is sensitive to both differences in size and in location and have
    been in the literature for comparing two segmentation masks. For more
    information see: "Morphometric Analysis of White Matter Lesions in MR
    Images: Method and Validation", A. P. Zijdenbos, B. M. Dawant, R. A.
    Margolin and A. C. Palmer, IEEE Trans. on Medical Imaging, 13(4) pp
    716-724,1994

    This filter requires the largest possible region of the first image
    and the same corresponding region in the second image. It behaves as
    filter with two input and one output. Thus it can be inserted in a
    pipeline with other filters. The filter passes the first input through
    unmodified.

    This filter is templated over the two input image type. It assume both
    image have the same number of dimensions.


    See:
     itk::SimilarityIndexImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSimilarityIndexImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimilarityIndexImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimilarityIndexImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SimilarityIndexImageFilter self) -> SimilarityIndexImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SimilarityIndexImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SimilarityIndexImageFilter
    __del__ = lambda self: None

    def GetSimilarityIndex(self):
        """
        GetSimilarityIndex(SimilarityIndexImageFilter self) -> double



        Return the computed similarity index.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.SimilarityIndexImageFilter_GetSimilarityIndex(self)


    def GetName(self):
        """
        GetName(SimilarityIndexImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SimilarityIndexImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SimilarityIndexImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SimilarityIndexImageFilter___str__(self)


    def Execute(self, image1, image2):
        """
        Execute(SimilarityIndexImageFilter self, Image image1, Image image2)



        Execute the filter on the input images


        """
        return _SimpleITK.SimilarityIndexImageFilter_Execute(self, image1, image2)

SimilarityIndexImageFilter_swigregister = _SimpleITK.SimilarityIndexImageFilter_swigregister
SimilarityIndexImageFilter_swigregister(SimilarityIndexImageFilter)

class SimpleContourExtractorImageFilter(ImageFilter_1):
    """


    Computes an image of contours which will be the contour of the first
    image.


    A pixel of the source image is considered to belong to the contour if
    its pixel value is equal to the input foreground value and it has in
    its neighborhood at least one pixel which its pixel value is equal to
    the input background value. The output image will have pixels which
    will be set to the output foreground value if they belong to the
    contour, otherwise they will be set to the ouput background value.

    The neighborhood "radius" is set thanks to the radius params.


    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::SimpleContourExtractor for the procedural interface

     itk::SimpleContourExtractorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSimpleContourExtractorImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleContourExtractorImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleContourExtractorImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SimpleContourExtractorImageFilter self) -> SimpleContourExtractorImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SimpleContourExtractorImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SimpleContourExtractorImageFilter
    __del__ = lambda self: None

    def SetInputForegroundValue(self, InputForegroundValue):
        """
        SetInputForegroundValue(SimpleContourExtractorImageFilter self, double InputForegroundValue)



        Set the foreground value used in order to identify a foreground pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetInputForegroundValue(self, InputForegroundValue)


    def GetInputForegroundValue(self):
        """
        GetInputForegroundValue(SimpleContourExtractorImageFilter self) -> double



        Get the foreground value used in order to identify a foreground pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetInputForegroundValue(self)


    def SetInputBackgroundValue(self, InputBackgroundValue):
        """
        SetInputBackgroundValue(SimpleContourExtractorImageFilter self, double InputBackgroundValue)



        Set the background value used in order to identify a background pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetInputBackgroundValue(self, InputBackgroundValue)


    def GetInputBackgroundValue(self):
        """
        GetInputBackgroundValue(SimpleContourExtractorImageFilter self) -> double



        Get the background value used in order to identify a background pixel
        in the input image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetInputBackgroundValue(self)


    def SetRadius(self, *args):
        """
        SetRadius(SimpleContourExtractorImageFilter self, VectorUInt32 Radius)
        SetRadius(SimpleContourExtractorImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(SimpleContourExtractorImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetRadius(self)


    def SetOutputForegroundValue(self, OutputForegroundValue):
        """
        SetOutputForegroundValue(SimpleContourExtractorImageFilter self, double OutputForegroundValue)



        Set the foreground value used in order to identify a foreground pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetOutputForegroundValue(self, OutputForegroundValue)


    def GetOutputForegroundValue(self):
        """
        GetOutputForegroundValue(SimpleContourExtractorImageFilter self) -> double



        Get the foreground value used in order to identify a foreground pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetOutputForegroundValue(self)


    def SetOutputBackgroundValue(self, OutputBackgroundValue):
        """
        SetOutputBackgroundValue(SimpleContourExtractorImageFilter self, double OutputBackgroundValue)



        Set the background value used in order to identify a background pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_SetOutputBackgroundValue(self, OutputBackgroundValue)


    def GetOutputBackgroundValue(self):
        """
        GetOutputBackgroundValue(SimpleContourExtractorImageFilter self) -> double



        Get the background value used in order to identify a background pixel
        in the output image.


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetOutputBackgroundValue(self)


    def GetName(self):
        """
        GetName(SimpleContourExtractorImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SimpleContourExtractorImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SimpleContourExtractorImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SimpleContourExtractorImageFilter self, Image image1) -> Image
        Execute(SimpleContourExtractorImageFilter self, Image image1, double inputForegroundValue, double inputBackgroundValue, VectorUInt32 radius, double outputForegroundValue, double outputBackgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SimpleContourExtractorImageFilter_Execute(self, *args)

SimpleContourExtractorImageFilter_swigregister = _SimpleITK.SimpleContourExtractorImageFilter_swigregister
SimpleContourExtractorImageFilter_swigregister(SimpleContourExtractorImageFilter)


def SimpleContourExtractor(*args, **kwargs):
    """
    SimpleContourExtractor(Image image1, double inputForegroundValue=1.0, double inputBackgroundValue=0.0, VectorUInt32 radius, double outputForegroundValue=1.0, double outputBackgroundValue=0.0) -> Image



    Computes an image of contours which will be the contour of the first
    image.


    This function directly calls the execute method of SimpleContourExtractorImageFilter in order to support a procedural API


    See:
     itk::simple::SimpleContourExtractorImageFilter for the object oriented interface



    """
    return _SimpleITK.SimpleContourExtractor(*args, **kwargs)
class SinImageFilter(ImageFilter_1):
    """


    Computes the sine of each pixel.


    The computations are performed using std::sin(x).

    Wiki Examples:

    All Examples

    Compute the sine of each pixel.
    See:
     itk::simple::Sin for the procedural interface

     itk::SinImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSinImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SinImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SinImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SinImageFilter self) -> SinImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SinImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SinImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(SinImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SinImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SinImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SinImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(SinImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.SinImageFilter_Execute(self, image1)

SinImageFilter_swigregister = _SimpleITK.SinImageFilter_swigregister
SinImageFilter_swigregister(SinImageFilter)


def Sin(image1):
    """
    Sin(Image image1) -> Image



    Computes the sine of each pixel.


    This function directly calls the execute method of SinImageFilter in order to support a procedural API


    See:
     itk::simple::SinImageFilter for the object oriented interface



    """
    return _SimpleITK.Sin(image1)
class SliceImageFilter(ImageFilter_1):
    """



    See:
     itk::simple::Slice for the procedural interface

     itk::SliceImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSliceImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SliceImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SliceImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SliceImageFilter self) -> SliceImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SliceImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SliceImageFilter
    __del__ = lambda self: None

    def SetStart(self, Start):
        """
        SetStart(SliceImageFilter self, VectorInt32 Start)



        """
        return _SimpleITK.SliceImageFilter_SetStart(self, Start)


    def GetStart(self):
        """
        GetStart(SliceImageFilter self) -> VectorInt32



        """
        return _SimpleITK.SliceImageFilter_GetStart(self)


    def SetStop(self, Stop):
        """
        SetStop(SliceImageFilter self, VectorInt32 Stop)



        """
        return _SimpleITK.SliceImageFilter_SetStop(self, Stop)


    def GetStop(self):
        """
        GetStop(SliceImageFilter self) -> VectorInt32



        """
        return _SimpleITK.SliceImageFilter_GetStop(self)


    def SetStep(self, *args):
        """
        SetStep(SliceImageFilter self, VectorInt32 Step)
        SetStep(SliceImageFilter self, int value)



        Set the values of the Step vector all to value


        """
        return _SimpleITK.SliceImageFilter_SetStep(self, *args)


    def GetStep(self):
        """
        GetStep(SliceImageFilter self) -> VectorInt32



        """
        return _SimpleITK.SliceImageFilter_GetStep(self)


    def GetName(self):
        """
        GetName(SliceImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SliceImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SliceImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SliceImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SliceImageFilter self, Image image1) -> Image
        Execute(SliceImageFilter self, Image image1, VectorInt32 start, VectorInt32 stop, VectorInt32 step) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SliceImageFilter_Execute(self, *args)

SliceImageFilter_swigregister = _SimpleITK.SliceImageFilter_swigregister
SliceImageFilter_swigregister(SliceImageFilter)


def Slice(*args, **kwargs):
    """
    Slice(Image image1, VectorInt32 start, VectorInt32 stop, VectorInt32 step) -> Image



    itk::simple::SliceImageFilter Procedural Interface


    This function directly calls the execute method of SliceImageFilter in order to support a procedural API


    See:
     itk::simple::SliceImageFilter for the object oriented interface



    """
    return _SimpleITK.Slice(*args, **kwargs)
class SmoothingRecursiveGaussianImageFilter(ImageFilter_1):
    """


    Computes the smoothing of an image by convolution with the Gaussian
    kernels implemented as IIR filters.


    This filter is implemented using the recursive gaussian filters. For
    multi-component images, the filter works on each component
    independently.

    For this filter to be able to run in-place the input and output image
    types need to be the same and/or the same type as the RealImageType.

    Wiki Examples:

    All Examples

    Gaussian smoothing that works with image adaptors
    See:
     itk::simple::SmoothingRecursiveGaussian for the procedural interface

     itk::SmoothingRecursiveGaussianImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSmoothingRecursiveGaussianImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmoothingRecursiveGaussianImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SmoothingRecursiveGaussianImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SmoothingRecursiveGaussianImageFilter self) -> SmoothingRecursiveGaussianImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SmoothingRecursiveGaussianImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SmoothingRecursiveGaussianImageFilter
    __del__ = lambda self: None

    def SetSigma(self, Sigma):
        """
        SetSigma(SmoothingRecursiveGaussianImageFilter self, double Sigma)



        Set Sigma value. Sigma is measured in the units of image spacing. You
        may use the method SetSigma to set the same value across each axis or
        use the method SetSigmaArray if you need different values along each
        axis.


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_SetSigma(self, Sigma)


    def GetSigma(self):
        """
        GetSigma(SmoothingRecursiveGaussianImageFilter self) -> double



        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_GetSigma(self)


    def SetNormalizeAcrossScale(self, NormalizeAcrossScale):
        """
        SetNormalizeAcrossScale(SmoothingRecursiveGaussianImageFilter self, bool NormalizeAcrossScale)



        This method does not effect the output of this filter.
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_SetNormalizeAcrossScale(self, NormalizeAcrossScale)


    def NormalizeAcrossScaleOn(self):
        """
        NormalizeAcrossScaleOn(SmoothingRecursiveGaussianImageFilter self)



        Set the value of NormalizeAcrossScale to true or false respectfully.


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_NormalizeAcrossScaleOn(self)


    def NormalizeAcrossScaleOff(self):
        """
        NormalizeAcrossScaleOff(SmoothingRecursiveGaussianImageFilter self)



        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_NormalizeAcrossScaleOff(self)


    def GetNormalizeAcrossScale(self):
        """
        GetNormalizeAcrossScale(SmoothingRecursiveGaussianImageFilter self) -> bool



        This method does not effect the output of this filter.
        See:
         RecursiveGaussianImageFilter::SetNormalizeAcrossScale



        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_GetNormalizeAcrossScale(self)


    def GetName(self):
        """
        GetName(SmoothingRecursiveGaussianImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SmoothingRecursiveGaussianImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SmoothingRecursiveGaussianImageFilter self, Image image1) -> Image
        Execute(SmoothingRecursiveGaussianImageFilter self, Image image1, double sigma, bool normalizeAcrossScale) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SmoothingRecursiveGaussianImageFilter_Execute(self, *args)

SmoothingRecursiveGaussianImageFilter_swigregister = _SimpleITK.SmoothingRecursiveGaussianImageFilter_swigregister
SmoothingRecursiveGaussianImageFilter_swigregister(SmoothingRecursiveGaussianImageFilter)


def SmoothingRecursiveGaussian(image1, sigma=1.0, normalizeAcrossScale=False):
    """
    SmoothingRecursiveGaussian(Image image1, double sigma=1.0, bool normalizeAcrossScale=False) -> Image



    Computes the smoothing of an image by convolution with the Gaussian
    kernels implemented as IIR filters.


    This function directly calls the execute method of SmoothingRecursiveGaussianImageFilter in order to support a procedural API


    See:
     itk::simple::SmoothingRecursiveGaussianImageFilter for the object oriented interface



    """
    return _SimpleITK.SmoothingRecursiveGaussian(image1, sigma, normalizeAcrossScale)
class SobelEdgeDetectionImageFilter(ImageFilter_1):
    """


    A 2D or 3D edge detection using the Sobel operator.


    This filter uses the Sobel operator to calculate the image gradient
    and then finds the magnitude of this gradient vector. The Sobel
    gradient magnitude (square-root sum of squares) is an indication of
    edge strength.


    See:
     ImageToImageFilter

     SobelOperator

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    SobelEdgeDetectionImageFilter
    See:
     itk::simple::SobelEdgeDetection for the procedural interface

     itk::SobelEdgeDetectionImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSobelEdgeDetectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SobelEdgeDetectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SobelEdgeDetectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SobelEdgeDetectionImageFilter self) -> SobelEdgeDetectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SobelEdgeDetectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SobelEdgeDetectionImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(SobelEdgeDetectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SobelEdgeDetectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SobelEdgeDetectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SobelEdgeDetectionImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(SobelEdgeDetectionImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.SobelEdgeDetectionImageFilter_Execute(self, image1)

SobelEdgeDetectionImageFilter_swigregister = _SimpleITK.SobelEdgeDetectionImageFilter_swigregister
SobelEdgeDetectionImageFilter_swigregister(SobelEdgeDetectionImageFilter)


def SobelEdgeDetection(image1):
    """
    SobelEdgeDetection(Image image1) -> Image



    A 2D or 3D edge detection using the Sobel operator.


    This function directly calls the execute method of SobelEdgeDetectionImageFilter in order to support a procedural API


    See:
     itk::simple::SobelEdgeDetectionImageFilter for the object oriented interface



    """
    return _SimpleITK.SobelEdgeDetection(image1)
class SpeckleNoiseImageFilter(ImageFilter_1):
    """


    Alter an image with speckle (multiplicative) noise.


    The speckle noise follows a Gamma distribution of mean 1 and standard
    deviation provided by the user. The noise is proportional to the pixel
    intensity.


    Gaetan Lehmann
     This code was contributed in the Insight Journal paper "Noise
    Simulation". https://hdl.handle.net/10380/3158
    See:
     itk::simple::SpeckleNoise for the procedural interface

     itk::SpeckleNoiseImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSpeckleNoiseImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeckleNoiseImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeckleNoiseImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SpeckleNoiseImageFilter self) -> SpeckleNoiseImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SpeckleNoiseImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SpeckleNoiseImageFilter
    __del__ = lambda self: None

    def SetStandardDeviation(self, StandardDeviation):
        """
        SetStandardDeviation(SpeckleNoiseImageFilter self, double StandardDeviation)



        """
        return _SimpleITK.SpeckleNoiseImageFilter_SetStandardDeviation(self, StandardDeviation)


    def GetStandardDeviation(self):
        """
        GetStandardDeviation(SpeckleNoiseImageFilter self) -> double



        """
        return _SimpleITK.SpeckleNoiseImageFilter_GetStandardDeviation(self)


    def SetSeed(self, Seed):
        """
        SetSeed(SpeckleNoiseImageFilter self, uint32_t Seed)



        """
        return _SimpleITK.SpeckleNoiseImageFilter_SetSeed(self, Seed)


    def GetSeed(self):
        """
        GetSeed(SpeckleNoiseImageFilter self) -> uint32_t



        """
        return _SimpleITK.SpeckleNoiseImageFilter_GetSeed(self)


    def GetName(self):
        """
        GetName(SpeckleNoiseImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SpeckleNoiseImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SpeckleNoiseImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SpeckleNoiseImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SpeckleNoiseImageFilter self, Image image1) -> Image
        Execute(SpeckleNoiseImageFilter self, Image image1, double standardDeviation, uint32_t seed) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SpeckleNoiseImageFilter_Execute(self, *args)

SpeckleNoiseImageFilter_swigregister = _SimpleITK.SpeckleNoiseImageFilter_swigregister
SpeckleNoiseImageFilter_swigregister(SpeckleNoiseImageFilter)


def SpeckleNoise(*args, **kwargs):
    """
    SpeckleNoise(Image image1, double standardDeviation=1.0, uint32_t seed) -> Image



    Alter an image with speckle (multiplicative) noise.


    This function directly calls the execute method of SpeckleNoiseImageFilter in order to support a procedural API


    See:
     itk::simple::SpeckleNoiseImageFilter for the object oriented interface



    """
    return _SimpleITK.SpeckleNoise(*args, **kwargs)
class SqrtImageFilter(ImageFilter_1):
    """


    Computes the square root of each pixel.


    The computations are performed using std::sqrt(x).
    See:
     itk::simple::Sqrt for the procedural interface

     itk::SqrtImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSqrtImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SqrtImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SqrtImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SqrtImageFilter self) -> SqrtImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SqrtImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SqrtImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(SqrtImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SqrtImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SqrtImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SqrtImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(SqrtImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.SqrtImageFilter_Execute(self, image1)

SqrtImageFilter_swigregister = _SimpleITK.SqrtImageFilter_swigregister
SqrtImageFilter_swigregister(SqrtImageFilter)


def Sqrt(image1):
    """
    Sqrt(Image image1) -> Image



    Computes the square root of each pixel.


    This function directly calls the execute method of SqrtImageFilter in order to support a procedural API


    See:
     itk::simple::SqrtImageFilter for the object oriented interface



    """
    return _SimpleITK.Sqrt(image1)
class SquareImageFilter(ImageFilter_1):
    """


    Computes the square of the intensity values pixel-wise.


    Wiki Examples:

    All Examples

    Square every pixel in an image
    See:
     itk::simple::Square for the procedural interface

     itk::SquareImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSquareImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquareImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquareImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SquareImageFilter self) -> SquareImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SquareImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SquareImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(SquareImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SquareImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SquareImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SquareImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(SquareImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.SquareImageFilter_Execute(self, image1)

SquareImageFilter_swigregister = _SimpleITK.SquareImageFilter_swigregister
SquareImageFilter_swigregister(SquareImageFilter)


def Square(image1):
    """
    Square(Image image1) -> Image



    Computes the square of the intensity values pixel-wise.


    This function directly calls the execute method of SquareImageFilter in order to support a procedural API


    See:
     itk::simple::SquareImageFilter for the object oriented interface



    """
    return _SimpleITK.Square(image1)
class SquaredDifferenceImageFilter(ImageFilter_2):
    """


    Implements pixel-wise the computation of squared difference.


    This filter is parametrized over the types of the two input images and
    the type of the output image.

    Numeric conversions (castings) are done by the C++ defaults.

    The filter will walk over all the pixels in the two input images, and
    for each one of them it will do the following:


    cast the input 1 pixel value to double

    cast the input 2 pixel value to double

    compute the difference of the two pixel values

    compute the square of the difference

    cast the double value resulting from sqr() to the pixel type of the output image

    store the casted value into the output image.
     The filter expect all images to have the same dimension (e.g. all 2D,
    or all 3D, or all ND)

    Wiki Examples:

    All Examples

    Compute the squared difference of corresponding pixels in two images
    See:
     itk::simple::SquaredDifference for the procedural interface

     itk::SquaredDifferenceImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSquaredDifferenceImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SquaredDifferenceImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SquaredDifferenceImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SquaredDifferenceImageFilter self) -> SquaredDifferenceImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SquaredDifferenceImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SquaredDifferenceImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(SquaredDifferenceImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SquaredDifferenceImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SquaredDifferenceImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SquaredDifferenceImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SquaredDifferenceImageFilter self, Image image1, Image image2) -> Image
        Execute(SquaredDifferenceImageFilter self, Image image1, double constant) -> Image
        Execute(SquaredDifferenceImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.SquaredDifferenceImageFilter_Execute(self, *args)

SquaredDifferenceImageFilter_swigregister = _SimpleITK.SquaredDifferenceImageFilter_swigregister
SquaredDifferenceImageFilter_swigregister(SquaredDifferenceImageFilter)


def SquaredDifference(*args):
    """
    SquaredDifference(Image image1, Image image2) -> Image
    SquaredDifference(Image image1, double constant) -> Image
    SquaredDifference(double constant, Image image2) -> Image



    """
    return _SimpleITK.SquaredDifference(*args)
class StandardDeviationProjectionImageFilter(ImageFilter_1):
    """


    Mean projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     SumProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     BinaryProjectionImageFilter

     itk::simple::StandardDeviationProjection for the procedural interface

     itk::StandardDeviationProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkStandardDeviationProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StandardDeviationProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StandardDeviationProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::StandardDeviationProjectionImageFilter self) -> StandardDeviationProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_StandardDeviationProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_StandardDeviationProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(StandardDeviationProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(StandardDeviationProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_GetProjectionDimension(self)


    def GetName(self):
        """
        GetName(StandardDeviationProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(StandardDeviationProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(StandardDeviationProjectionImageFilter self, Image image1) -> Image
        Execute(StandardDeviationProjectionImageFilter self, Image image1, unsigned int projectionDimension) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.StandardDeviationProjectionImageFilter_Execute(self, *args)

StandardDeviationProjectionImageFilter_swigregister = _SimpleITK.StandardDeviationProjectionImageFilter_swigregister
StandardDeviationProjectionImageFilter_swigregister(StandardDeviationProjectionImageFilter)


def StandardDeviationProjection(image1, projectionDimension=0):
    """
    StandardDeviationProjection(Image image1, unsigned int projectionDimension=0) -> Image



    Mean projection.


    This function directly calls the execute method of StandardDeviationProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::StandardDeviationProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.StandardDeviationProjection(image1, projectionDimension)
class StatisticsImageFilter(ImageFilter_1):
    """


    Compute min. max, variance and mean of an Image .


    StatisticsImageFilter computes the minimum, maximum, sum, mean, variance sigma of an image.
    The filter needs all of its input image. It behaves as a filter with
    an input and output. Thus it can be inserted in a pipline with other
    filters and the statistics will only be recomputed if a downstream
    filter changes.

    The filter passes its input through unmodified. The filter is
    threaded. It computes statistics in each thread then combines them in
    its AfterThreadedGenerate method.

    Wiki Examples:

    All Examples

    Compute min, max, variance and mean of an Image.

    See:
     itk::StatisticsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkStatisticsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StatisticsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StatisticsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::StatisticsImageFilter self) -> StatisticsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_StatisticsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_StatisticsImageFilter
    __del__ = lambda self: None

    def GetMinimum(self):
        """
        GetMinimum(StatisticsImageFilter self) -> double



        Return the computed Minimum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetMinimum(self)


    def GetMaximum(self):
        """
        GetMaximum(StatisticsImageFilter self) -> double



        Return the computed Maximum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetMaximum(self)


    def GetMean(self):
        """
        GetMean(StatisticsImageFilter self) -> double



        Return the computed Mean.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetMean(self)


    def GetSigma(self):
        """
        GetSigma(StatisticsImageFilter self) -> double



        Return the computed Standard Deviation.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetSigma(self)


    def GetVariance(self):
        """
        GetVariance(StatisticsImageFilter self) -> double



        Return the computed Variance.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetVariance(self)


    def GetSum(self):
        """
        GetSum(StatisticsImageFilter self) -> double



        Return the compute Sum.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.StatisticsImageFilter_GetSum(self)


    def GetName(self):
        """
        GetName(StatisticsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.StatisticsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(StatisticsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.StatisticsImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(StatisticsImageFilter self, Image image1)



        Execute the filter on the input image


        """
        return _SimpleITK.StatisticsImageFilter_Execute(self, image1)

StatisticsImageFilter_swigregister = _SimpleITK.StatisticsImageFilter_swigregister
StatisticsImageFilter_swigregister(StatisticsImageFilter)

class SubtractImageFilter(ImageFilter_2):
    """


    Pixel-wise subtraction of two images.


    Subtract each pixel from image2 from its corresponding pixel in
    image1:


    This is done using


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Additionally, a constant can be subtracted from every pixel in an
    image using:



    The result of AddImageFilter with a negative constant is not necessarily the same as SubtractImageFilter . This would be the case when the PixelType defines an operator-() that is not the inverse of operator+()
    Wiki Examples:

    All Examples

    Subtract two images

    Subtract a constant from every pixel in an image
    See:
     itk::simple::Subtract for the procedural interface

     itk::SubtractImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkSubtractImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubtractImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SubtractImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SubtractImageFilter self) -> SubtractImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SubtractImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SubtractImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(SubtractImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SubtractImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SubtractImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SubtractImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SubtractImageFilter self, Image image1, Image image2) -> Image
        Execute(SubtractImageFilter self, Image image1, double constant) -> Image
        Execute(SubtractImageFilter self, double constant, Image image2) -> Image



        """
        return _SimpleITK.SubtractImageFilter_Execute(self, *args)

SubtractImageFilter_swigregister = _SimpleITK.SubtractImageFilter_swigregister
SubtractImageFilter_swigregister(SubtractImageFilter)


def Subtract(*args):
    """
    Subtract(Image image1, Image image2) -> Image
    Subtract(Image image1, double constant) -> Image
    Subtract(double constant, Image image2) -> Image



    """
    return _SimpleITK.Subtract(*args)
class SumProjectionImageFilter(ImageFilter_1):
    """


    Sum projection.


    This class was contributed to the Insight Journal by Gaetan Lehmann.
    The original paper can be found at https://hdl.handle.net/1926/164


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     ProjectionImageFilter

     MedianProjectionImageFilter

     MeanProjectionImageFilter

     MeanProjectionImageFilter

     MaximumProjectionImageFilter

     MinimumProjectionImageFilter

     BinaryProjectionImageFilter

     StandardDeviationProjectionImageFilter

     itk::simple::SumProjection for the procedural interface

     itk::SumProjectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSumProjectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SumProjectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SumProjectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SumProjectionImageFilter self) -> SumProjectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SumProjectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SumProjectionImageFilter
    __del__ = lambda self: None

    def SetProjectionDimension(self, ProjectionDimension):
        """
        SetProjectionDimension(SumProjectionImageFilter self, unsigned int ProjectionDimension)



        """
        return _SimpleITK.SumProjectionImageFilter_SetProjectionDimension(self, ProjectionDimension)


    def GetProjectionDimension(self):
        """
        GetProjectionDimension(SumProjectionImageFilter self) -> unsigned int



        """
        return _SimpleITK.SumProjectionImageFilter_GetProjectionDimension(self)


    def GetName(self):
        """
        GetName(SumProjectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SumProjectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(SumProjectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SumProjectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SumProjectionImageFilter self, Image image1) -> Image
        Execute(SumProjectionImageFilter self, Image image1, unsigned int projectionDimension) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.SumProjectionImageFilter_Execute(self, *args)

SumProjectionImageFilter_swigregister = _SimpleITK.SumProjectionImageFilter_swigregister
SumProjectionImageFilter_swigregister(SumProjectionImageFilter)


def SumProjection(image1, projectionDimension=0):
    """
    SumProjection(Image image1, unsigned int projectionDimension=0) -> Image



    Sum projection.


    This function directly calls the execute method of SumProjectionImageFilter in order to support a procedural API


    See:
     itk::simple::SumProjectionImageFilter for the object oriented interface



    """
    return _SimpleITK.SumProjection(image1, projectionDimension)
class SymmetricForcesDemonsRegistrationFilter(ImageFilter_0):
    """


    Deformably register two images using the demons algorithm.


    This class was contributed by Corinne Mattmann, ETH Zurich,
    Switzerland. based on a variation of the DemonsRegistrationFilter . The basic modification is to use equation (5) from Thirion's paper
    along with the modification for avoiding large deformations when
    gradients have small values.

    SymmetricForcesDemonsRegistrationFilter implements the demons deformable algorithm that register two images
    by computing the deformation field which will map a moving image onto
    a fixed image.

    A deformation field is represented as a image whose pixel type is some
    vector type with at least N elements, where N is the dimension of the
    fixed image. The vector type must support element access via operator
    []. It is assumed that the vector elements behave like floating point
    scalars.

    This class is templated over the fixed image type, moving image type
    and the deformation field type.

    The input fixed and moving images are set via methods SetFixedImage
    and SetMovingImage respectively. An initial deformation field maybe
    set via SetInitialDisplacementField or SetInput. If no initial field
    is set, a zero field is used as the initial condition.

    The algorithm has one parameters: the number of iteration to be
    performed.

    The output deformation field can be obtained via methods GetOutput or
    GetDisplacementField.

    This class make use of the finite difference solver hierarchy. Update
    for each iteration is computed in DemonsRegistrationFunction .


    WARNING:
    This filter assumes that the fixed image type, moving image type and
    deformation field type all have the same number of dimensions.

    See:
     SymmetricForcesDemonsRegistrationFunction

     DemonsRegistrationFilter

     DemonsRegistrationFunction

     itk::SymmetricForcesDemonsRegistrationFilter for the Doxygen on the original ITK class.


    C++ includes: sitkSymmetricForcesDemonsRegistrationFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymmetricForcesDemonsRegistrationFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymmetricForcesDemonsRegistrationFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::SymmetricForcesDemonsRegistrationFilter self) -> SymmetricForcesDemonsRegistrationFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_SymmetricForcesDemonsRegistrationFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_SymmetricForcesDemonsRegistrationFilter
    __del__ = lambda self: None

    def SetStandardDeviations(self, *args):
        """
        SetStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, VectorDouble StandardDeviations)
        SetStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, double value)



        Set the values of the StandardDeviations vector all to value


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetStandardDeviations(self, *args)


    def GetStandardDeviations(self):
        """
        GetStandardDeviations(SymmetricForcesDemonsRegistrationFilter self) -> VectorDouble



        Set/Get the Gaussian smoothing standard deviations for the
        displacement field. The values are set with respect to pixel
        coordinates.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetStandardDeviations(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(SymmetricForcesDemonsRegistrationFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(SymmetricForcesDemonsRegistrationFilter self) -> uint32_t



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetNumberOfIterations(self)


    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(SymmetricForcesDemonsRegistrationFilter self, double MaximumRMSError)



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(SymmetricForcesDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMaximumRMSError(self)


    def SetSmoothDisplacementField(self, SmoothDisplacementField):
        """
        SetSmoothDisplacementField(SymmetricForcesDemonsRegistrationFilter self, bool SmoothDisplacementField)



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetSmoothDisplacementField(self, SmoothDisplacementField)


    def SmoothDisplacementFieldOn(self):
        """
        SmoothDisplacementFieldOn(SymmetricForcesDemonsRegistrationFilter self)



        Set the value of SmoothDisplacementField to true or false
        respectfully.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOn(self)


    def SmoothDisplacementFieldOff(self):
        """
        SmoothDisplacementFieldOff(SymmetricForcesDemonsRegistrationFilter self)



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothDisplacementFieldOff(self)


    def GetSmoothDisplacementField(self):
        """
        GetSmoothDisplacementField(SymmetricForcesDemonsRegistrationFilter self) -> bool



        Set/Get whether the displacement field is smoothed (regularized).
        Smoothing the displacement yields a solution elastic in nature. If
        SmoothDisplacementField is on, then the displacement field is smoothed
        with a Gaussian whose standard deviations are specified with SetStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetSmoothDisplacementField(self)


    def SetSmoothUpdateField(self, SmoothUpdateField):
        """
        SetSmoothUpdateField(SymmetricForcesDemonsRegistrationFilter self, bool SmoothUpdateField)



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetSmoothUpdateField(self, SmoothUpdateField)


    def SmoothUpdateFieldOn(self):
        """
        SmoothUpdateFieldOn(SymmetricForcesDemonsRegistrationFilter self)



        Set the value of SmoothUpdateField to true or false respectfully.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOn(self)


    def SmoothUpdateFieldOff(self):
        """
        SmoothUpdateFieldOff(SymmetricForcesDemonsRegistrationFilter self)



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SmoothUpdateFieldOff(self)


    def GetSmoothUpdateField(self):
        """
        GetSmoothUpdateField(SymmetricForcesDemonsRegistrationFilter self) -> bool



        Set/Get whether the update field is smoothed (regularized). Smoothing
        the update field yields a solution viscous in nature. If
        SmoothUpdateField is on, then the update field is smoothed with a
        Gaussian whose standard deviations are specified with SetUpdateFieldStandardDeviations()


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetSmoothUpdateField(self)


    def SetUpdateFieldStandardDeviations(self, *args):
        """
        SetUpdateFieldStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, VectorDouble UpdateFieldStandardDeviations)
        SetUpdateFieldStandardDeviations(SymmetricForcesDemonsRegistrationFilter self, double value)



        Set the values of the UpdateFieldStandardDeviations vector all to
        value


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetUpdateFieldStandardDeviations(self, *args)


    def GetUpdateFieldStandardDeviations(self):
        """
        GetUpdateFieldStandardDeviations(SymmetricForcesDemonsRegistrationFilter self) -> VectorDouble



        Set the Gaussian smoothing standard deviations for the update field.
        The values are set with respect to pixel coordinates.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetUpdateFieldStandardDeviations(self)


    def SetMaximumKernelWidth(self, MaximumKernelWidth):
        """
        SetMaximumKernelWidth(SymmetricForcesDemonsRegistrationFilter self, unsigned int MaximumKernelWidth)



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetMaximumKernelWidth(self, MaximumKernelWidth)


    def GetMaximumKernelWidth(self):
        """
        GetMaximumKernelWidth(SymmetricForcesDemonsRegistrationFilter self) -> unsigned int



        Set/Get the desired limits of the Gaussian kernel width.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMaximumKernelWidth(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(SymmetricForcesDemonsRegistrationFilter self, double MaximumError)



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(SymmetricForcesDemonsRegistrationFilter self) -> double



        Set/Get the desired maximum error of the Guassian kernel approximate.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMaximumError(self)


    def SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold):
        """
        SetIntensityDifferenceThreshold(SymmetricForcesDemonsRegistrationFilter self, double IntensityDifferenceThreshold)



        Set/Get the threshold below which the absolute difference of intensity
        yields a match. When the intensities match between a moving and fixed
        image pixel, the update vector (for that iteration) will be the zero
        vector. Default is 0.001.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetIntensityDifferenceThreshold(self, IntensityDifferenceThreshold)


    def GetIntensityDifferenceThreshold(self):
        """
        GetIntensityDifferenceThreshold(SymmetricForcesDemonsRegistrationFilter self) -> double



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetIntensityDifferenceThreshold(self)


    def SetUseImageSpacing(self, UseImageSpacing):
        """
        SetUseImageSpacing(SymmetricForcesDemonsRegistrationFilter self, bool UseImageSpacing)



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_SetUseImageSpacing(self, UseImageSpacing)


    def UseImageSpacingOn(self):
        """
        UseImageSpacingOn(SymmetricForcesDemonsRegistrationFilter self)



        Set the value of UseImageSpacing to true or false respectfully.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_UseImageSpacingOn(self)


    def UseImageSpacingOff(self):
        """
        UseImageSpacingOff(SymmetricForcesDemonsRegistrationFilter self)



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_UseImageSpacingOff(self)


    def GetUseImageSpacing(self):
        """
        GetUseImageSpacing(SymmetricForcesDemonsRegistrationFilter self) -> bool



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetUseImageSpacing(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(SymmetricForcesDemonsRegistrationFilter self) -> uint32_t



        Number of iterations run.


        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(SymmetricForcesDemonsRegistrationFilter self) -> double



        Set/Get the root mean squared change of the previous iteration. May
        not be used by all solvers.

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetRMSChange(self)


    def GetMetric(self):
        """
        GetMetric(SymmetricForcesDemonsRegistrationFilter self) -> double



        Get the metric value. The metric value is the mean square difference
        in intensity between the fixed image and transforming moving image
        computed over the the overlapping region between the two images. This
        value is calculated for the current iteration

        This is an active measurement. It may be accessed while the filter is
        being executing in command call-backs and can be accessed after
        execution.


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetMetric(self)


    def GetName(self):
        """
        GetName(SymmetricForcesDemonsRegistrationFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_GetName(self)


    def __str__(self):
        """
        __str__(SymmetricForcesDemonsRegistrationFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(SymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField) -> Image
        Execute(SymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage) -> Image
        Execute(SymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, Image initialDisplacementField, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image
        Execute(SymmetricForcesDemonsRegistrationFilter self, Image fixedImage, Image movingImage, VectorDouble standardDeviations, uint32_t numberOfIterations, double maximumRMSError, bool smoothDisplacementField, bool smoothUpdateField, VectorDouble updateFieldStandardDeviations, unsigned int maximumKernelWidth, double maximumError, double intensityDifferenceThreshold, bool useImageSpacing) -> Image



        """
        return _SimpleITK.SymmetricForcesDemonsRegistrationFilter_Execute(self, *args)

SymmetricForcesDemonsRegistrationFilter_swigregister = _SimpleITK.SymmetricForcesDemonsRegistrationFilter_swigregister
SymmetricForcesDemonsRegistrationFilter_swigregister(SymmetricForcesDemonsRegistrationFilter)

class TanImageFilter(ImageFilter_1):
    """


    Computes the tangent of each input pixel.


    The computations are performed using std::tan(x).
    See:
     itk::simple::Tan for the procedural interface

     itk::TanImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTanImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TanImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TanImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TanImageFilter self) -> TanImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TanImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TanImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(TanImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TanImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TanImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TanImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(TanImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.TanImageFilter_Execute(self, image1)

TanImageFilter_swigregister = _SimpleITK.TanImageFilter_swigregister
TanImageFilter_swigregister(TanImageFilter)


def Tan(image1):
    """
    Tan(Image image1) -> Image



    Computes the tangent of each input pixel.


    This function directly calls the execute method of TanImageFilter in order to support a procedural API


    See:
     itk::simple::TanImageFilter for the object oriented interface



    """
    return _SimpleITK.Tan(image1)
class TernaryAddImageFilter(ImageFilter_3):
    """


    Pixel-wise addition of three images.


    This class is templated over the types of the three input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.
    See:
     itk::simple::TernaryAdd for the procedural interface

     itk::TernaryAddImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTernaryAddImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TernaryAddImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TernaryAddImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TernaryAddImageFilter self) -> TernaryAddImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TernaryAddImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TernaryAddImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(TernaryAddImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TernaryAddImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TernaryAddImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TernaryAddImageFilter___str__(self)


    def Execute(self, image1, image2, image3):
        """
        Execute(TernaryAddImageFilter self, Image image1, Image image2, Image image3) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.TernaryAddImageFilter_Execute(self, image1, image2, image3)

TernaryAddImageFilter_swigregister = _SimpleITK.TernaryAddImageFilter_swigregister
TernaryAddImageFilter_swigregister(TernaryAddImageFilter)


def TernaryAdd(image1, image2, image3):
    """
    TernaryAdd(Image image1, Image image2, Image image3) -> Image



    Pixel-wise addition of three images.


    This function directly calls the execute method of TernaryAddImageFilter in order to support a procedural API


    See:
     itk::simple::TernaryAddImageFilter for the object oriented interface



    """
    return _SimpleITK.TernaryAdd(image1, image2, image3)
class TernaryMagnitudeImageFilter(ImageFilter_3):
    """


    Compute the pixel-wise magnitude of three images.


    This class is templated over the types of the three input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.
    See:
     itk::simple::TernaryMagnitude for the procedural interface

     itk::TernaryMagnitudeImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTernaryMagnitudeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TernaryMagnitudeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TernaryMagnitudeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TernaryMagnitudeImageFilter self) -> TernaryMagnitudeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TernaryMagnitudeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TernaryMagnitudeImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(TernaryMagnitudeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TernaryMagnitudeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TernaryMagnitudeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TernaryMagnitudeImageFilter___str__(self)


    def Execute(self, image1, image2, image3):
        """
        Execute(TernaryMagnitudeImageFilter self, Image image1, Image image2, Image image3) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.TernaryMagnitudeImageFilter_Execute(self, image1, image2, image3)

TernaryMagnitudeImageFilter_swigregister = _SimpleITK.TernaryMagnitudeImageFilter_swigregister
TernaryMagnitudeImageFilter_swigregister(TernaryMagnitudeImageFilter)


def TernaryMagnitude(image1, image2, image3):
    """
    TernaryMagnitude(Image image1, Image image2, Image image3) -> Image



    Compute the pixel-wise magnitude of three images.


    This function directly calls the execute method of TernaryMagnitudeImageFilter in order to support a procedural API


    See:
     itk::simple::TernaryMagnitudeImageFilter for the object oriented interface



    """
    return _SimpleITK.TernaryMagnitude(image1, image2, image3)
class TernaryMagnitudeSquaredImageFilter(ImageFilter_3):
    """


    Compute the pixel-wise squared magnitude of three images.


    This class is templated over the types of the three input images and
    the type of the output image. Numeric conversions (castings) are done
    by the C++ defaults.
    See:
     itk::simple::TernaryMagnitudeSquared for the procedural interface

     itk::TernaryMagnitudeSquaredImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTernaryMagnitudeSquaredImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TernaryMagnitudeSquaredImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TernaryMagnitudeSquaredImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TernaryMagnitudeSquaredImageFilter self) -> TernaryMagnitudeSquaredImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TernaryMagnitudeSquaredImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TernaryMagnitudeSquaredImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(TernaryMagnitudeSquaredImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TernaryMagnitudeSquaredImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TernaryMagnitudeSquaredImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TernaryMagnitudeSquaredImageFilter___str__(self)


    def Execute(self, image1, image2, image3):
        """
        Execute(TernaryMagnitudeSquaredImageFilter self, Image image1, Image image2, Image image3) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.TernaryMagnitudeSquaredImageFilter_Execute(self, image1, image2, image3)

TernaryMagnitudeSquaredImageFilter_swigregister = _SimpleITK.TernaryMagnitudeSquaredImageFilter_swigregister
TernaryMagnitudeSquaredImageFilter_swigregister(TernaryMagnitudeSquaredImageFilter)


def TernaryMagnitudeSquared(image1, image2, image3):
    """
    TernaryMagnitudeSquared(Image image1, Image image2, Image image3) -> Image



    Compute the pixel-wise squared magnitude of three images.


    This function directly calls the execute method of TernaryMagnitudeSquaredImageFilter in order to support a procedural API


    See:
     itk::simple::TernaryMagnitudeSquaredImageFilter for the object oriented interface



    """
    return _SimpleITK.TernaryMagnitudeSquared(image1, image2, image3)
class ThresholdImageFilter(ImageFilter_1):
    """


    Set image values to a user-specified value if they are below, above,
    or between simple threshold values.


    ThresholdImageFilter sets image values to a user-specified "outside" value (by default,
    "black") if the image values are below, above, or between simple
    threshold values.

    The available methods are:

    ThresholdAbove() : The values greater than the threshold value are set
    to OutsideValue

    ThresholdBelow() : The values less than the threshold value are set to
    OutsideValue

    ThresholdOutside() : The values outside the threshold range (less than
    lower or greater than upper) are set to OutsideValue

    Note that these definitions indicate that pixels equal to the
    threshold value are not set to OutsideValue in any of these methods

    The pixels must support the operators >= and <=.

    Wiki Examples:

    All Examples

    Threshold an image
    See:
     itk::simple::Threshold for the procedural interface

     itk::ThresholdImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ThresholdImageFilter self) -> ThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ThresholdImageFilter
    __del__ = lambda self: None

    def SetLower(self, Lower):
        """
        SetLower(ThresholdImageFilter self, double Lower)



        Set/Get methods to set the lower threshold.


        """
        return _SimpleITK.ThresholdImageFilter_SetLower(self, Lower)


    def GetLower(self):
        """
        GetLower(ThresholdImageFilter self) -> double



        Set/Get methods to set the lower threshold.


        """
        return _SimpleITK.ThresholdImageFilter_GetLower(self)


    def SetUpper(self, Upper):
        """
        SetUpper(ThresholdImageFilter self, double Upper)



        Set/Get methods to set the upper threshold.


        """
        return _SimpleITK.ThresholdImageFilter_SetUpper(self, Upper)


    def GetUpper(self):
        """
        GetUpper(ThresholdImageFilter self) -> double



        Set/Get methods to set the upper threshold.


        """
        return _SimpleITK.ThresholdImageFilter_GetUpper(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(ThresholdImageFilter self, double OutsideValue)



        The pixel type must support comparison operators. Set the "outside"
        pixel value. The default value NumericTraits<PixelType>::ZeroValue() .


        """
        return _SimpleITK.ThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(ThresholdImageFilter self) -> double



        Get the "outside" pixel value.


        """
        return _SimpleITK.ThresholdImageFilter_GetOutsideValue(self)


    def GetName(self):
        """
        GetName(ThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ThresholdImageFilter self, Image image1) -> Image
        Execute(ThresholdImageFilter self, Image image1, double lower, double upper, double outsideValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ThresholdImageFilter_Execute(self, *args)

ThresholdImageFilter_swigregister = _SimpleITK.ThresholdImageFilter_swigregister
ThresholdImageFilter_swigregister(ThresholdImageFilter)


def Threshold(image1, lower=0.0, upper=1.0, outsideValue=0.0):
    """
    Threshold(Image image1, double lower=0.0, double upper=1.0, double outsideValue=0.0) -> Image



    Set image values to a user-specified value if they are below, above,
    or between simple threshold values.


    This function directly calls the execute method of ThresholdImageFilter in order to support a procedural API


    See:
     itk::simple::ThresholdImageFilter for the object oriented interface



    """
    return _SimpleITK.Threshold(image1, lower, upper, outsideValue)
class ThresholdMaximumConnectedComponentsImageFilter(ImageFilter_1):
    """


    Finds the threshold value of an image based on maximizing the number
    of objects in the image that are larger than a given minimal size.



    This method is based on Topological Stable State Thresholding to
    calculate the threshold set point. This method is particularly
    effective when there are a large number of objects in a microscopy
    image. Compiling in Debug mode and enable the debug flag for this
    filter to print debug information to see how the filter focuses in on
    a threshold value. Please see the Insight Journal's MICCAI 2005
    workshop for a complete description. References are below.
    Parameters
    The MinimumObjectSizeInPixels parameter is controlled through the
    class Get/SetMinimumObjectSizeInPixels() method. Similar to the
    standard itk::BinaryThresholdImageFilter the Get/SetInside and Get/SetOutside values of the threshold can be
    set. The GetNumberOfObjects() and GetThresholdValue() methods return
    the number of objects above the minimum pixel size and the calculated
    threshold value.
    Automatic Thresholding in ITK
    There are multiple methods to automatically calculate the threshold
    intensity value of an image. As of version 4.0, ITK has a Thresholding
    ( ITKThresholding ) module which contains numerous automatic
    thresholding methods.implements two of these. Topological Stable State
    Thresholding works well on images with a large number of objects to be
    counted.
    References:
    1) Urish KL, August J, Huard J. "Unsupervised segmentation for
    myofiber counting in immunoflourescent images". Insight Journal. ISC
    /NA-MIC/MICCAI Workshop on Open-Source Software (2005) Dspace handle: https://hdl.handle.net/1926/48 2) Pikaz A, Averbuch, A. "Digital image thresholding based on
    topological stable-state". Pattern Recognition, 29(5): 829-843, 1996.

    Questions: email Ken Urish at ken.urish(at)gmail.com Please cc the itk
    list serve for archival purposes.

    See:
     itk::simple::ThresholdMaximumConnectedComponents for the procedural interface

     itk::ThresholdMaximumConnectedComponentsImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkThresholdMaximumConnectedComponentsImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThresholdMaximumConnectedComponentsImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThresholdMaximumConnectedComponentsImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ThresholdMaximumConnectedComponentsImageFilter self) -> ThresholdMaximumConnectedComponentsImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ThresholdMaximumConnectedComponentsImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ThresholdMaximumConnectedComponentsImageFilter
    __del__ = lambda self: None

    def SetMinimumObjectSizeInPixels(self, MinimumObjectSizeInPixels):
        """
        SetMinimumObjectSizeInPixels(ThresholdMaximumConnectedComponentsImageFilter self, uint32_t MinimumObjectSizeInPixels)



        The pixel type must support comparison operators. Set the minimum
        pixel area used to count objects on the image. Thus, only objects that
        have a pixel area greater than the minimum pixel area will be counted
        as an object in the optimization portion of this filter. Essentially,
        it eliminates noise from being counted as an object. The default value
        is zero.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetMinimumObjectSizeInPixels(self, MinimumObjectSizeInPixels)


    def GetMinimumObjectSizeInPixels(self):
        """
        GetMinimumObjectSizeInPixels(ThresholdMaximumConnectedComponentsImageFilter self) -> uint32_t



        The pixel type must support comparison operators. Set the minimum
        pixel area used to count objects on the image. Thus, only objects that
        have a pixel area greater than the minimum pixel area will be counted
        as an object in the optimization portion of this filter. Essentially,
        it eliminates noise from being counted as an object. The default value
        is zero.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetMinimumObjectSizeInPixels(self)


    def SetUpperBoundary(self, UpperBoundary):
        """
        SetUpperBoundary(ThresholdMaximumConnectedComponentsImageFilter self, double UpperBoundary)



        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetUpperBoundary(self, UpperBoundary)


    def GetUpperBoundary(self):
        """
        GetUpperBoundary(ThresholdMaximumConnectedComponentsImageFilter self) -> double



        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetUpperBoundary(self)


    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(ThresholdMaximumConnectedComponentsImageFilter self, uint8_t InsideValue)



        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(ThresholdMaximumConnectedComponentsImageFilter self) -> uint8_t



        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(ThresholdMaximumConnectedComponentsImageFilter self, uint8_t OutsideValue)



        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(ThresholdMaximumConnectedComponentsImageFilter self) -> uint8_t



        The following Set/Get methods are for the binary threshold function.
        This class automatically calculates the lower threshold boundary. The
        upper threshold boundary, inside value, and outside value can be
        defined by the user, however the standard values are used as default
        if not set by the user. The default value of the: Inside value is the
        maximum pixel type intensity. Outside value is the minimum pixel type
        intensity. Upper threshold boundary is the maximum pixel type
        intensity.


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetOutsideValue(self)


    def GetName(self):
        """
        GetName(ThresholdMaximumConnectedComponentsImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ThresholdMaximumConnectedComponentsImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ThresholdMaximumConnectedComponentsImageFilter self, Image image1) -> Image
        Execute(ThresholdMaximumConnectedComponentsImageFilter self, Image image1, uint32_t minimumObjectSizeInPixels, double upperBoundary, uint8_t insideValue, uint8_t outsideValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_Execute(self, *args)

ThresholdMaximumConnectedComponentsImageFilter_swigregister = _SimpleITK.ThresholdMaximumConnectedComponentsImageFilter_swigregister
ThresholdMaximumConnectedComponentsImageFilter_swigregister(ThresholdMaximumConnectedComponentsImageFilter)


def ThresholdMaximumConnectedComponents(*args, **kwargs):
    """
    ThresholdMaximumConnectedComponents(Image image1, uint32_t minimumObjectSizeInPixels=0, double upperBoundary, uint8_t insideValue=1, uint8_t outsideValue=0) -> Image



    Finds the threshold value of an image based on maximizing the number
    of objects in the image that are larger than a given minimal size.


    This function directly calls the execute method of ThresholdMaximumConnectedComponentsImageFilter in order to support a procedural API


    See:
     itk::simple::ThresholdMaximumConnectedComponentsImageFilter for the object oriented interface



    """
    return _SimpleITK.ThresholdMaximumConnectedComponents(*args, **kwargs)
class ThresholdSegmentationLevelSetImageFilter(ImageFilter_2):
    """


    Segments structures in images based on intensity values.


    IMPORTANT
    The SegmentationLevelSetImageFilter class and the ThresholdSegmentationLevelSetFunction class contain additional information necessary to the full
    understanding of how to use this filter.
    OVERVIEW
    This class is a level set method segmentation filter. It constructs a
    speed function which is close to zero at the upper and lower bounds of
    an intensity window, effectively locking the propagating front onto
    those edges. Elsewhere, the front will propagate quickly.
    INPUTS
    This filter requires two inputs. The first input is a seed image. This
    seed image must contain an isosurface that you want to use as the seed
    for your segmentation. It can be a binary, graylevel, or floating
    point image. The only requirement is that it contain a closed
    isosurface that you will identify as the seed by setting the
    IsosurfaceValue parameter of the filter. For a binary image you will
    want to set your isosurface value halfway between your on and off
    values (i.e. for 0's and 1's, use an isosurface value of 0.5).

    The second input is the feature image. This is the image from which
    the speed function will be calculated. For most applications, this is
    the image that you want to segment. The desired isosurface in your
    seed image should lie within the region of your feature image that you
    are trying to segment. Note that this filter does no preprocessing of
    the feature image before thresholding.

    See SegmentationLevelSetImageFilter for more information on Inputs.
    OUTPUTS
    The filter outputs a single, scalar, real-valued image. Positive
    values in the output image are inside the segmentated region and
    negative values in the image are outside of the inside region. The
    zero crossings of the image correspond to the position of the level
    set front.

    See SparseFieldLevelSetImageFilter and SegmentationLevelSetImageFilter for more information.
    PARAMETERS
    In addition to parameters described in SegmentationLevelSetImageFilter , this filter adds the UpperThreshold and LowerThreshold. See ThresholdSegmentationLevelSetFunction for a description of how these values affect the segmentation.

    See:
     SegmentationLevelSetImageFilter

     ThresholdSegmentationLevelSetFunction ,

     SparseFieldLevelSetImageFilter

     itk::simple::ThresholdSegmentationLevelSet for the procedural interface

     itk::ThresholdSegmentationLevelSetImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkThresholdSegmentationLevelSetImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ThresholdSegmentationLevelSetImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ThresholdSegmentationLevelSetImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ThresholdSegmentationLevelSetImageFilter self) -> ThresholdSegmentationLevelSetImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ThresholdSegmentationLevelSetImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ThresholdSegmentationLevelSetImageFilter
    __del__ = lambda self: None

    def SetLowerThreshold(self, LowerThreshold):
        """
        SetLowerThreshold(ThresholdSegmentationLevelSetImageFilter self, double LowerThreshold)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetLowerThreshold(self, LowerThreshold)


    def GetLowerThreshold(self):
        """
        GetLowerThreshold(ThresholdSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetLowerThreshold(self)


    def SetUpperThreshold(self, UpperThreshold):
        """
        SetUpperThreshold(ThresholdSegmentationLevelSetImageFilter self, double UpperThreshold)



        Get/Set the threshold values that will be used to calculate the speed
        function.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetUpperThreshold(self, UpperThreshold)


    def GetUpperThreshold(self):
        """
        GetUpperThreshold(ThresholdSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetUpperThreshold(self)


    def SetMaximumRMSError(self, MaximumRMSError):
        """
        SetMaximumRMSError(ThresholdSegmentationLevelSetImageFilter self, double MaximumRMSError)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetMaximumRMSError(self, MaximumRMSError)


    def GetMaximumRMSError(self):
        """
        GetMaximumRMSError(ThresholdSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetMaximumRMSError(self)


    def SetPropagationScaling(self, PropagationScaling):
        """
        SetPropagationScaling(ThresholdSegmentationLevelSetImageFilter self, double PropagationScaling)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetPropagationScaling(self, PropagationScaling)


    def GetPropagationScaling(self):
        """
        GetPropagationScaling(ThresholdSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetPropagationScaling(self)


    def SetCurvatureScaling(self, CurvatureScaling):
        """
        SetCurvatureScaling(ThresholdSegmentationLevelSetImageFilter self, double CurvatureScaling)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetCurvatureScaling(self, CurvatureScaling)


    def GetCurvatureScaling(self):
        """
        GetCurvatureScaling(ThresholdSegmentationLevelSetImageFilter self) -> double



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetCurvatureScaling(self)


    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(ThresholdSegmentationLevelSetImageFilter self, uint32_t NumberOfIterations)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(ThresholdSegmentationLevelSetImageFilter self) -> uint32_t



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetNumberOfIterations(self)


    def SetReverseExpansionDirection(self, ReverseExpansionDirection):
        """
        SetReverseExpansionDirection(ThresholdSegmentationLevelSetImageFilter self, bool ReverseExpansionDirection)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_SetReverseExpansionDirection(self, ReverseExpansionDirection)


    def ReverseExpansionDirectionOn(self):
        """
        ReverseExpansionDirectionOn(ThresholdSegmentationLevelSetImageFilter self)



        Set the value of ReverseExpansionDirection to true or false
        respectfully.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_ReverseExpansionDirectionOn(self)


    def ReverseExpansionDirectionOff(self):
        """
        ReverseExpansionDirectionOff(ThresholdSegmentationLevelSetImageFilter self)



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_ReverseExpansionDirectionOff(self)


    def GetReverseExpansionDirection(self):
        """
        GetReverseExpansionDirection(ThresholdSegmentationLevelSetImageFilter self) -> bool



        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetReverseExpansionDirection(self)


    def GetElapsedIterations(self):
        """
        GetElapsedIterations(ThresholdSegmentationLevelSetImageFilter self) -> uint32_t



        Number of iterations run.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetElapsedIterations(self)


    def GetRMSChange(self):
        """
        GetRMSChange(ThresholdSegmentationLevelSetImageFilter self) -> double



        The Root Mean Square of the levelset upon termination.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetRMSChange(self)


    def GetName(self):
        """
        GetName(ThresholdSegmentationLevelSetImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ThresholdSegmentationLevelSetImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ThresholdSegmentationLevelSetImageFilter self, Image image1, Image image2) -> Image
        Execute(ThresholdSegmentationLevelSetImageFilter self, Image image1, Image image2, double lowerThreshold, double upperThreshold, double maximumRMSError, double propagationScaling, double curvatureScaling, uint32_t numberOfIterations, bool reverseExpansionDirection) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.ThresholdSegmentationLevelSetImageFilter_Execute(self, *args)

ThresholdSegmentationLevelSetImageFilter_swigregister = _SimpleITK.ThresholdSegmentationLevelSetImageFilter_swigregister
ThresholdSegmentationLevelSetImageFilter_swigregister(ThresholdSegmentationLevelSetImageFilter)


def ThresholdSegmentationLevelSet(image1, image2, lowerThreshold=0.0, upperThreshold=255.0, maximumRMSError=0.02, propagationScaling=1.0, curvatureScaling=1.0, numberOfIterations=1000, reverseExpansionDirection=False):
    """
    ThresholdSegmentationLevelSet(Image image1, Image image2, double lowerThreshold=0.0, double upperThreshold=255.0, double maximumRMSError=0.02, double propagationScaling=1.0, double curvatureScaling=1.0, uint32_t numberOfIterations=1000, bool reverseExpansionDirection=False) -> Image



    Segments structures in images based on intensity values.


    This function directly calls the execute method of ThresholdSegmentationLevelSetImageFilter in order to support a procedural API


    See:
     itk::simple::ThresholdSegmentationLevelSetImageFilter for the object oriented interface



    """
    return _SimpleITK.ThresholdSegmentationLevelSet(image1, image2, lowerThreshold, upperThreshold, maximumRMSError, propagationScaling, curvatureScaling, numberOfIterations, reverseExpansionDirection)
class TikhonovDeconvolutionImageFilter(ImageFilter_2):
    """


    An inverse deconvolution filter regularized in the Tikhonov sense.


    The Tikhonov deconvolution filter is the inverse deconvolution filter
    with a regularization term added to the denominator. The filter
    minimizes the equation \\[ ||\\hat{f} \\otimes h - g||_{L_2}^2 + \\mu||\\hat{f}||^2
    \\] where $\\hat{f}$ is the estimate of the unblurred image, $h$ is the blurring kernel, $g$ is the blurred image, and $\\mu$ is a non-negative real regularization function.

    The filter applies a kernel described in the Fourier domain as $H^*(\\omega) / (|H(\\omega)|^2 + \\mu)$ where $H(\\omega)$ is the Fourier transform of $h$ . The term $\\mu$ is called RegularizationConstant in this filter. If $\\mu$ is set to zero, this filter is equivalent to the InverseDeconvolutionImageFilter .


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France
     Cory Quammen, The University of North Carolina at Chapel Hill
    See:
     itk::simple::TikhonovDeconvolution for the procedural interface

     itk::TikhonovDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTikhonovDeconvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TikhonovDeconvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TikhonovDeconvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TikhonovDeconvolutionImageFilter self) -> TikhonovDeconvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TikhonovDeconvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TikhonovDeconvolutionImageFilter
    __del__ = lambda self: None

    def SetRegularizationConstant(self, RegularizationConstant):
        """
        SetRegularizationConstant(TikhonovDeconvolutionImageFilter self, double RegularizationConstant)



        The regularization factor. Larger values reduce the dominance of noise
        in the solution, but results in higher approximation error in the
        deblurred image. Default value is 0.0, yielding the same results as
        the InverseDeconvolutionImageFilter .


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetRegularizationConstant(self, RegularizationConstant)


    def GetRegularizationConstant(self):
        """
        GetRegularizationConstant(TikhonovDeconvolutionImageFilter self) -> double



        The regularization factor. Larger values reduce the dominance of noise
        in the solution, but results in higher approximation error in the
        deblurred image. Default value is 0.0, yielding the same results as
        the InverseDeconvolutionImageFilter .


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetRegularizationConstant(self)


    def SetNormalize(self, Normalize):
        """
        SetNormalize(TikhonovDeconvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(TikhonovDeconvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(TikhonovDeconvolutionImageFilter self)



        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(TikhonovDeconvolutionImageFilter self) -> bool



        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.TikhonovDeconvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.TikhonovDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.TikhonovDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(TikhonovDeconvolutionImageFilter self, itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(TikhonovDeconvolutionImageFilter self) -> itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.TikhonovDeconvolutionImageFilter_SAME
    VALID = _SimpleITK.TikhonovDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(TikhonovDeconvolutionImageFilter self, itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(TikhonovDeconvolutionImageFilter self) -> itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(TikhonovDeconvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TikhonovDeconvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(TikhonovDeconvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(TikhonovDeconvolutionImageFilter self, Image image1, Image image2, double regularizationConstant, bool normalize, itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.TikhonovDeconvolutionImageFilter_Execute(self, *args)

TikhonovDeconvolutionImageFilter_swigregister = _SimpleITK.TikhonovDeconvolutionImageFilter_swigregister
TikhonovDeconvolutionImageFilter_swigregister(TikhonovDeconvolutionImageFilter)


def TikhonovDeconvolution(*args, **kwargs):
    """
    TikhonovDeconvolution(Image image1, Image image2, double regularizationConstant=0.0, bool normalize=False, itk::simple::TikhonovDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::TikhonovDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    An inverse deconvolution filter regularized in the Tikhonov sense.


    This function directly calls the execute method of TikhonovDeconvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::TikhonovDeconvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.TikhonovDeconvolution(*args, **kwargs)
class TileImageFilter(ImageFilter_3):
    """


    Tile multiple input images into a single output image.


    This filter will tile multiple images using a user-specified layout.
    The tile sizes will be large enough to accommodate the largest image
    for each tile. The layout is specified with the SetLayout method. The
    layout has the same dimension as the output image. If all entries of
    the layout are positive, the tiled output will contain the exact
    number of tiles. If the layout contains a 0 in the last dimension, the
    filter will compute a size that will accommodate all of the images.
    Empty tiles are filled with the value specified with the SetDefault
    value method. The input images must have a dimension less than or
    equal to the output image. The output image have a larger dimension
    than the input images. This filter can be used to create a volume from
    a series of inputs by specifying a layout of 1,1,0.

    Wiki Examples:

    All Examples

    Tile multiple images into another image

    Stack multiple 2D images into a 3D image

    Tile multiple images side by side

    See:
     itk::simple::Tile for the procedural interface


    C++ includes: sitkTileImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TileImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_3]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TileImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TileImageFilter self) -> TileImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TileImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TileImageFilter
    __del__ = lambda self: None

    def SetLayout(self, Layout):
        """
        SetLayout(TileImageFilter self, VectorUInt32 Layout)



        """
        return _SimpleITK.TileImageFilter_SetLayout(self, Layout)


    def GetLayout(self):
        """
        GetLayout(TileImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.TileImageFilter_GetLayout(self)


    def SetDefaultPixelValue(self, DefaultPixelValue):
        """
        SetDefaultPixelValue(TileImageFilter self, double DefaultPixelValue)



        """
        return _SimpleITK.TileImageFilter_SetDefaultPixelValue(self, DefaultPixelValue)


    def GetDefaultPixelValue(self):
        """
        GetDefaultPixelValue(TileImageFilter self) -> double



        """
        return _SimpleITK.TileImageFilter_GetDefaultPixelValue(self)


    def GetName(self):
        """
        GetName(TileImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TileImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TileImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TileImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(TileImageFilter self, VectorOfImage images) -> Image
        Execute(TileImageFilter self, Image image1) -> Image
        Execute(TileImageFilter self, Image image1, Image image2) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, Image image4) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5) -> Image
        Execute(TileImageFilter self, VectorOfImage images, VectorUInt32 layout, double defaultPixelValue) -> Image
        Execute(TileImageFilter self, Image image1, VectorUInt32 layout, double defaultPixelValue) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, VectorUInt32 layout, double defaultPixelValue) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, VectorUInt32 layout, double defaultPixelValue) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, Image image4, VectorUInt32 layout, double defaultPixelValue) -> Image
        Execute(TileImageFilter self, Image image1, Image image2, Image image3, Image image4, Image image5, VectorUInt32 layout, double defaultPixelValue) -> Image



        """
        return _SimpleITK.TileImageFilter_Execute(self, *args)

TileImageFilter_swigregister = _SimpleITK.TileImageFilter_swigregister
TileImageFilter_swigregister(TileImageFilter)


def Tile(*args):
    """
    Tile(VectorOfImage images, VectorUInt32 layout, double defaultPixelValue=0.0) -> Image
    Tile(Image image1, VectorUInt32 layout, double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, VectorUInt32 layout, double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, Image image3, VectorUInt32 layout, double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, Image image3, Image image4, VectorUInt32 layout, double defaultPixelValue=0.0) -> Image
    Tile(Image image1, Image image2, Image image3, Image image4, Image image5, VectorUInt32 layout, double defaultPixelValue=0.0) -> Image
    """
    return _SimpleITK.Tile(*args)
class TransformToDisplacementFieldFilter(ImageFilter_0):
    """


    Generate a displacement field from a coordinate transform.


    Output information (spacing, size and direction) for the output image
    should be set. This information has the normal defaults of unit
    spacing, zero origin and identity direction. Optionally, the output
    information can be obtained from a reference image. If the reference
    image is provided and UseReferenceImage is On, then the spacing,
    origin and direction of the reference image will be used.

    Since this filter produces an image which is a different size than its
    input, it needs to override several of the methods defined in ProcessObject in order to properly manage the pipeline execution model. In
    particular, this filter overrides
    ProcessObject::GenerateOutputInformation() .

    This filter is implemented as a multithreaded filter. It provides a
    ThreadedGenerateData() method for its implementation.


    Marius Staring, Leiden University Medical Center, The Netherlands.
     This class was taken from the Insight Journal paper: https://hdl.handle.net/1926/1387
    See:
     itk::simple::TransformToDisplacementFieldFilter for the procedural interface

     itk::TransformToDisplacementFieldFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTransformToDisplacementFieldFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransformToDisplacementFieldFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransformToDisplacementFieldFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TransformToDisplacementFieldFilter self) -> TransformToDisplacementFieldFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TransformToDisplacementFieldFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TransformToDisplacementFieldFilter
    __del__ = lambda self: None

    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(TransformToDisplacementFieldFilter self, itk::simple::PixelIDValueEnum OutputPixelType)



        Set the output pixel type, only sitkVectorFloat32 and
        sitkVectorFloat64 are supported.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(TransformToDisplacementFieldFilter self) -> itk::simple::PixelIDValueEnum



        Get the ouput pixel type.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetOutputPixelType(self)


    def SetSize(self, Size):
        """
        SetSize(TransformToDisplacementFieldFilter self, VectorUInt32 Size)



        Set/Get the size of the output image.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetSize(self, Size)


    def GetSize(self):
        """
        GetSize(TransformToDisplacementFieldFilter self) -> VectorUInt32



        Set/Get the size of the output image.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetSize(self)


    def SetOutputOrigin(self, OutputOrigin):
        """
        SetOutputOrigin(TransformToDisplacementFieldFilter self, VectorDouble OutputOrigin)



        Set the output image origin.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetOutputOrigin(self, OutputOrigin)


    def GetOutputOrigin(self):
        """
        GetOutputOrigin(TransformToDisplacementFieldFilter self) -> VectorDouble



        Get the output image origin.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetOutputOrigin(self)


    def SetOutputSpacing(self, OutputSpacing):
        """
        SetOutputSpacing(TransformToDisplacementFieldFilter self, VectorDouble OutputSpacing)



        Set the output image spacing.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetOutputSpacing(self, OutputSpacing)


    def GetOutputSpacing(self):
        """
        GetOutputSpacing(TransformToDisplacementFieldFilter self) -> VectorDouble



        Get the output image spacing.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetOutputSpacing(self)


    def SetOutputDirection(self, OutputDirection):
        """
        SetOutputDirection(TransformToDisplacementFieldFilter self, VectorDouble OutputDirection)



        Set the output direction cosine matrix.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetOutputDirection(self, OutputDirection)


    def GetOutputDirection(self):
        """
        GetOutputDirection(TransformToDisplacementFieldFilter self) -> VectorDouble



        Set the output direction cosine matrix.


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetOutputDirection(self)


    def GetName(self):
        """
        GetName(TransformToDisplacementFieldFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_GetName(self)


    def __str__(self):
        """
        __str__(TransformToDisplacementFieldFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TransformToDisplacementFieldFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(TransformToDisplacementFieldFilter self, Transform transform) -> Image
        Execute(TransformToDisplacementFieldFilter self, Transform transform, itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_Execute(self, *args)


    def SetReferenceImage(self, refImage):
        """
        SetReferenceImage(TransformToDisplacementFieldFilter self, Image refImage)



        This methods sets the size, origin, spacing and direction to that of
        the provided image


        """
        return _SimpleITK.TransformToDisplacementFieldFilter_SetReferenceImage(self, refImage)

TransformToDisplacementFieldFilter_swigregister = _SimpleITK.TransformToDisplacementFieldFilter_swigregister
TransformToDisplacementFieldFilter_swigregister(TransformToDisplacementFieldFilter)


def TransformToDisplacementField(*args, **kwargs):
    """
    TransformToDisplacementField(Transform transform, itk::simple::PixelIDValueEnum outputPixelType, VectorUInt32 size, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection) -> Image



    Generate a displacement field from a coordinate transform.


    This function directly calls the execute method of TransformToDisplacementFieldFilter in order to support a procedural API


    See:
     itk::simple::TransformToDisplacementFieldFilter for the object oriented interface



    """
    return _SimpleITK.TransformToDisplacementField(*args, **kwargs)
class TriangleThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Triangle Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the TriangleThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::TriangleThreshold for the procedural interface

     itk::TriangleThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkTriangleThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriangleThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriangleThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::TriangleThresholdImageFilter self) -> TriangleThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_TriangleThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_TriangleThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(TriangleThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(TriangleThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(TriangleThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(TriangleThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(TriangleThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(TriangleThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.TriangleThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(TriangleThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(TriangleThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.TriangleThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(TriangleThresholdImageFilter self)



        """
        return _SimpleITK.TriangleThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(TriangleThresholdImageFilter self) -> bool



        """
        return _SimpleITK.TriangleThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(TriangleThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.TriangleThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(TriangleThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.TriangleThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(TriangleThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(TriangleThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.TriangleThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(TriangleThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.TriangleThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(TriangleThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(TriangleThresholdImageFilter self, Image image) -> Image
        Execute(TriangleThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(TriangleThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.TriangleThresholdImageFilter_Execute(self, *args)

TriangleThresholdImageFilter_swigregister = _SimpleITK.TriangleThresholdImageFilter_swigregister
TriangleThresholdImageFilter_swigregister(TriangleThresholdImageFilter)


def TriangleThreshold(*args):
    """
    TriangleThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    TriangleThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.TriangleThreshold(*args)
class UnaryMinusImageFilter(ImageFilter_1):
    """


    Computes the negative of each pixel.



    See:
     itk::simple::UnaryMinus for the procedural interface

     itk::UnaryFunctorImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkUnaryMinusImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnaryMinusImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnaryMinusImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::UnaryMinusImageFilter self) -> UnaryMinusImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_UnaryMinusImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_UnaryMinusImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(UnaryMinusImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.UnaryMinusImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(UnaryMinusImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.UnaryMinusImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(UnaryMinusImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.UnaryMinusImageFilter_Execute(self, image1)

UnaryMinusImageFilter_swigregister = _SimpleITK.UnaryMinusImageFilter_swigregister
UnaryMinusImageFilter_swigregister(UnaryMinusImageFilter)


def UnaryMinus(image1):
    """
    UnaryMinus(Image image1) -> Image



    Computes the negative of each pixel.


    This function directly calls the execute method of UnaryMinusImageFilter in order to support a procedural API


    See:
     itk::simple::UnaryMinusImageFilter for the object oriented interface



    """
    return _SimpleITK.UnaryMinus(image1)
class ValuedRegionalMaximaImageFilter(ImageFilter_1):
    """


    Transforms the image so that any pixel that is not a regional maxima
    is set to the minimum value for the pixel type. Pixels that are
    regional maxima retain their value.


    Regional maxima are flat zones surrounded by pixels of lower value. A
    completely flat image will be marked as a regional maxima by this
    filter.

    This code was contributed in the Insight Journal paper: "Finding
    regional extrema - methods and performance" by Beare R., Lehmann G. https://hdl.handle.net/1926/153 http://www.insight-journal.org/browse/publication/65


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     ValuedRegionalMinimaImageFilter

     ValuedRegionalExtremaImageFilter

     HMinimaImageFilter
    Wiki Examples:

    All Examples

    ValuedRegionalMaximaImageFilter
    See:
     itk::simple::ValuedRegionalMaxima for the procedural interface

     itk::ValuedRegionalMaximaImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkValuedRegionalMaximaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValuedRegionalMaximaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValuedRegionalMaximaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ValuedRegionalMaximaImageFilter self) -> ValuedRegionalMaximaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ValuedRegionalMaximaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ValuedRegionalMaximaImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ValuedRegionalMaximaImageFilter self, bool FullyConnected)



        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ValuedRegionalMaximaImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ValuedRegionalMaximaImageFilter self)



        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ValuedRegionalMaximaImageFilter self) -> bool



        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_GetFullyConnected(self)


    def GetFlat(self):
        """
        GetFlat(ValuedRegionalMaximaImageFilter self) -> bool



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_GetFlat(self)


    def GetName(self):
        """
        GetName(ValuedRegionalMaximaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ValuedRegionalMaximaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ValuedRegionalMaximaImageFilter self, Image image1) -> Image
        Execute(ValuedRegionalMaximaImageFilter self, Image image1, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ValuedRegionalMaximaImageFilter_Execute(self, *args)

ValuedRegionalMaximaImageFilter_swigregister = _SimpleITK.ValuedRegionalMaximaImageFilter_swigregister
ValuedRegionalMaximaImageFilter_swigregister(ValuedRegionalMaximaImageFilter)


def ValuedRegionalMaxima(image1, fullyConnected=False):
    """
    ValuedRegionalMaxima(Image image1, bool fullyConnected=False) -> Image



    Transforms the image so that any pixel that is not a regional maxima
    is set to the minimum value for the pixel type. Pixels that are
    regional maxima retain their value.


    This function directly calls the execute method of ValuedRegionalMaximaImageFilter in order to support a procedural API


    See:
     itk::simple::ValuedRegionalMaximaImageFilter for the object oriented interface



    """
    return _SimpleITK.ValuedRegionalMaxima(image1, fullyConnected)
class ValuedRegionalMinimaImageFilter(ImageFilter_1):
    """


    Transforms the image so that any pixel that is not a regional minima
    is set to the maximum value for the pixel type. Pixels that are
    regional minima retain their value.


    Regional minima are flat zones surrounded by pixels of higher value. A
    completely flat image will be marked as a regional minima by this
    filter.

    This code was contributed in the Insight Journal paper: "Finding
    regional extrema - methods and performance" by Beare R., Lehmann G. https://hdl.handle.net/1926/153 http://www.insight-journal.org/browse/publication/65


    Richard Beare. Department of Medicine, Monash University, Melbourne,
    Australia.

    See:
     ValuedRegionalMaximaImageFilter , ValuedRegionalExtremaImageFilter ,

     HMinimaImageFilter
    Wiki Examples:

    All Examples

    ValuedRegionalMinimaImageFilter
    See:
     itk::simple::ValuedRegionalMinima for the procedural interface

     itk::ValuedRegionalMinimaImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkValuedRegionalMinimaImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValuedRegionalMinimaImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValuedRegionalMinimaImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ValuedRegionalMinimaImageFilter self) -> ValuedRegionalMinimaImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ValuedRegionalMinimaImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ValuedRegionalMinimaImageFilter
    __del__ = lambda self: None

    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(ValuedRegionalMinimaImageFilter self, bool FullyConnected)



        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(ValuedRegionalMinimaImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(ValuedRegionalMinimaImageFilter self)



        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(ValuedRegionalMinimaImageFilter self) -> bool



        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_GetFullyConnected(self)


    def GetFlat(self):
        """
        GetFlat(ValuedRegionalMinimaImageFilter self) -> bool



        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_GetFlat(self)


    def GetName(self):
        """
        GetName(ValuedRegionalMinimaImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ValuedRegionalMinimaImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ValuedRegionalMinimaImageFilter self, Image image1) -> Image
        Execute(ValuedRegionalMinimaImageFilter self, Image image1, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ValuedRegionalMinimaImageFilter_Execute(self, *args)

ValuedRegionalMinimaImageFilter_swigregister = _SimpleITK.ValuedRegionalMinimaImageFilter_swigregister
ValuedRegionalMinimaImageFilter_swigregister(ValuedRegionalMinimaImageFilter)


def ValuedRegionalMinima(image1, fullyConnected=False):
    """
    ValuedRegionalMinima(Image image1, bool fullyConnected=False) -> Image



    Transforms the image so that any pixel that is not a regional minima
    is set to the maximum value for the pixel type. Pixels that are
    regional minima retain their value.


    This function directly calls the execute method of ValuedRegionalMinimaImageFilter in order to support a procedural API


    See:
     itk::simple::ValuedRegionalMinimaImageFilter for the object oriented interface



    """
    return _SimpleITK.ValuedRegionalMinima(image1, fullyConnected)
class VectorConfidenceConnectedImageFilter(ImageFilter_1):
    """


    Segment pixels with similar statistics using connectivity.


    This filter extracts a connected set of pixels whose pixel intensities
    are consistent with the pixel statistics of a seed point. The mean and
    variance across a neighborhood (8-connected, 26-connected, etc.) are
    calculated for a seed point. Then pixels connected to this seed point
    whose values are within the confidence interval for the seed point are
    grouped. The width of the confidence interval is controlled by the
    "Multiplier" variable (the confidence interval is the mean plus or
    minus the "Multiplier" times the standard deviation). If the
    intensity variations across a segment were gaussian, a "Multiplier"
    setting of 2.5 would define a confidence interval wide enough to
    capture 99% of samples in the segment.

    After this initial segmentation is calculated, the mean and variance
    are re-calculated. All the pixels in the previous segmentation are
    used to calculate the mean the standard deviation (as opposed to using
    the pixels in the neighborhood of the seed point). The segmentation is
    then recalculted using these refined estimates for the mean and
    variance of the pixel values. This process is repeated for the
    specified number of iterations. Setting the "NumberOfIterations" to
    zero stops the algorithm after the initial segmentation from the seed
    point.

    NOTE: the lower and upper threshold are restricted to lie within the
    valid numeric limits of the input data pixel type. Also, the limits
    may be adjusted to contain the seed point's intensity.
    See:
     itk::simple::VectorConfidenceConnected for the procedural interface

     itk::VectorConfidenceConnectedImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVectorConfidenceConnectedImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorConfidenceConnectedImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorConfidenceConnectedImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VectorConfidenceConnectedImageFilter self) -> VectorConfidenceConnectedImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VectorConfidenceConnectedImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VectorConfidenceConnectedImageFilter
    __del__ = lambda self: None

    def SetNumberOfIterations(self, NumberOfIterations):
        """
        SetNumberOfIterations(VectorConfidenceConnectedImageFilter self, unsigned int NumberOfIterations)



        Set/Get the number of iterations


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetNumberOfIterations(self, NumberOfIterations)


    def GetNumberOfIterations(self):
        """
        GetNumberOfIterations(VectorConfidenceConnectedImageFilter self) -> unsigned int



        Set/Get the number of iterations


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetNumberOfIterations(self)


    def SetMultiplier(self, Multiplier):
        """
        SetMultiplier(VectorConfidenceConnectedImageFilter self, double Multiplier)



        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetMultiplier(self, Multiplier)


    def GetMultiplier(self):
        """
        GetMultiplier(VectorConfidenceConnectedImageFilter self) -> double



        Set/Get the multiplier to define the confidence interval. Multiplier
        can be anything greater than zero. A typical value is 2.5


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetMultiplier(self)


    def SetInitialNeighborhoodRadius(self, InitialNeighborhoodRadius):
        """
        SetInitialNeighborhoodRadius(VectorConfidenceConnectedImageFilter self, unsigned int InitialNeighborhoodRadius)



        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetInitialNeighborhoodRadius(self, InitialNeighborhoodRadius)


    def GetInitialNeighborhoodRadius(self):
        """
        GetInitialNeighborhoodRadius(VectorConfidenceConnectedImageFilter self) -> unsigned int



        Get/Set the radius of the neighborhood over which the statistics are
        evaluated


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetInitialNeighborhoodRadius(self)


    def SetReplaceValue(self, ReplaceValue):
        """
        SetReplaceValue(VectorConfidenceConnectedImageFilter self, uint8_t ReplaceValue)



        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetReplaceValue(self, ReplaceValue)


    def GetReplaceValue(self):
        """
        GetReplaceValue(VectorConfidenceConnectedImageFilter self) -> uint8_t



        Set/Get value to replace thresholded pixels


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetReplaceValue(self)


    def GetMean(self):
        """
        GetMean(VectorConfidenceConnectedImageFilter self) -> VectorDouble



        Get the Mean Vector computed during the segmentation

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetMean(self)


    def GetCovariance(self):
        """
        GetCovariance(VectorConfidenceConnectedImageFilter self) -> VectorDouble



        Get the Covariance matrix computed during the segmentation

        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetCovariance(self)


    def SetSeedList(self, t):
        """
        SetSeedList(VectorConfidenceConnectedImageFilter self, VectorUIntList t)



        Set SeedList


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetSeedList(self, t)


    def GetSeedList(self):
        """
        GetSeedList(VectorConfidenceConnectedImageFilter self) -> VectorUIntList



        Get SeedList


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetSeedList(self)


    def ClearSeeds(self):
        """
        ClearSeeds(VectorConfidenceConnectedImageFilter self)



        ClearSeeds - Clear out all seeds in the list


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_ClearSeeds(self)


    def SetSeed(self, idx):
        """
        SetSeed(VectorConfidenceConnectedImageFilter self, VectorUInt32 idx)



        SetSeed - Set list to a single seed


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_SetSeed(self, idx)


    def AddSeed(self, idx):
        """
        AddSeed(VectorConfidenceConnectedImageFilter self, VectorUInt32 idx)



        AddSeed - Add a seed to the end of the list


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_AddSeed(self, idx)


    def GetName(self):
        """
        GetName(VectorConfidenceConnectedImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VectorConfidenceConnectedImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(VectorConfidenceConnectedImageFilter self, Image image1) -> Image
        Execute(VectorConfidenceConnectedImageFilter self, Image image1, VectorUIntList seedList, unsigned int numberOfIterations, double multiplier, unsigned int initialNeighborhoodRadius, uint8_t replaceValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.VectorConfidenceConnectedImageFilter_Execute(self, *args)

VectorConfidenceConnectedImageFilter_swigregister = _SimpleITK.VectorConfidenceConnectedImageFilter_swigregister
VectorConfidenceConnectedImageFilter_swigregister(VectorConfidenceConnectedImageFilter)


def VectorConfidenceConnected(image1, seedList, numberOfIterations=4, multiplier=4.5, initialNeighborhoodRadius=1, replaceValue=1):
    """
    VectorConfidenceConnected(Image image1, VectorUIntList seedList, unsigned int numberOfIterations=4, double multiplier=4.5, unsigned int initialNeighborhoodRadius=1, uint8_t replaceValue=1) -> Image



    itk::simple::VectorConfidenceConnectedImageFilter Functional Interface

    This function directly calls the execute method of VectorConfidenceConnectedImageFilter in order to support a fully functional API


    """
    return _SimpleITK.VectorConfidenceConnected(image1, seedList, numberOfIterations, multiplier, initialNeighborhoodRadius, replaceValue)
class VectorConnectedComponentImageFilter(ImageFilter_1):
    """


    A connected components filter that labels the objects in a vector
    image. Two vectors are pointing similar directions if one minus their
    dot product is less than a threshold. Vectors that are 180 degrees out
    of phase are similar. Assumes that vectors are normalized.



    See:
     itk::simple::VectorConnectedComponent for the procedural interface

     itk::VectorConnectedComponentImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVectorConnectedComponentImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorConnectedComponentImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorConnectedComponentImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VectorConnectedComponentImageFilter self) -> VectorConnectedComponentImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VectorConnectedComponentImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VectorConnectedComponentImageFilter
    __del__ = lambda self: None

    def SetDistanceThreshold(self, DistanceThreshold):
        """
        SetDistanceThreshold(VectorConnectedComponentImageFilter self, double DistanceThreshold)



        """
        return _SimpleITK.VectorConnectedComponentImageFilter_SetDistanceThreshold(self, DistanceThreshold)


    def GetDistanceThreshold(self):
        """
        GetDistanceThreshold(VectorConnectedComponentImageFilter self) -> double



        """
        return _SimpleITK.VectorConnectedComponentImageFilter_GetDistanceThreshold(self)


    def SetFullyConnected(self, FullyConnected):
        """
        SetFullyConnected(VectorConnectedComponentImageFilter self, bool FullyConnected)



        """
        return _SimpleITK.VectorConnectedComponentImageFilter_SetFullyConnected(self, FullyConnected)


    def FullyConnectedOn(self):
        """
        FullyConnectedOn(VectorConnectedComponentImageFilter self)



        Set the value of FullyConnected to true or false respectfully.


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_FullyConnectedOn(self)


    def FullyConnectedOff(self):
        """
        FullyConnectedOff(VectorConnectedComponentImageFilter self)



        """
        return _SimpleITK.VectorConnectedComponentImageFilter_FullyConnectedOff(self)


    def GetFullyConnected(self):
        """
        GetFullyConnected(VectorConnectedComponentImageFilter self) -> bool



        """
        return _SimpleITK.VectorConnectedComponentImageFilter_GetFullyConnected(self)


    def GetName(self):
        """
        GetName(VectorConnectedComponentImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VectorConnectedComponentImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VectorConnectedComponentImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(VectorConnectedComponentImageFilter self, Image image1) -> Image
        Execute(VectorConnectedComponentImageFilter self, Image image1, double distanceThreshold, bool fullyConnected) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.VectorConnectedComponentImageFilter_Execute(self, *args)

VectorConnectedComponentImageFilter_swigregister = _SimpleITK.VectorConnectedComponentImageFilter_swigregister
VectorConnectedComponentImageFilter_swigregister(VectorConnectedComponentImageFilter)


def VectorConnectedComponent(image1, distanceThreshold=1.0, fullyConnected=False):
    """
    VectorConnectedComponent(Image image1, double distanceThreshold=1.0, bool fullyConnected=False) -> Image



    A connected components filter that labels the objects in a vector
    image. Two vectors are pointing similar directions if one minus their
    dot product is less than a threshold. Vectors that are 180 degrees out
    of phase are similar. Assumes that vectors are normalized.


    This function directly calls the execute method of VectorConnectedComponentImageFilter in order to support a procedural API


    See:
     itk::simple::VectorConnectedComponentImageFilter for the object oriented interface



    """
    return _SimpleITK.VectorConnectedComponent(image1, distanceThreshold, fullyConnected)
class VectorIndexSelectionCastImageFilter(ImageFilter_1):
    """


    Extracts the selected index of the vector that is the input pixel
    type.


    This filter is templated over the input image type and output image
    type.

    The filter expect the input image pixel type to be a vector and the
    output image pixel type to be a scalar. The only requirement on the
    type used for representing the vector is that it must provide an
    operator[].


    See:
     ComposeImageFilter
    Wiki Examples:

    All Examples

    Extract a component/channel of a vector image
    See:
     itk::simple::VectorIndexSelectionCast for the procedural interface

     itk::VectorIndexSelectionCastImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkVectorIndexSelectionCastImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorIndexSelectionCastImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorIndexSelectionCastImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VectorIndexSelectionCastImageFilter self) -> VectorIndexSelectionCastImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VectorIndexSelectionCastImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VectorIndexSelectionCastImageFilter
    __del__ = lambda self: None

    def SetIndex(self, Index):
        """
        SetIndex(VectorIndexSelectionCastImageFilter self, unsigned int Index)



        Get/Set methods for the index


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_SetIndex(self, Index)


    def GetIndex(self):
        """
        GetIndex(VectorIndexSelectionCastImageFilter self) -> unsigned int



        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_GetIndex(self)


    def SetOutputPixelType(self, OutputPixelType):
        """
        SetOutputPixelType(VectorIndexSelectionCastImageFilter self, itk::simple::PixelIDValueEnum OutputPixelType)



        Set the output pixel type of the scalar component to extract.


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_SetOutputPixelType(self, OutputPixelType)


    def GetOutputPixelType(self):
        """
        GetOutputPixelType(VectorIndexSelectionCastImageFilter self) -> itk::simple::PixelIDValueEnum



        Get the ouput pixel type.


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_GetOutputPixelType(self)


    def GetName(self):
        """
        GetName(VectorIndexSelectionCastImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VectorIndexSelectionCastImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(VectorIndexSelectionCastImageFilter self, Image image1) -> Image
        Execute(VectorIndexSelectionCastImageFilter self, Image image1, unsigned int index, itk::simple::PixelIDValueEnum outputPixelType) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.VectorIndexSelectionCastImageFilter_Execute(self, *args)

VectorIndexSelectionCastImageFilter_swigregister = _SimpleITK.VectorIndexSelectionCastImageFilter_swigregister
VectorIndexSelectionCastImageFilter_swigregister(VectorIndexSelectionCastImageFilter)


def VectorIndexSelectionCast(*args, **kwargs):
    """
    VectorIndexSelectionCast(Image image1, unsigned int index=0, itk::simple::PixelIDValueEnum outputPixelType) -> Image



    Extracts the selected index of the vector that is the input pixel
    type.


    This function directly calls the execute method of VectorIndexSelectionCastImageFilter in order to support a procedural API


    See:
     itk::simple::VectorIndexSelectionCastImageFilter for the object oriented interface



    """
    return _SimpleITK.VectorIndexSelectionCast(*args, **kwargs)
class VectorMagnitudeImageFilter(ImageFilter_1):
    """


    Take an image of vectors as input and produce an image with the
    magnitude of those vectors.


    The filter expects the input image pixel type to be a vector and the
    output image pixel type to be a scalar.

    This filter assumes that the PixelType of the input image is a
    VectorType that provides a GetNorm() method.

    Wiki Examples:

    All Examples

    Compute the magnitude of each pixel in a vector image to produce a
    magnitude image
    See:
     itk::simple::VectorMagnitude for the procedural interface

     itk::VectorMagnitudeImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkVectorMagnitudeImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorMagnitudeImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorMagnitudeImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VectorMagnitudeImageFilter self) -> VectorMagnitudeImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VectorMagnitudeImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VectorMagnitudeImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(VectorMagnitudeImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VectorMagnitudeImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VectorMagnitudeImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VectorMagnitudeImageFilter___str__(self)


    def Execute(self, image1):
        """
        Execute(VectorMagnitudeImageFilter self, Image image1) -> Image



        Execute the filter on the input image


        """
        return _SimpleITK.VectorMagnitudeImageFilter_Execute(self, image1)

VectorMagnitudeImageFilter_swigregister = _SimpleITK.VectorMagnitudeImageFilter_swigregister
VectorMagnitudeImageFilter_swigregister(VectorMagnitudeImageFilter)


def VectorMagnitude(image1):
    """
    VectorMagnitude(Image image1) -> Image



    Take an image of vectors as input and produce an image with the
    magnitude of those vectors.


    This function directly calls the execute method of VectorMagnitudeImageFilter in order to support a procedural API


    See:
     itk::simple::VectorMagnitudeImageFilter for the object oriented interface



    """
    return _SimpleITK.VectorMagnitude(image1)
class VotingBinaryHoleFillingImageFilter(ImageFilter_1):
    """


    Fills in holes and cavities by applying a voting operation on each
    pixel.



    See:
     Image

     VotingBinaryImageFilter

     VotingBinaryIterativeHoleFillingImageFilter

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::VotingBinaryHoleFilling for the procedural interface

     itk::VotingBinaryHoleFillingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVotingBinaryHoleFillingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VotingBinaryHoleFillingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VotingBinaryHoleFillingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VotingBinaryHoleFillingImageFilter self) -> VotingBinaryHoleFillingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VotingBinaryHoleFillingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VotingBinaryHoleFillingImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(VotingBinaryHoleFillingImageFilter self, VectorUInt32 Radius)
        SetRadius(VotingBinaryHoleFillingImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(VotingBinaryHoleFillingImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetRadius(self)


    def SetMajorityThreshold(self, MajorityThreshold):
        """
        SetMajorityThreshold(VotingBinaryHoleFillingImageFilter self, unsigned int MajorityThreshold)



        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set upd a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_SetMajorityThreshold(self, MajorityThreshold)


    def GetMajorityThreshold(self):
        """
        GetMajorityThreshold(VotingBinaryHoleFillingImageFilter self) -> unsigned int



        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set upd a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetMajorityThreshold(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(VotingBinaryHoleFillingImageFilter self, double ForegroundValue)



        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(VotingBinaryHoleFillingImageFilter self) -> double



        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(VotingBinaryHoleFillingImageFilter self, double BackgroundValue)



        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(VotingBinaryHoleFillingImageFilter self) -> double



        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(VotingBinaryHoleFillingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VotingBinaryHoleFillingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(VotingBinaryHoleFillingImageFilter self, Image image1) -> Image
        Execute(VotingBinaryHoleFillingImageFilter self, Image image1, VectorUInt32 radius, unsigned int majorityThreshold, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.VotingBinaryHoleFillingImageFilter_Execute(self, *args)

VotingBinaryHoleFillingImageFilter_swigregister = _SimpleITK.VotingBinaryHoleFillingImageFilter_swigregister
VotingBinaryHoleFillingImageFilter_swigregister(VotingBinaryHoleFillingImageFilter)


def VotingBinaryHoleFilling(*args, **kwargs):
    """
    VotingBinaryHoleFilling(Image image1, VectorUInt32 radius, unsigned int majorityThreshold=1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image



    Fills in holes and cavities by applying a voting operation on each
    pixel.


    This function directly calls the execute method of VotingBinaryHoleFillingImageFilter in order to support a procedural API


    See:
     itk::simple::VotingBinaryHoleFillingImageFilter for the object oriented interface



    """
    return _SimpleITK.VotingBinaryHoleFilling(*args, **kwargs)
class VotingBinaryImageFilter(ImageFilter_1):
    """


    Applies a voting operation in a neighborhood of each pixel.



    Pixels which are not Foreground or Background will remain unchanged.

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::VotingBinary for the procedural interface

     itk::VotingBinaryImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVotingBinaryImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VotingBinaryImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VotingBinaryImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VotingBinaryImageFilter self) -> VotingBinaryImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VotingBinaryImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VotingBinaryImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(VotingBinaryImageFilter self, VectorUInt32 Radius)
        SetRadius(VotingBinaryImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.VotingBinaryImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(VotingBinaryImageFilter self) -> VectorUInt32



        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.VotingBinaryImageFilter_GetRadius(self)


    def SetBirthThreshold(self, BirthThreshold):
        """
        SetBirthThreshold(VotingBinaryImageFilter self, unsigned int BirthThreshold)



        Birth threshold. Pixels that are OFF will turn ON when the number of
        neighbors ON is larger than the value defined in this threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_SetBirthThreshold(self, BirthThreshold)


    def GetBirthThreshold(self):
        """
        GetBirthThreshold(VotingBinaryImageFilter self) -> unsigned int



        Birth threshold. Pixels that are OFF will turn ON when the number of
        neighbors ON is larger than the value defined in this threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_GetBirthThreshold(self)


    def SetSurvivalThreshold(self, SurvivalThreshold):
        """
        SetSurvivalThreshold(VotingBinaryImageFilter self, unsigned int SurvivalThreshold)



        Survival threshold. Pixels that are ON will turn OFF when the number
        of neighbors ON is smaller than the value defined in this survival
        threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_SetSurvivalThreshold(self, SurvivalThreshold)


    def GetSurvivalThreshold(self):
        """
        GetSurvivalThreshold(VotingBinaryImageFilter self) -> unsigned int



        Survival threshold. Pixels that are ON will turn OFF when the number
        of neighbors ON is smaller than the value defined in this survival
        threshold.


        """
        return _SimpleITK.VotingBinaryImageFilter_GetSurvivalThreshold(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(VotingBinaryImageFilter self, double ForegroundValue)



        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(VotingBinaryImageFilter self) -> double



        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(VotingBinaryImageFilter self, double BackgroundValue)



        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(VotingBinaryImageFilter self) -> double



        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(VotingBinaryImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VotingBinaryImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VotingBinaryImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VotingBinaryImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(VotingBinaryImageFilter self, Image image1) -> Image
        Execute(VotingBinaryImageFilter self, Image image1, VectorUInt32 radius, unsigned int birthThreshold, unsigned int survivalThreshold, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.VotingBinaryImageFilter_Execute(self, *args)

VotingBinaryImageFilter_swigregister = _SimpleITK.VotingBinaryImageFilter_swigregister
VotingBinaryImageFilter_swigregister(VotingBinaryImageFilter)


def VotingBinary(*args, **kwargs):
    """
    VotingBinary(Image image1, VectorUInt32 radius, unsigned int birthThreshold=1, unsigned int survivalThreshold=1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image



    Applies a voting operation in a neighborhood of each pixel.


    This function directly calls the execute method of VotingBinaryImageFilter in order to support a procedural API


    See:
     itk::simple::VotingBinaryImageFilter for the object oriented interface



    """
    return _SimpleITK.VotingBinary(*args, **kwargs)
class VotingBinaryIterativeHoleFillingImageFilter(ImageFilter_1):
    """


    Fills in holes and cavities by iteratively applying a voting
    operation.


    This filter uses internally the VotingBinaryHoleFillingImageFilter , and runs it iteratively until no pixels are being changed or until
    it reaches the maximum number of iterations. The purpose of the filter
    is to fill in holes of medium size (tens of pixels in radius). In
    principle the number of iterations is related to the size of the holes
    to be filled in. The larger the holes, the more iteration must be run
    with this filter in order to fill in the full hole. The size of the
    neighborhood is also related to the curvature of the hole borders and
    therefore the hole size. Note that as a collateral effect this filter
    may also fill in cavities in the external side of structures.

    This filter is templated over a single image type because the output
    image type must be the same as the input image type. This is required
    in order to make the iterations possible, since the output image of
    one iteration is taken as the input image for the next iteration.


    See:
     Image

     VotingBinaryImageFilter

     VotingBinaryHoleFillingImageFilter

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator

     itk::simple::VotingBinaryIterativeHoleFilling for the procedural interface

     itk::VotingBinaryIterativeHoleFillingImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkVotingBinaryIterativeHoleFillingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VotingBinaryIterativeHoleFillingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VotingBinaryIterativeHoleFillingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::VotingBinaryIterativeHoleFillingImageFilter self) -> VotingBinaryIterativeHoleFillingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_VotingBinaryIterativeHoleFillingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_VotingBinaryIterativeHoleFillingImageFilter
    __del__ = lambda self: None

    def SetRadius(self, *args):
        """
        SetRadius(VotingBinaryIterativeHoleFillingImageFilter self, VectorUInt32 Radius)
        SetRadius(VotingBinaryIterativeHoleFillingImageFilter self, unsigned int value)



        Set the values of the Radius vector all to value


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetRadius(self, *args)


    def GetRadius(self):
        """
        GetRadius(VotingBinaryIterativeHoleFillingImageFilter self) -> VectorUInt32



        Get the radius of the neighborhood used to compute the median


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetRadius(self)


    def SetMaximumNumberOfIterations(self, MaximumNumberOfIterations):
        """
        SetMaximumNumberOfIterations(VotingBinaryIterativeHoleFillingImageFilter self, unsigned int MaximumNumberOfIterations)



        Maximum number of iterations. This filter is executed iteratively as
        long as at least one pixel has changed in a previous iteration, or
        until the maximum number of iterations has been reached.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetMaximumNumberOfIterations(self, MaximumNumberOfIterations)


    def GetMaximumNumberOfIterations(self):
        """
        GetMaximumNumberOfIterations(VotingBinaryIterativeHoleFillingImageFilter self) -> unsigned int



        Maximum number of iterations. This filter is executed iteratively as
        long as at least one pixel has changed in a previous iteration, or
        until the maximum number of iterations has been reached.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetMaximumNumberOfIterations(self)


    def SetMajorityThreshold(self, MajorityThreshold):
        """
        SetMajorityThreshold(VotingBinaryIterativeHoleFillingImageFilter self, unsigned int MajorityThreshold)



        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set upd a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetMajorityThreshold(self, MajorityThreshold)


    def GetMajorityThreshold(self):
        """
        GetMajorityThreshold(VotingBinaryIterativeHoleFillingImageFilter self) -> unsigned int



        Majority threshold. It is the number of pixels over 50% that will
        decide whether an OFF pixel will become ON or not. For example, if the
        neighborhood of a pixel has 124 pixels (excluding itself), the 50%
        will be 62, and if you set upd a Majority threshold of 5, that means
        that the filter will require 67 or more neighbor pixels to be ON in
        order to switch the current OFF pixel to ON. The default value is 1.


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetMajorityThreshold(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(VotingBinaryIterativeHoleFillingImageFilter self, double ForegroundValue)



        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(VotingBinaryIterativeHoleFillingImageFilter self) -> double



        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(VotingBinaryIterativeHoleFillingImageFilter self, double BackgroundValue)



        Set the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(VotingBinaryIterativeHoleFillingImageFilter self) -> double



        Get the value associated with the Foreground (or the object) on the
        binary input image and the Background .


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(VotingBinaryIterativeHoleFillingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(VotingBinaryIterativeHoleFillingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(VotingBinaryIterativeHoleFillingImageFilter self, Image image1) -> Image
        Execute(VotingBinaryIterativeHoleFillingImageFilter self, Image image1, VectorUInt32 radius, unsigned int maximumNumberOfIterations, unsigned int majorityThreshold, double foregroundValue, double backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_Execute(self, *args)

VotingBinaryIterativeHoleFillingImageFilter_swigregister = _SimpleITK.VotingBinaryIterativeHoleFillingImageFilter_swigregister
VotingBinaryIterativeHoleFillingImageFilter_swigregister(VotingBinaryIterativeHoleFillingImageFilter)


def VotingBinaryIterativeHoleFilling(*args, **kwargs):
    """
    VotingBinaryIterativeHoleFilling(Image image1, VectorUInt32 radius, unsigned int maximumNumberOfIterations=10, unsigned int majorityThreshold=1, double foregroundValue=1.0, double backgroundValue=0.0) -> Image



    Fills in holes and cavities by iteratively applying a voting
    operation.


    This function directly calls the execute method of VotingBinaryIterativeHoleFillingImageFilter in order to support a procedural API


    See:
     itk::simple::VotingBinaryIterativeHoleFillingImageFilter for the object oriented interface



    """
    return _SimpleITK.VotingBinaryIterativeHoleFilling(*args, **kwargs)
class WarpImageFilter(ImageFilter_2):
    """


    Warps an image using an input displacement field.


    WarpImageFilter warps an existing image with respect to a given displacement field.

    A displacement field is represented as a image whose pixel type is
    some vector type with at least N elements, where N is the dimension of
    the input image. The vector type must support element access via
    operator [].

    The output image is produced by inverse mapping: the output pixels are
    mapped back onto the input image. This scheme avoids the creation of
    any holes and overlaps in the output image.

    Each vector in the displacement field represent the distance between a
    geometric point in the input space and a point in the output space
    such that:

    \\[ p_{in} = p_{out} + d \\]

    Typically the mapped position does not correspond to an integer pixel
    position in the input image. Interpolation via an image function is
    used to compute values at non-integer positions. The default
    interpolation typed used is the LinearInterpolateImageFunction . The user can specify a particular interpolation function via SetInterpolator() . Note that the input interpolator must derive from base class InterpolateImageFunction .

    Position mapped to outside of the input image buffer are assigned a
    edge padding value.

    The LargetPossibleRegion for the output is inherited from the input
    displacement field. The output image spacing, origin and orientation
    may be set via SetOutputSpacing, SetOutputOrigin and
    SetOutputDirection. The default are respectively a vector of 1's, a
    vector of 0's and an identity matrix.

    This class is templated over the type of the input image, the type of
    the output image and the type of the displacement field.

    The input image is set via SetInput. The input displacement field is
    set via SetDisplacementField.

    This filter is implemented as a multithreaded filter.


    WARNING:
    This filter assumes that the input type, output type and displacement
    field type all have the same number of dimensions.
    Wiki Examples:

    All Examples

    Warp one image to another using manually specified landmarks
    See:
     itk::simple::Warp for the procedural interface

     itk::WarpImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkWarpImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WarpImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WarpImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::WarpImageFilter self) -> WarpImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_WarpImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_WarpImageFilter
    __del__ = lambda self: None

    def SetInterpolator(self, Interpolator):
        """
        SetInterpolator(WarpImageFilter self, itk::simple::InterpolatorEnum Interpolator)



        Get/Set the interpolator function.


        """
        return _SimpleITK.WarpImageFilter_SetInterpolator(self, Interpolator)


    def GetInterpolator(self):
        """
        GetInterpolator(WarpImageFilter self) -> itk::simple::InterpolatorEnum



        Get/Set the interpolator function.


        """
        return _SimpleITK.WarpImageFilter_GetInterpolator(self)


    def SetOutputSize(self, OutputSize):
        """
        SetOutputSize(WarpImageFilter self, VectorUInt32 OutputSize)



        Set the size of the output image.


        """
        return _SimpleITK.WarpImageFilter_SetOutputSize(self, OutputSize)


    def GetOutputSize(self):
        """
        GetOutputSize(WarpImageFilter self) -> VectorUInt32



        Get the size of the output image.


        """
        return _SimpleITK.WarpImageFilter_GetOutputSize(self)


    def SetOutputOrigin(self, OutputOrigin):
        """
        SetOutputOrigin(WarpImageFilter self, VectorDouble OutputOrigin)



        Set the output image origin.


        """
        return _SimpleITK.WarpImageFilter_SetOutputOrigin(self, OutputOrigin)


    def GetOutputOrigin(self):
        """
        GetOutputOrigin(WarpImageFilter self) -> VectorDouble



        Get the output image origin.


        """
        return _SimpleITK.WarpImageFilter_GetOutputOrigin(self)


    def SetOutputSpacing(self, OutputSpacing):
        """
        SetOutputSpacing(WarpImageFilter self, VectorDouble OutputSpacing)



        Set the output image spacing.


        """
        return _SimpleITK.WarpImageFilter_SetOutputSpacing(self, OutputSpacing)


    def GetOutputSpacing(self):
        """
        GetOutputSpacing(WarpImageFilter self) -> VectorDouble



        Get the output image spacing.


        """
        return _SimpleITK.WarpImageFilter_GetOutputSpacing(self)


    def SetOutputDirection(self, OutputDirection):
        """
        SetOutputDirection(WarpImageFilter self, VectorDouble OutputDirection)



        Set/Get the direction (orientation) of the output image


        """
        return _SimpleITK.WarpImageFilter_SetOutputDirection(self, OutputDirection)


    def GetOutputDirection(self):
        """
        GetOutputDirection(WarpImageFilter self) -> VectorDouble



        Set/Get the direction (orientation) of the output image


        """
        return _SimpleITK.WarpImageFilter_GetOutputDirection(self)


    def SetEdgePaddingValue(self, EdgePaddingValue):
        """
        SetEdgePaddingValue(WarpImageFilter self, double EdgePaddingValue)



        Set the edge padding value


        """
        return _SimpleITK.WarpImageFilter_SetEdgePaddingValue(self, EdgePaddingValue)


    def GetEdgePaddingValue(self):
        """
        GetEdgePaddingValue(WarpImageFilter self) -> double



        Get the edge padding value


        """
        return _SimpleITK.WarpImageFilter_GetEdgePaddingValue(self)


    def GetName(self):
        """
        GetName(WarpImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.WarpImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(WarpImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.WarpImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(WarpImageFilter self, Image image1, Image image2) -> Image
        Execute(WarpImageFilter self, Image image1, Image image2, itk::simple::InterpolatorEnum interpolator, VectorUInt32 outputSize, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double edgePaddingValue) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.WarpImageFilter_Execute(self, *args)


    def SetOutputParameteresFromImage(self, refImage):
        """
        SetOutputParameteresFromImage(WarpImageFilter self, Image refImage)



        This methods sets the output size, origin, spacing and direction to
        that of the provided image


        """
        return _SimpleITK.WarpImageFilter_SetOutputParameteresFromImage(self, refImage)

WarpImageFilter_swigregister = _SimpleITK.WarpImageFilter_swigregister
WarpImageFilter_swigregister(WarpImageFilter)


def Warp(*args, **kwargs):
    """
    Warp(Image image1, Image image2, itk::simple::InterpolatorEnum interpolator, VectorUInt32 outputSize, VectorDouble outputOrigin, VectorDouble outputSpacing, VectorDouble outputDirection, double edgePaddingValue=0.0) -> Image



    Warps an image using an input displacement field.


    This function directly calls the execute method of WarpImageFilter in order to support a procedural API


    See:
     itk::simple::WarpImageFilter for the object oriented interface



    """
    return _SimpleITK.Warp(*args, **kwargs)
class WhiteTopHatImageFilter(ImageFilter_1):
    """


    White top hat extract local maxima that are larger than the
    structuring element.


    Top-hats are described in Chapter 4.5 of Pierre Soille's book
    "Morphological Image Analysis: Principles and Applications", Second
    Edition, Springer, 2003.


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     itk::simple::WhiteTopHat for the procedural interface

     itk::WhiteTopHatImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkWhiteTopHatImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WhiteTopHatImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WhiteTopHatImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::WhiteTopHatImageFilter self) -> WhiteTopHatImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_WhiteTopHatImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_WhiteTopHatImageFilter
    __del__ = lambda self: None
    Annulus = _SimpleITK.WhiteTopHatImageFilter_Annulus
    Ball = _SimpleITK.WhiteTopHatImageFilter_Ball
    Box = _SimpleITK.WhiteTopHatImageFilter_Box
    Cross = _SimpleITK.WhiteTopHatImageFilter_Cross

    def SetSafeBorder(self, SafeBorder):
        """
        SetSafeBorder(WhiteTopHatImageFilter self, bool SafeBorder)



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.WhiteTopHatImageFilter_SetSafeBorder(self, SafeBorder)


    def SafeBorderOn(self):
        """
        SafeBorderOn(WhiteTopHatImageFilter self)



        Set the value of SafeBorder to true or false respectfully.


        """
        return _SimpleITK.WhiteTopHatImageFilter_SafeBorderOn(self)


    def SafeBorderOff(self):
        """
        SafeBorderOff(WhiteTopHatImageFilter self)



        """
        return _SimpleITK.WhiteTopHatImageFilter_SafeBorderOff(self)


    def GetSafeBorder(self):
        """
        GetSafeBorder(WhiteTopHatImageFilter self) -> bool



        A safe border is added to input image to avoid borders effects and
        remove it once the closing is done


        """
        return _SimpleITK.WhiteTopHatImageFilter_GetSafeBorder(self)


    def SetKernelRadius(self, *args):
        """
        SetKernelRadius(WhiteTopHatImageFilter self, uint32_t r)
        SetKernelRadius(WhiteTopHatImageFilter self, VectorUInt32 r)



        Set/Get the radius of the kernel structuring element as a vector.

        If the dimension of the image is greater then the length of r, then
        the radius will be padded. If it is less the r will be truncated.


        """
        return _SimpleITK.WhiteTopHatImageFilter_SetKernelRadius(self, *args)


    def GetKernelRadius(self):
        """
        GetKernelRadius(WhiteTopHatImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.WhiteTopHatImageFilter_GetKernelRadius(self)


    def SetKernelType(self, t):
        """
        SetKernelType(WhiteTopHatImageFilter self, itk::simple::KernelEnum t)



        """
        return _SimpleITK.WhiteTopHatImageFilter_SetKernelType(self, t)


    def GetKernelType(self):
        """
        GetKernelType(WhiteTopHatImageFilter self) -> itk::simple::KernelEnum



        """
        return _SimpleITK.WhiteTopHatImageFilter_GetKernelType(self)


    def GetName(self):
        """
        GetName(WhiteTopHatImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.WhiteTopHatImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(WhiteTopHatImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.WhiteTopHatImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(WhiteTopHatImageFilter self, Image image1) -> Image
        Execute(WhiteTopHatImageFilter self, Image image1, bool safeBorder) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.WhiteTopHatImageFilter_Execute(self, *args)

WhiteTopHatImageFilter_swigregister = _SimpleITK.WhiteTopHatImageFilter_swigregister
WhiteTopHatImageFilter_swigregister(WhiteTopHatImageFilter)


def WhiteTopHat(*args):
    """
    WhiteTopHat(Image arg1, uint32_t radius=1, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image
    WhiteTopHat(Image arg1, VectorUInt32 vectorRadius, itk::simple::KernelEnum kernel, bool safeBorder=True) -> Image



    itk::simple::WhiteTopHatImageFilter Functional Interface

    This function directly calls the execute method of WhiteTopHatImageFilter in order to support a fully functional API


    """
    return _SimpleITK.WhiteTopHat(*args)
class WienerDeconvolutionImageFilter(ImageFilter_2):
    """


    The Wiener deconvolution image filter is designed to restore an image
    convolved with a blurring kernel while keeping noise enhancement to a
    minimum.


    The Wiener filter aims to minimize noise enhancement induced by
    frequencies with low signal-to-noise ratio. The Wiener filter kernel
    is defined in the frequency domain as $W(\\omega) = H^*(\\omega) / (|H(\\omega)|^2 + (1 /
    SNR(\\omega)))$ where $H(\\omega)$ is the Fourier transform of the blurring kernel with which the
    original image was convolved and the signal-to-noise ratio $SNR(\\omega)$ . $SNR(\\omega)$ is defined by $P_f(\\omega) / P_n(\\omega)$ where $P_f(\\omega)$ is the power spectral density of the uncorrupted signal and $P_n(\\omega)$ is the power spectral density of the noise. When applied to the input
    blurred image, this filter produces an estimate $\\hat{f}(x)$ of the true underlying signal $f(x)$ that minimizes the expected error between $\\hat{f}(x)$ and $f(x)$ .

    This filter requires two inputs, the image to be deconvolved and the
    blurring kernel. These two inputs can be set using the methods
    SetInput() and SetKernelImage() , respectively.

    The power spectral densities of the signal and noise are typically
    unavailable for a given problem. In particular, $P_f(\\omega)$ cannot be computed from $f(x)$ because this unknown signal is precisely the signal that this filter
    aims to recover. Nevertheless, it is common for the noise to have a
    power spectral density that is flat or decreasing significantly more
    slowly than the power spectral density of a typical image as the
    frequency $\\omega$ increases. Hence, $P_n(\\omega)$ can typically be approximated with a constant, and this filter makes
    this assumption (see the NoiseVariance member variable). $P_f(\\omega)$ , on the other hand, will vary with input. This filter computes the
    power spectral density of the input blurred image, subtracts the power
    spectral density of the noise, and uses the result as the estimate of $P_f(\\omega)$ .

    For further information on the Wiener deconvolution filter, please see
    "Digital Signal Processing" by Kenneth R. Castleman, Prentice Hall,
    1995


    Gaetan Lehmann, Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France
     Chris Mullins, The University of North Carolina at Chapel Hill

    Cory Quammen, The University of North Carolina at Chapel Hill
    See:
     itk::simple::WienerDeconvolution for the procedural interface

     itk::WienerDeconvolutionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkWienerDeconvolutionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WienerDeconvolutionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WienerDeconvolutionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::WienerDeconvolutionImageFilter self) -> WienerDeconvolutionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_WienerDeconvolutionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_WienerDeconvolutionImageFilter
    __del__ = lambda self: None

    def SetNoiseVariance(self, NoiseVariance):
        """
        SetNoiseVariance(WienerDeconvolutionImageFilter self, double NoiseVariance)



        Set/get the variance of the zero-mean Gaussian white noise assumed to
        be added to the input.


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetNoiseVariance(self, NoiseVariance)


    def GetNoiseVariance(self):
        """
        GetNoiseVariance(WienerDeconvolutionImageFilter self) -> double



        Set/get the variance of the zero-mean Gaussian white noise assumed to
        be added to the input.


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetNoiseVariance(self)


    def SetNormalize(self, Normalize):
        """
        SetNormalize(WienerDeconvolutionImageFilter self, bool Normalize)



        Normalize the output image by the sum of the kernel components


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetNormalize(self, Normalize)


    def NormalizeOn(self):
        """
        NormalizeOn(WienerDeconvolutionImageFilter self)



        Set the value of Normalize to true or false respectfully.


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_NormalizeOn(self)


    def NormalizeOff(self):
        """
        NormalizeOff(WienerDeconvolutionImageFilter self)



        """
        return _SimpleITK.WienerDeconvolutionImageFilter_NormalizeOff(self)


    def GetNormalize(self):
        """
        GetNormalize(WienerDeconvolutionImageFilter self) -> bool



        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetNormalize(self)

    ZERO_PAD = _SimpleITK.WienerDeconvolutionImageFilter_ZERO_PAD
    ZERO_FLUX_NEUMANN_PAD = _SimpleITK.WienerDeconvolutionImageFilter_ZERO_FLUX_NEUMANN_PAD
    PERIODIC_PAD = _SimpleITK.WienerDeconvolutionImageFilter_PERIODIC_PAD

    def SetBoundaryCondition(self, BoundaryCondition):
        """
        SetBoundaryCondition(WienerDeconvolutionImageFilter self, itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType BoundaryCondition)



        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetBoundaryCondition(self, BoundaryCondition)


    def GetBoundaryCondition(self):
        """
        GetBoundaryCondition(WienerDeconvolutionImageFilter self) -> itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType



        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetBoundaryCondition(self)

    SAME = _SimpleITK.WienerDeconvolutionImageFilter_SAME
    VALID = _SimpleITK.WienerDeconvolutionImageFilter_VALID

    def SetOutputRegionMode(self, OutputRegionMode):
        """
        SetOutputRegionMode(WienerDeconvolutionImageFilter self, itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType OutputRegionMode)



        """
        return _SimpleITK.WienerDeconvolutionImageFilter_SetOutputRegionMode(self, OutputRegionMode)


    def GetOutputRegionMode(self):
        """
        GetOutputRegionMode(WienerDeconvolutionImageFilter self) -> itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType



        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetOutputRegionMode(self)


    def GetName(self):
        """
        GetName(WienerDeconvolutionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(WienerDeconvolutionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.WienerDeconvolutionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(WienerDeconvolutionImageFilter self, Image image1, Image image2) -> Image
        Execute(WienerDeconvolutionImageFilter self, Image image1, Image image2, double noiseVariance, bool normalize, itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



        Execute the filter on the input images with the given parameters


        """
        return _SimpleITK.WienerDeconvolutionImageFilter_Execute(self, *args)

WienerDeconvolutionImageFilter_swigregister = _SimpleITK.WienerDeconvolutionImageFilter_swigregister
WienerDeconvolutionImageFilter_swigregister(WienerDeconvolutionImageFilter)


def WienerDeconvolution(*args, **kwargs):
    """
    WienerDeconvolution(Image image1, Image image2, double noiseVariance=0.0, bool normalize=False, itk::simple::WienerDeconvolutionImageFilter::BoundaryConditionType boundaryCondition, itk::simple::WienerDeconvolutionImageFilter::OutputRegionModeType outputRegionMode) -> Image



    The Wiener deconvolution image filter is designed to restore an image
    convolved with a blurring kernel while keeping noise enhancement to a
    minimum.


    This function directly calls the execute method of WienerDeconvolutionImageFilter in order to support a procedural API


    See:
     itk::simple::WienerDeconvolutionImageFilter for the object oriented interface



    """
    return _SimpleITK.WienerDeconvolution(*args, **kwargs)
class WrapPadImageFilter(ImageFilter_1):
    """


    Increase the image size by padding with replicants of the input image
    value.


    WrapPadImageFilter changes the image bounds of an image. Added pixels are filled in with
    a wrapped replica of the input image. For instance, if the output
    image needs a pixel that is two pixels to the left of the
    LargestPossibleRegion of the input image, the value assigned will be
    from the pixel two pixels inside the right boundary of the
    LargestPossibleRegion. The image bounds of the output must be
    specified.

    Visual explanation of padding regions. This filter is implemented as a
    multithreaded filter. It provides a ThreadedGenerateData() method for
    its implementation.


    See:
     MirrorPadImageFilter , ConstantPadImageFilter
    Wiki Examples:

    All Examples

    Pad an image by wrapping
    See:
     itk::simple::WrapPad for the procedural interface

     itk::WrapPadImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkWrapPadImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WrapPadImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WrapPadImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::WrapPadImageFilter self) -> WrapPadImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_WrapPadImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_WrapPadImageFilter
    __del__ = lambda self: None

    def SetPadLowerBound(self, PadLowerBound):
        """
        SetPadLowerBound(WrapPadImageFilter self, VectorUInt32 PadLowerBound)



        """
        return _SimpleITK.WrapPadImageFilter_SetPadLowerBound(self, PadLowerBound)


    def GetPadLowerBound(self):
        """
        GetPadLowerBound(WrapPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.WrapPadImageFilter_GetPadLowerBound(self)


    def SetPadUpperBound(self, PadUpperBound):
        """
        SetPadUpperBound(WrapPadImageFilter self, VectorUInt32 PadUpperBound)



        """
        return _SimpleITK.WrapPadImageFilter_SetPadUpperBound(self, PadUpperBound)


    def GetPadUpperBound(self):
        """
        GetPadUpperBound(WrapPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.WrapPadImageFilter_GetPadUpperBound(self)


    def GetName(self):
        """
        GetName(WrapPadImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.WrapPadImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(WrapPadImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.WrapPadImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(WrapPadImageFilter self, Image image1) -> Image
        Execute(WrapPadImageFilter self, Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.WrapPadImageFilter_Execute(self, *args)

WrapPadImageFilter_swigregister = _SimpleITK.WrapPadImageFilter_swigregister
WrapPadImageFilter_swigregister(WrapPadImageFilter)


def WrapPad(*args, **kwargs):
    """
    WrapPad(Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) -> Image



    Increase the image size by padding with replicants of the input image
    value.


    This function directly calls the execute method of WrapPadImageFilter in order to support a procedural API


    See:
     itk::simple::WrapPadImageFilter for the object oriented interface



    """
    return _SimpleITK.WrapPad(*args, **kwargs)
class XorImageFilter(ImageFilter_2):
    """


    Computes the XOR bitwise operator pixel-wise between two images.


    This class is templated over the types of the two input images and the
    type of the output image. Numeric conversions (castings) are done by
    the C++ defaults.

    Since the bitwise XOR operation is only defined in C++ for integer
    types, the images passed to this filter must comply with the
    requirement of using integer pixel type.

    The total operation over one pixel will be


    Where "^" is the boolean XOR operator in C++.

    Wiki Examples:

    All Examples

    Binary XOR (exclusive OR) two images
    See:
     itk::simple::Xor for the procedural interface

     itk::XorImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkXorImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XorImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_2]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, XorImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::XorImageFilter self) -> XorImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_XorImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_XorImageFilter
    __del__ = lambda self: None

    def GetName(self):
        """
        GetName(XorImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.XorImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(XorImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.XorImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(XorImageFilter self, Image image1, Image image2) -> Image
        Execute(XorImageFilter self, Image image1, int constant) -> Image
        Execute(XorImageFilter self, int constant, Image image2) -> Image



        """
        return _SimpleITK.XorImageFilter_Execute(self, *args)

XorImageFilter_swigregister = _SimpleITK.XorImageFilter_swigregister
XorImageFilter_swigregister(XorImageFilter)


def Xor(*args):
    """
    Xor(Image image1, Image image2) -> Image
    Xor(Image image1, int constant) -> Image
    Xor(int constant, Image image2) -> Image



    """
    return _SimpleITK.Xor(*args)
class YenThresholdImageFilter(ImageFilter_0):
    """


    Threshold an image using the Yen Threshold.


    This filter creates a binary thresholded image that separates an image
    into foreground and background components. The filter computes the
    threshold using the YenThresholdCalculator and applies that theshold to the input image using the BinaryThresholdImageFilter .


    Richard Beare
     Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    This implementation was taken from the Insight Journal paper: https://hdl.handle.net/10380/3279 or http://www.insight-journal.org/browse/publication/811


    See:
     HistogramThresholdImageFilter

     itk::simple::YenThreshold for the procedural interface

     itk::YenThresholdImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkYenThresholdImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, YenThresholdImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_0]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, YenThresholdImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::YenThresholdImageFilter self) -> YenThresholdImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_YenThresholdImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_YenThresholdImageFilter
    __del__ = lambda self: None

    def SetInsideValue(self, InsideValue):
        """
        SetInsideValue(YenThresholdImageFilter self, uint8_t InsideValue)



        Set the "inside" pixel value.


        """
        return _SimpleITK.YenThresholdImageFilter_SetInsideValue(self, InsideValue)


    def GetInsideValue(self):
        """
        GetInsideValue(YenThresholdImageFilter self) -> uint8_t



        Get the "inside" pixel value.


        """
        return _SimpleITK.YenThresholdImageFilter_GetInsideValue(self)


    def SetOutsideValue(self, OutsideValue):
        """
        SetOutsideValue(YenThresholdImageFilter self, uint8_t OutsideValue)



        Set the "outside" pixel value. The default value NumericTraits<OutputPixelType>::Zero.


        """
        return _SimpleITK.YenThresholdImageFilter_SetOutsideValue(self, OutsideValue)


    def GetOutsideValue(self):
        """
        GetOutsideValue(YenThresholdImageFilter self) -> uint8_t



        Get the "outside" pixel value.


        """
        return _SimpleITK.YenThresholdImageFilter_GetOutsideValue(self)


    def SetNumberOfHistogramBins(self, NumberOfHistogramBins):
        """
        SetNumberOfHistogramBins(YenThresholdImageFilter self, uint32_t NumberOfHistogramBins)



        Set/Get the number of histogram bins.


        """
        return _SimpleITK.YenThresholdImageFilter_SetNumberOfHistogramBins(self, NumberOfHistogramBins)


    def GetNumberOfHistogramBins(self):
        """
        GetNumberOfHistogramBins(YenThresholdImageFilter self) -> uint32_t



        """
        return _SimpleITK.YenThresholdImageFilter_GetNumberOfHistogramBins(self)


    def SetMaskOutput(self, MaskOutput):
        """
        SetMaskOutput(YenThresholdImageFilter self, bool MaskOutput)



        Do you want the output to be masked by the mask used in histogram
        construction. Only relevant if masking is in use.


        """
        return _SimpleITK.YenThresholdImageFilter_SetMaskOutput(self, MaskOutput)


    def MaskOutputOn(self):
        """
        MaskOutputOn(YenThresholdImageFilter self)



        Set the value of MaskOutput to true or false respectfully.


        """
        return _SimpleITK.YenThresholdImageFilter_MaskOutputOn(self)


    def MaskOutputOff(self):
        """
        MaskOutputOff(YenThresholdImageFilter self)



        """
        return _SimpleITK.YenThresholdImageFilter_MaskOutputOff(self)


    def GetMaskOutput(self):
        """
        GetMaskOutput(YenThresholdImageFilter self) -> bool



        """
        return _SimpleITK.YenThresholdImageFilter_GetMaskOutput(self)


    def SetMaskValue(self, MaskValue):
        """
        SetMaskValue(YenThresholdImageFilter self, uint8_t MaskValue)



        The value in the mask image, if used, indicating voxels that should be
        included. Default is the max of pixel type, as in the
        MaskedImageToHistogramFilter


        """
        return _SimpleITK.YenThresholdImageFilter_SetMaskValue(self, MaskValue)


    def GetMaskValue(self):
        """
        GetMaskValue(YenThresholdImageFilter self) -> uint8_t



        """
        return _SimpleITK.YenThresholdImageFilter_GetMaskValue(self)


    def GetThreshold(self):
        """
        GetThreshold(YenThresholdImageFilter self) -> double



        Get the computed threshold.


        This is a measurement. Its value is updated in the Execute methods, so
        the value will only be valid after an execution.


        """
        return _SimpleITK.YenThresholdImageFilter_GetThreshold(self)


    def GetName(self):
        """
        GetName(YenThresholdImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.YenThresholdImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(YenThresholdImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.YenThresholdImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(YenThresholdImageFilter self, Image image, Image maskImage) -> Image
        Execute(YenThresholdImageFilter self, Image image) -> Image
        Execute(YenThresholdImageFilter self, Image image, Image maskImage, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image
        Execute(YenThresholdImageFilter self, Image image, uint8_t insideValue, uint8_t outsideValue, uint32_t numberOfHistogramBins, bool maskOutput, uint8_t maskValue) -> Image



        """
        return _SimpleITK.YenThresholdImageFilter_Execute(self, *args)

YenThresholdImageFilter_swigregister = _SimpleITK.YenThresholdImageFilter_swigregister
YenThresholdImageFilter_swigregister(YenThresholdImageFilter)


def YenThreshold(*args):
    """
    YenThreshold(Image image, Image maskImage, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image
    YenThreshold(Image image, uint8_t insideValue=1, uint8_t outsideValue=0, uint32_t numberOfHistogramBins=256, bool maskOutput=True, uint8_t maskValue=255) -> Image



    """
    return _SimpleITK.YenThreshold(*args)
class ZeroCrossingBasedEdgeDetectionImageFilter(ImageFilter_1):
    """


    This filter implements a zero-crossing based edge detecor.


    The zero-crossing based edge detector looks for pixels in the
    Laplacian of an image where the value of the Laplacian passes through
    zero points where the Laplacian changes sign. Such points often occur
    at "edges" in images i.e. points where the intensity of the image
    changes rapidly, but they also occur at places that are not as easy to
    associate with edges. It is best to think of the zero crossing
    detector as some sort of feature detector rather than as a specific
    edge detector.


    Zero crossings always lie on closed contours and so the output from
    the zero crossing detector is usually a binary image with single pixel
    thickness lines showing the positions of the zero crossing points.

    In this implementation, the input image is first smoothed with a
    Gaussian filter, then the LaplacianImageFilter is applied to smoothed image. Finally the zero-crossing of the
    Laplacian of the smoothed image is detected. The output is a binary
    image.
    Inputs and Outputs
    The input to the filter should be a scalar, itk::Image of arbitrary dimension. The output image is a binary, labeled image.
    See itkZeroCrossingImageFilter for more information on requirements of
    the data type of the output.

    To use this filter, first set the parameters (variance and maximum
    error) needed by the embedded DiscreteGaussianImageFilter , i.e. See DiscreteGaussianImageFilter for information about these parameters. Optionally, you may also set
    foreground and background values for the zero-crossing filter. The
    default label values are Zero for the background and One for the
    foreground, as defined in NumericTraits for the data type of the output image.

    See:
     DiscreteGaussianImageFilter

     LaplacianImageFilter

     ZeroCrossingImageFilter

     itk::simple::ZeroCrossingBasedEdgeDetection for the procedural interface

     itk::ZeroCrossingBasedEdgeDetectionImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkZeroCrossingBasedEdgeDetectionImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZeroCrossingBasedEdgeDetectionImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZeroCrossingBasedEdgeDetectionImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ZeroCrossingBasedEdgeDetectionImageFilter self) -> ZeroCrossingBasedEdgeDetectionImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ZeroCrossingBasedEdgeDetectionImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ZeroCrossingBasedEdgeDetectionImageFilter
    __del__ = lambda self: None

    def SetVariance(self, Variance):
        """
        SetVariance(ZeroCrossingBasedEdgeDetectionImageFilter self, double Variance)



        Set the variance parameter needed by the embedded gaussian filter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetVariance(self, Variance)


    def GetVariance(self):
        """
        GetVariance(ZeroCrossingBasedEdgeDetectionImageFilter self) -> double



        Standard get/set macros for Gaussian filter parameters.


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetVariance(self)


    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self, uint8_t ForegroundValue)



        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self) -> uint8_t



        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self, uint8_t BackgroundValue)



        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(ZeroCrossingBasedEdgeDetectionImageFilter self) -> uint8_t



        Get/Set the label values for the ZeroCrossingImageFilter


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetBackgroundValue(self)


    def SetMaximumError(self, MaximumError):
        """
        SetMaximumError(ZeroCrossingBasedEdgeDetectionImageFilter self, double MaximumError)



        Set the MaximumError parameter needed by the embedded gaussian filter
        This value is used to set the desired maximum error of the gaussian
        approximation. Maximum error is the difference between the area under
        the discrete Gaussian curve and the area under the continuous
        Gaussian. Maximum error affects the Gaussian operator size. The value
        must be between 0.0 and 1.0.


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_SetMaximumError(self, MaximumError)


    def GetMaximumError(self):
        """
        GetMaximumError(ZeroCrossingBasedEdgeDetectionImageFilter self) -> double



        Standard get/set macros for Gaussian filter parameters.


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetMaximumError(self)


    def GetName(self):
        """
        GetName(ZeroCrossingBasedEdgeDetectionImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ZeroCrossingBasedEdgeDetectionImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ZeroCrossingBasedEdgeDetectionImageFilter self, Image image1) -> Image
        Execute(ZeroCrossingBasedEdgeDetectionImageFilter self, Image image1, double variance, uint8_t foregroundValue, uint8_t backgroundValue, double maximumError) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_Execute(self, *args)

ZeroCrossingBasedEdgeDetectionImageFilter_swigregister = _SimpleITK.ZeroCrossingBasedEdgeDetectionImageFilter_swigregister
ZeroCrossingBasedEdgeDetectionImageFilter_swigregister(ZeroCrossingBasedEdgeDetectionImageFilter)


def ZeroCrossingBasedEdgeDetection(image1, variance=1, foregroundValue=1, backgroundValue=0, maximumError=0.1):
    """
    ZeroCrossingBasedEdgeDetection(Image image1, double variance=1, uint8_t foregroundValue=1, uint8_t backgroundValue=0, double maximumError=0.1) -> Image



    This filter implements a zero-crossing based edge detecor.


    This function directly calls the execute method of ZeroCrossingBasedEdgeDetectionImageFilter in order to support a procedural API


    See:
     itk::simple::ZeroCrossingBasedEdgeDetectionImageFilter for the object oriented interface



    """
    return _SimpleITK.ZeroCrossingBasedEdgeDetection(image1, variance, foregroundValue, backgroundValue, maximumError)
class ZeroCrossingImageFilter(ImageFilter_1):
    """


    This filter finds the closest pixel to the zero-crossings (sign
    changes) in a signed itk::Image .


    Pixels closest to zero-crossings are labeled with a foreground value.
    All other pixels are marked with a background value. The algorithm
    works by detecting differences in sign among neighbors using city-
    block style connectivity (4-neighbors in 2d, 6-neighbors in 3d, etc.).

    Inputs and Outputs
    The input to this filter is an itk::Image of arbitrary dimension. The algorithm assumes a signed data type
    (zero-crossings are not defined for unsigned data types), and requires
    that operator>, operator<, operator==, and operator!= are defined.

    The output of the filter is a binary, labeled image of user-specified
    type. By default, zero-crossing pixels are labeled with a default
    "foreground" value of itk::NumericTraits<OutputDataType>::OneValue() , where OutputDataType is the data type of the output image. All
    other pixels are labeled with a default "background" value of itk::NumericTraits<OutputDataType>::ZeroValue() .
    Parameters
    There are two parameters for this filter. ForegroundValue is the value
    that marks zero-crossing pixels. The BackgroundValue is the value
    given to all other pixels.

    See:
     Image

     Neighborhood

     NeighborhoodOperator

     NeighborhoodIterator
    Wiki Examples:

    All Examples

    Find zero crossings in a signed image
    See:
     itk::simple::ZeroCrossing for the procedural interface

     itk::ZeroCrossingImageFilter for the Doxygen on the original ITK class.



    C++ includes: sitkZeroCrossingImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZeroCrossingImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZeroCrossingImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ZeroCrossingImageFilter self) -> ZeroCrossingImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ZeroCrossingImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ZeroCrossingImageFilter
    __del__ = lambda self: None

    def SetForegroundValue(self, ForegroundValue):
        """
        SetForegroundValue(ZeroCrossingImageFilter self, uint8_t ForegroundValue)



        Set/Get the label value for zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_SetForegroundValue(self, ForegroundValue)


    def GetForegroundValue(self):
        """
        GetForegroundValue(ZeroCrossingImageFilter self) -> uint8_t



        Set/Get the label value for zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_GetForegroundValue(self)


    def SetBackgroundValue(self, BackgroundValue):
        """
        SetBackgroundValue(ZeroCrossingImageFilter self, uint8_t BackgroundValue)



        Set/Get the label value for non-zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_SetBackgroundValue(self, BackgroundValue)


    def GetBackgroundValue(self):
        """
        GetBackgroundValue(ZeroCrossingImageFilter self) -> uint8_t



        Set/Get the label value for non-zero-crossing pixels.


        """
        return _SimpleITK.ZeroCrossingImageFilter_GetBackgroundValue(self)


    def GetName(self):
        """
        GetName(ZeroCrossingImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ZeroCrossingImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ZeroCrossingImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ZeroCrossingImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ZeroCrossingImageFilter self, Image image1) -> Image
        Execute(ZeroCrossingImageFilter self, Image image1, uint8_t foregroundValue, uint8_t backgroundValue) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ZeroCrossingImageFilter_Execute(self, *args)

ZeroCrossingImageFilter_swigregister = _SimpleITK.ZeroCrossingImageFilter_swigregister
ZeroCrossingImageFilter_swigregister(ZeroCrossingImageFilter)


def ZeroCrossing(image1, foregroundValue=1, backgroundValue=0):
    """
    ZeroCrossing(Image image1, uint8_t foregroundValue=1, uint8_t backgroundValue=0) -> Image



    This filter finds the closest pixel to the zero-crossings (sign
    changes) in a signed itk::Image .


    This function directly calls the execute method of ZeroCrossingImageFilter in order to support a procedural API


    See:
     itk::simple::ZeroCrossingImageFilter for the object oriented interface



    """
    return _SimpleITK.ZeroCrossing(image1, foregroundValue, backgroundValue)
class ZeroFluxNeumannPadImageFilter(ImageFilter_1):
    """


    Increase the image size by padding according to the zero-flux Neumann
    boundary condition.


    A filter which extends the image size and fill the missing pixels
    according to a Neumann boundary condition where first, upwind
    derivatives on the boundary are zero. This is a useful condition in
    solving some classes of differential equations.

    For example, invoking this filter on an image with a corner like: returns the following padded image:


    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.

    See:
     WrapPadImageFilter , MirrorPadImageFilter , ConstantPadImageFilter , ZeroFluxNeumannBoundaryCondition

     itk::simple::ZeroFluxNeumannPad for the procedural interface

     itk::ZeroFluxNeumannPadImageFilter for the Doxygen on the original ITK class.


    C++ includes: sitkZeroFluxNeumannPadImageFilter.h

    """

    __swig_setmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZeroFluxNeumannPadImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageFilter_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZeroFluxNeumannPadImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        __init__(itk::simple::ZeroFluxNeumannPadImageFilter self) -> ZeroFluxNeumannPadImageFilter



        Default Constructor that takes no arguments and initializes default
        parameters


        """
        this = _SimpleITK.new_ZeroFluxNeumannPadImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_ZeroFluxNeumannPadImageFilter
    __del__ = lambda self: None

    def SetPadLowerBound(self, PadLowerBound):
        """
        SetPadLowerBound(ZeroFluxNeumannPadImageFilter self, VectorUInt32 PadLowerBound)



        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_SetPadLowerBound(self, PadLowerBound)


    def GetPadLowerBound(self):
        """
        GetPadLowerBound(ZeroFluxNeumannPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_GetPadLowerBound(self)


    def SetPadUpperBound(self, PadUpperBound):
        """
        SetPadUpperBound(ZeroFluxNeumannPadImageFilter self, VectorUInt32 PadUpperBound)



        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_SetPadUpperBound(self, PadUpperBound)


    def GetPadUpperBound(self):
        """
        GetPadUpperBound(ZeroFluxNeumannPadImageFilter self) -> VectorUInt32



        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_GetPadUpperBound(self)


    def GetName(self):
        """
        GetName(ZeroFluxNeumannPadImageFilter self) -> std::string



        Name of this class


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_GetName(self)


    def __str__(self):
        """
        __str__(ZeroFluxNeumannPadImageFilter self) -> std::string



        Print ourselves out


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter___str__(self)


    def Execute(self, *args):
        """
        Execute(ZeroFluxNeumannPadImageFilter self, Image image1) -> Image
        Execute(ZeroFluxNeumannPadImageFilter self, Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) -> Image



        Execute the filter on the input image with the given parameters


        """
        return _SimpleITK.ZeroFluxNeumannPadImageFilter_Execute(self, *args)

ZeroFluxNeumannPadImageFilter_swigregister = _SimpleITK.ZeroFluxNeumannPadImageFilter_swigregister
ZeroFluxNeumannPadImageFilter_swigregister(ZeroFluxNeumannPadImageFilter)


def ZeroFluxNeumannPad(*args, **kwargs):
    """
    ZeroFluxNeumannPad(Image image1, VectorUInt32 padLowerBound, VectorUInt32 padUpperBound) -> Image



    Increase the image size by padding according to the zero-flux Neumann
    boundary condition.


    This function directly calls the execute method of ZeroFluxNeumannPadImageFilter in order to support a procedural API


    See:
     itk::simple::ZeroFluxNeumannPadImageFilter for the object oriented interface



    """
    return _SimpleITK.ZeroFluxNeumannPad(*args, **kwargs)
class PyCommand(Command):
    """Proxy of C++ itk::simple::PyCommand class."""

    __swig_setmethods__ = {}
    for _s in [Command]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyCommand, name, value)
    __swig_getmethods__ = {}
    for _s in [Command]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyCommand, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(itk::simple::PyCommand self) -> PyCommand"""
        this = _SimpleITK.new_PyCommand()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SimpleITK.delete_PyCommand
    __del__ = lambda self: None

    def SetCallbackPyCallable(self, obj):
        """SetCallbackPyCallable(PyCommand self, PyObject * obj)"""
        return _SimpleITK.PyCommand_SetCallbackPyCallable(self, obj)


    def GetCallbackPyCallable(self):
        """GetCallbackPyCallable(PyCommand self) -> PyObject *"""
        return _SimpleITK.PyCommand_GetCallbackPyCallable(self)


    def Execute(self):
        """
        Execute(PyCommand self)



        The method that defines action to be taken by the command


        """
        return _SimpleITK.PyCommand_Execute(self)

PyCommand_swigregister = _SimpleITK.PyCommand_swigregister
PyCommand_swigregister(PyCommand)

# This file is compatible with both classic and new-style classes.


